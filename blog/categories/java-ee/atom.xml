<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java_ee | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/java-ee/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2013-09-22T23:41:35+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JMS 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/07/13/jms_101/"/>
    <updated>2012-07-13T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/07/13/jms_101</id>
    <content type="html"><![CDATA[<p>本文中內容，主要以<a href="http://activemq.apache.org/" title="http://activemq.apache.org/">ActiveMQ
5.4</a>為主，若不是此版本，程式碼不一定可以執行</p>

<blockquote><p>JMS 2 於2013年Q1 release,使用者更會簡單，也內建訊息延遲發送功能(目前每一個使用方式都不一樣)，如果沒有相容性問題，建議採 JMS 2.0</p></blockquote>

<h1>基本觀念</h1>

<h3>JMS 基本元素</h3>

<ul>
<li>provider :</li>
<li>client : 產出(傳送)或消費(接收)訊息</li>
<li>consumer : 消費(接收)訊息</li>
<li>message : 在client間被傳遞的訊息物件</li>
<li><p>destination : 信息的目的或<strong>來源</strong></p>

<ol>
<li>queue : 訊息佇列,destination在PTP叫queue</li>
<li>topic :
一個散佈訊息給多個訂閱者的機制,destination在pub/sub叫topic</li>
</ol>
</li>
<li><p>session : thread context，用來producing/consuming messages</p></li>
<li>Administered Objects</li>
</ul>


<h3>Messaging Domains</h3>

<h5>Point-to-Point Messaging Domain （PTP）</h5>

<ul>
<li>基於queues, senders, and receivers的模型</li>
<li>每一個message<strong>同時只有一個</strong>Consumer</li>
<li>Consumer跟Producer沒有時間的依賴性，Producer發送訊息後，Consumer可以隨時上去接收</li>
<li>Consumer回應訊息處理狀態</li>
</ul>


<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_001.gif" alt="jms_101_001.gif" /></p>

<h5>Publish/Subscribe Messaging Domain (pub/sub)</h5>

<ul>
<li><p>主要就三個要素</p>

<ol>
<li>Publisher 發佈者:發佈訊息</li>
<li>Subscriber 訂閱者: 訂閱訊息</li>
<li>Topic 訊息的閱者，為發佈者或訂閱者之間的channel</li>
</ol>
</li>
<li><p>Broadcast型的結構</p></li>
<li>每一個Topic<strong>可以多個</strong>Subscribers</li>
<li>Subscriber跟Publisher<strong>有</strong>時間的依賴性，Subscriber可以必須先進行訂閱後，才會收到Producer發佈的Topic</li>
<li><p>Subscriber 依連線方式可以分為</p>

<ol>
<li>Nondurable Subscribers : 必須一直保持在接收狀態^<a href="#fn__1">1)</a>^</li>
<li>Durable Subscribers :
建立後，如以inactive，當active後，會將累積的訊息一起收下來</li>
</ol>
</li>
<li><p>Subscriber 依建立方式可分為</p>

<ol>
<li>Dynamic Subscribers : 程式動態建立</li>
<li>Administered Subscribers : 由provider (server)建立</li>
</ol>
</li>
</ul>


<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_002.gif" alt="jms_101_002.gif" /></p>

<h3>JMS API</h3>

<p>在JMS裡，上述的觀念，主要是透過JMS API來定義的，JMS
API只是定義規格(類似於JDBC)，至於實作會由其他實作的vendors提供，JMS
API主要的類似如下：</p>

<ul>
<li>ConnectionFactory</li>
<li>Destination</li>
<li>Connection</li>
<li>Session</li>
<li>Message</li>
<li>MessageProducer</li>
<li>MessageConsumer</li>
</ul>


<h1>建立Connection/Session的流程</h1>

<p>不論是PTP或是pub/sub模組，要跟MessageQuery
Server溝通的流程是差不多的，流程如下</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_003.gif" alt="jms_101_003.gif" /></p>

<ol>
<li>建立ConnectionFactory</li>
<li>由ConnectionFactory建立Connection</li>
<li>由Connection建立Session</li>
<li>由Session建立訊息(包含訊息內容，目的(Destination)，模型，…)</li>
</ol>


<h3>與Message Server建立連線</h3>

<h4>由ActiveMQ提供的ActiveMQConnectionFactory建立connection</h4>

<p>```</p>

<pre><code>// ActiveMQConnectionFactory是ActiveMQ專屬寫法，會有平台跟lib依賴性，可用jndi來解決這個問題
factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
connection = factory.createConnection();
connection.start(); 
</code></pre>

<p>```</p>

<p>剛建立好後的connection是在停止狀態的，必需先啟動才有辦法使用，一般啟動後，不用特別去stop，因為stop也會一併停止接受來自mq
server的訊息，但是如果不希望connection一直連著，可以把他close掉</p>

<h4>用JNDI的方式建立connection</h4>

<p>這種方式比較通用，不會依賴特定平台的API</p>

<p>```</p>

<pre><code>Properties env = new Properties();
env.put(Context.SECURITY_PRINCIPAL, "system");
env.put(Context.SECURITY_CREDENTIALS, "manager");
env.put(Context.INITIAL_CONTEXT_FACTORY,"org.apache.activemq.jndi.ActiveMQInitialContextFactory");
env.put(Context.PROVIDER_URL, "tcp://localhost:61616");
InitialContext ctx = new InitialContext(env);
TopicConnectionFactory conFactory = (TopicConnectionFactory)ctx.lookup(topicFactory);
</code></pre>

<p>```</p>

<h3>建立Session</h3>

<h4>用傳統的方式建立Session</h4>

<p><code>
connection = factory.createConnection();
connection.start();
session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
</code></p>

<h4>用Annotation的方式建立connection</h4>

<p>這種方式，需要DI Container的支援</p>

<p>```</p>

<pre><code>@Resource(lookup = "jms/Queue")
private static Queue queue;
 
@Resource(lookup = "jms/Topic")
private static Topic topic;
</code></pre>

<p>```</p>

<h1>Hello JMS</h1>

<p>以下是幾個比較完整(可執行)的範例，可以在ActiveMQ的web admin(ex:
<a href="http://localhost:8161/admin/queues.jsp" title="http://localhost:8161/admin/queues.jsp">http://localhost:8161/admin/queues.jsp</a>
)畫面上看到息的狀態</p>

<h3>傳送訊息 (PTP)</h3>

<p>```</p>

<pre><code>@Test
public void sendMessagePTP() throws JMSException {
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616"); // 記得先確定61616 port的service有enabled
    Connection connection = factory.createConnection();
    connection.start();
    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    Destination destination = session.createQueue("queue1"); // 建立PTP message,Destination為"queue1"
    MessageProducer sender = session.createProducer(destination);
    TextMessage message = session.createTextMessage("Hello World!");
    sender.send(message);
}
</code></pre>

<p>```</p>

<p>執行後可以在ActiveMQ的”Queue”看到”queue1”的message</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_005.png" alt="jms_101_005.png" /></p>

<ul>
<li>Number Of Pending Messages: 在queue等待處理的訊息的數量</li>
<li>Number Of Consumers:
連線中，正在等待訊息的Consumers的數量(正在listening的client的數量)</li>
<li>Messages Enqueued : 進入佇列的訊息數量</li>
<li>Messages Dequeued : 離開佇列的訊息數量</li>
</ul>


<h3>取得訊息 (PTP)</h3>

<p>```</p>

<pre><code>@Test
public void retrieveMessagePTP() throws Exception {
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616"); // 記得先確定61616 port的service有enabled
    Connection connection = factory.createConnection();
    connection.start();
    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    Destination destination = session.createQueue("queue1"); // 建立PTP message,Destination為"queue1"
    MessageConsumer consumer = session.createConsumer(destination);
    System.out.println(consumer.receive());
    // 取回的訊息如下(內容會依執行環境的不同而不同)
    // ActiveMQTextMessage {commandId = 5, responseRequired = true, messageId = ID:kent-PC-4384-1294370677008-0:0:1:1:1, originalDestination = null, originalTransactionId = null, producerId = ID:kent-PC-4384-1294370677008-0:0:1:1, destination = queue://queue1, transactionId = null, expiration = 0, timestamp = 1294370677215, arrival = 0, brokerInTime = 1294370677215, brokerOutTime = 1294370677264, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 0, properties = null, readOnlyProperties = true, readOnlyBody = true, droppable = false, text = Hello World!}
}
</code></pre>

<p>```</p>

<h3>建立Topic (Pub/Sub)</h3>

<p>```</p>

<pre><code>@Test
public void createTopic() throws Exception {
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
    TopicConnection connection = factory.createTopicConnection();
    connection.start();
    TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
    Topic topic = session.createTopic("MyTopic");
    TopicPublisher publisher = session.createPublisher(topic);
}
</code></pre>

<p>```</p>

<p>執行後可以在ActiveMQ的”Topic”看到”MyTopic”</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_006.png" alt="jms_101_006.png" /></p>

<h3>建立Topic並發佈訊息 (Pub/Sub)</h3>

<p>```</p>

<pre><code>@Test
public void createTopicAndPublishMessage() throws Exception {
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
    TopicConnection connection = factory.createTopicConnection();
    connection.start();
    TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
    Topic topic = session.createTopic("MyTopic2");
    TopicPublisher publisher = session.createPublisher(topic);
    TextMessage message = session.createTextMessage("MyTopic2 Message Body");
    publisher.publish(message);
}
</code></pre>

<p>```</p>

<p>執行後可以在ActiveMQ的”Topic”看到”MyTopic2”，”Messages Enqueued”會加1</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_006.png" alt="jms_101_006.png" /></p>

<h3>訂閱Topic</h3>

<p>```</p>

<pre><code>@Test
public void subscribeMessage() throws Exception {
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
    TopicConnection connection = factory.createTopicConnection();
    connection.start();
    TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
    Topic topic = session.createTopic("MyTopic2");
    TopicSubscriber subscriber = session.createSubscriber(topic);
    System.out.println(subscriber.receive()); // 執行後，會停在這一行，直到有訊息被取回
    // result
    // ActiveMQTextMessage {commandId = 7, responseRequired = false, messageId = ID:kent-PC-2524-1294364408121-4:5:1:1:3, originalDestination = null, originalTransactionId = null, producerId = ID:kent-PC-2524-1294364408121-4:5:1:1, destination = topic://MyTopic2, transactionId = null, expiration = 0, timestamp = 1294375382476, arrival = 0, brokerInTime = 1294375382477, brokerOutTime = 1294375382478, correlationId = , replyTo = null, persistent = false, type = , priority = 0, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 0, properties = null, readOnlyProperties = true, readOnlyBody = true, droppable = false, text = MyMessage}
 
    // 也可以設定timeout，如果timeout前都沒有取到訊息，會傳回null
    // System.out.println(subscriber.receive(10 * 1000)); // 執行後，會停在這一行，直到有訊息被取回或10秒後timeout，並傳回null
    // result
    // null
}
</code></pre>

<p>```</p>

<p>以上面的例子來說，如果是同步接受的，一收完訊息，程式會馬上往下執行，並結速，這樣便無法一直接到MQ
Server的訊息，
如果想持續一直收到MQ的訊息，可以recive()後加一個無限迴圈，讓程式不會結束，即可以一直收到訊息</p>

<p>```
TopicSubscriber subscriber = session.createSubscriber(topic);
subscriber.recive();
connection.start();
while (true) {</p>

<pre><code>// prevent main thread stop 
</code></pre>

<p>}
```</p>

<p>執行後可以在ActiveMQ的”Topic”看到”MyTopic2”，”Number Of Consumers”會加1</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_007.png" alt="jms_101_007.png" /></p>

<p>程式會一直hold住(如果沒設timeout的話)，此時，可以透過”Send
To”的hyperlink，讓”MyTopic2”發佈一個訊息，這樣”subscriber.receive()“就會取得”MyTopic2”發佈的訊息了.</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_008.png" alt="jms_101_008.png" /></p>

<h1>JMS API使用說明</h1>

<h2>Destination</h2>

<p>Destination的結構如下</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_004.png" alt="jms_101_004.png" /></p>

<p>Destination本身是一個空的Interface，它主要是要標明，Destination的概念，底下有Queue(用在PTP)跟Topic(用在Pub/Sub)兩個介面繼承自Destination</p>

<p><code>
package javax.jms;
 
public interface Destination {
}
</code></p>

<h2>PTP model</h2>

<h4>Producing / Consuming Message</h4>

<p>```</p>

<pre><code>MessageConsumer consumer = session.createConsumer(dest);
MessageConsumer consumer = session.createConsumer(queue);
MessageConsumer consumer = session.createConsumer(topic);
 
connection.start();
Message m = consumer.receive();
connection.start();
Message m = consumer.receive(1000); // time out after a second
</code></pre>

<p>```</p>

<h4>Queue Browsers</h4>

<p><code>
QueueBrowser browser = session.createBrowser(queue);
</code></p>

<h2>Pub/Sub model</h2>

<h2>Message</h2>

<h3>Message Header</h3>

<table>
<thead>
<tr>
<th>  Header Field       </th>
<th> Set By                  </th>
<th> description</th>
</tr>
</thead>
<tbody>
<tr>
<td>  JMSDestination     </td>
<td> send or publish method  </td>
<td> 訊息的目的地</td>
</tr>
<tr>
<td>  JMSDeliveryMode    </td>
<td> send or publish method  </td>
<td> DeliveryMode.NON_PERSISTENT (不存到DB) or DeliveryMode.PERSISTENT (存到DB)</td>
</tr>
<tr>
<td>  JMSExpiration      </td>
<td> send or publish method  </td>
<td> 訊息過期的時間</td>
</tr>
<tr>
<td>  JMSPriority        </td>
<td> send or publish method  </td>
<td> 0-9的值(9最高)，0-4是一般,5-9是 “加急”</td>
</tr>
<tr>
<td>  JMSMessageID       </td>
<td> send or publish method  </td>
<td> 一個唯一的訊息id字串</td>
</tr>
<tr>
<td>  JMSTimestamp       </td>
<td> send or publish method  </td>
<td> 訊息傳送的時間</td>
</tr>
<tr>
<td>  JMSCorrelationID   </td>
<td> Client                  </td>
<td> 相關的id (參閱<a href="#jmscorrelationid" title="java:jms_101 ↵">下面</a>的說明)</td>
</tr>
<tr>
<td>  JMSReplyTo         </td>
<td> Client                  </td>
<td> 讓client知道，要”回信”給誰</td>
</tr>
<tr>
<td>  JMSType            </td>
<td> Client                  </td>
<td> <a href="#message_type" title="java:jms_101 ↵">Message Type</a></td>
</tr>
<tr>
<td>  JMSRedelivered     </td>
<td> JMS provider            </td>
<td> 值為true或false，指明message之前是否沒有被consumer成功取回</td>
</tr>
</tbody>
</table>


<p>只有 Set By
Client的header需要進行設定，其他的大部份是由send或publish的method設定.</p>

<h5>JMSCorrelationID</h5>

<p>在大多數的情況下，JMSCorrelationID會是指回應那一個JMSMessageID，但JMSCorrelationID可以是任何的值，不見得要是JMSMessageID.
一般也會被拿來放Application-specific ID.</p>

<h5>Message Type</h5>

<table>
<thead>
<tr>
<th>  Message Type   </th>
<th> Body Contains</th>
</tr>
</thead>
<tbody>
<tr>
<td>  TextMessage    </td>
<td> A java.lang.String object (for example, the contents of an XML file).</td>
</tr>
<tr>
<td>  MapMessage     </td>
<td> A set of name-value pairs, with names as String objects and values as primitive types in the Java programming language. The entries can be accessed sequentially by enumerator or randomly by name. The order of the entries is undefined.</td>
</tr>
<tr>
<td>  BytesMessage   </td>
<td> A stream of uninterpreted bytes. This message type is for literally encoding a body to match an existing message format.</td>
</tr>
<tr>
<td>  StreamMessage  </td>
<td> A stream of primitive values in the Java programming language, filled and read sequentially.</td>
</tr>
<tr>
<td>  ObjectMessage  </td>
<td> A Serializable object in the Java programming language.</td>
</tr>
<tr>
<td>  Message        </td>
<td> Nothing. Composed of header fields and properties only. This message type is useful when a message body is not required.</td>
</tr>
</tbody>
</table>


<h3>Message Property</h3>

<p>Property像是message的metadata，可以放入一些特定的屬性，之後可以透過<a href="#message_selectors" title="java:jms_101 ↵">Message
Selectors</a>的功能來做查詢。^<a href="#fn__2">2)</a>^</p>

<p>```</p>

<pre><code>TextMessage message = pubSession.createTextMessage();
message.setText(text);
message.setStringProperty("username",username);
publisher.publish(message);
</code></pre>

<p>```</p>

<h5>JMS-Defined Properties &amp; Provider-Specific Properties</h5>

<p>另外，還會有JMS訂義的JMS-Defined Properties及Provider-Specific
Properties</p>

<p>JMS-Defined Properties</p>

<ol>
<li>JMSXUserID</li>
<li>JMSXAppID</li>
<li>JMSXProducerTXID</li>
<li>JMSXConsumerTXID</li>
<li>JMSXRcvTimestamp</li>
<li>JMSXDeliveryCount</li>
<li>JMSXState</li>
<li>JMSXGroupID</li>
<li>JMSXGroupSeq</li>
</ol>


<h3>Message Selectors</h3>

<p>Message
Selectors的功能，是在Messages中過濾出需要的部份，Messages只對針對property進行過濾，不能針對message
body做過濾，但可以透過簡單的expression來操作properties.</p>

<p><code>
String filter = "(currentRate - newRate) &gt;= 1.0";
TopicSubscriber subscriber = session.createSubscriber(topic, filter, true);
</code></p>

<p>currentRate範例中的<code>currentRate</code>跟<code>newRate</code>是message的User定義的<a href="#message_property" title="java:jms_101 ↵">properties</a></p>

<p>Message Selectors的語法是SQL 92的子集，可以用許多SQL
92的運算符來作為expression的一部份，ex:</p>

<p><code>
Shares &gt; 1000.0 AND Symbol LIKE 'A%C'
</code></p>

<p><strong>Message Filtering approach VS Multiple Destination approach</strong></p>

<p>在設計時，可以採用Message Filtering或Multiple
Destination的方式進行訊息的分類</p>

<p>Message Filtering approach
:是所有的訊息進到同一個Destination後透過selector進行分類選取。</p>

<p>Multiple Destination
approach:是不同類的訊息，一開始就分派到不同的Destination。</p>

<h3>Message Persistent</h3>

<p>Message可以選擇Persistent或Nonpersistent,Persistent的訊息是存在db或file，Nonpersistent只是放在memory
所以Nonpersistent的訊息，在server重啟後就不見了，如果是Persistent，server重啟後，還是會存在。</p>

<p>Persistent或Nonpersistent是由JMSDeliveryMode決定。</p>

<h1>Acknowledge Mode</h1>

<p>Acknowledge
Mode是用來確定訊息傳遞的可靠性的，需要做Acknowledge(回應，確認)的是在傳送或接收(發佈或訂閱)訊息時，client用來回應provider訊息有確實收到的機制</p>

<p>Acknowledge Mode是在建立session時決定的。</p>

<p>```</p>

<pre><code>Session = Connect.createTopicSession(false, Session.CLIENT_ACKNOWLEDGE);
Session = Connect.createQueueSession(false, Session.DUPS_OK_ACKNOWLEDGE);
</code></pre>

<p>```</p>

<p>Acknowledge Mode有以下幾種</p>

<ol>
<li><a href="#auto_acknowledge" title="java:jms_101 ↵">AUTO_ACKNOWLEDGE</a> 自動回應</li>
<li><a href="#client_acknowledge" title="java:jms_101 ↵">CLIENT_ACKNOWLEDGE</a>
由客戶端自行回應</li>
<li><a href="#dups_ok_acknowledge" title="java:jms_101 ↵">DUPS_OK_ACKNOWLEDGE</a>
可重覆的回應</li>
</ol>


<h4>AUTO_ACKNOWLEDGE</h4>

<p>只要訊息成功被傳送或接收，就會產生回應，而且最多只會回應一次(once-and-only-once)</p>

<h4>CLIENT_ACKNOWLEDGE</h4>

<p>如果客戶端需在傳送時接受訊息後，先進行一些額外的處理，等這些額外的處理直正的成功後，才進行回應，如果失敗的話(或沒回應的話)，訊息就不會被產生出來(或消化掉)</p>

<h4>DUPS_OK_ACKNOWLEDGE</h4>

<p>如果不介意訊息被重覆的傳送或接收，可以用這個模式，<strong>DUPS_OK_ACKNOWLEDGE</strong>
mode，其最大的特色就是效能會有顯著的提昇。 要使用這個模式，需要把
<code>JMSRedelivered</code>屬性設為<code>true</code></p>

<h1>Transactions</h1>

<p>Transactions是用來做批量messages的處理，用來保證所有的messages都有被成功的同時送出或取回。</p>

<p>Transactions的啟用方式是將createSession的第一個參數設為true，第二個參數將會被忽略，當所以有訊息被處理後，可以透過<code>session.commit()</code>提交或<code>session.rollback()</code>取消。</p>

<p><code>
Session session = connection.createSession(true, Session.SESSION_TRANSACTED);;
</code></p>

<h1>Transport Connectors (ActiveMQ)</h1>

<p>ActiveMQ提供許多連線的Protocol叫Transport Connectors,Transport
Connectors所使用的ports是透過ActiveMQ_HOME/conf/activemq.xml進行設定。</p>

<p>```</p>

<!-- The transport connectors ActiveMQ will listen to -->


<p><transportConnectors>
<transportConnector name="openwire" uri="tcp://localhost:61616"
discoveryUri="multicast://default"/>
<transportConnector name="ssl" uri="ssl://localhost:61617"/>
<transportConnector name="stomp" uri="stomp://localhost:61613"/>
<transportConnector name="xmpp" uri="xmpp://localhost:61222"/>
</transportConnectors>
```</p>

<h3>連線格式</h3>

<p>JMS是透過URIs當做連線格式</p>

<p><code>
&lt;scheme&gt;:&lt;scheme-specific-part&gt;
&lt;scheme&gt;://&lt;authority&gt;&lt;path&gt;&lt;?query&gt;
</code></p>

<p>ex:</p>

<p><code>
tcp://localhost:61616
tcp://hostname:port?key=value&amp;key=value
</code></p>

<p>特別需要注意的是 JMS 亦提供composite URIs</p>

<p><code>
static://(tcp://host1:61616, tcp://host2:61616)
</code></p>

<h5>Protocol</h5>

<ol>
<li>tcp</li>
<li>nio</li>
<li>ssl (需要認證)</li>
<li>http/https (80 port)</li>
<li>VM (with other JVM)</li>
</ol>


<p>如果有許多clients需要連線到MQ，
連線數可能會受到OS限制，這時可以採用NIO的protocol</p>

<p><code>
nio://hostname:port?key=value
</code></p>

<h1>遠端監控ActiveMQ</h1>

<p>有時需要取得MQ上面的連線資訊或管理MQ
Server，此時可以透過JMX的功能進行監控。 要進行JMX前，可以需先開啟設定</p>

<p>```</p>

<pre><code>&lt;managementContext&gt;
    &lt;managementContext createConnector="true"/&gt; 
&lt;/managementContext&gt;
</code></pre>

<p>```</p>

<p>把managementContext/managementContext的createConnector屬性設成true即可</p>

<p>完成後，重新啟動mq，然後，可以先用jdk內建的jconsole(jdk/bin/jconsole.exe)做連線測試</p>

<p>啟動jconsole後，remote process填入</p>

<p><code>
service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi
</code></p>

<p>填入後，按連線即可(本例中，mq跟jconsole在同一台，所以用localhost，如果不同一台，需先確認1099的port沒被防火牆擋住)，
連線成功後，即可取得MQ的相關資訊，需要的內容會在MBeans的tab頁上</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-13/jms_101_009.png" alt="jms_101_009.png" /></p>

<p>確定可以用jconsole連線後，便可以使用程式取得連線資訊</p>

<p><code>
RemoteJMXBrokerFacade createConnector = new RemoteJMXBrokerFacade();
System.setProperty("webconsole.jmx.url", "service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi");
SystemPropertiesConfiguration configuration = new SystemPropertiesConfiguration();
createConnector.setConfiguration(configuration);
// 可透過brokerAdmin取得broker上的資訊
BrokerViewMBean brokerAdmin = createConnector.getBrokerAdmin();
String brokerName = brokerAdmin.getBrokerName();
brokerAdmin.getTotalConsumerCount();  
brokerAdmin.getTotalMessageCount();
</code></p>

<h1>Resources</h1>

<ul>
<li><a href="http://download.oracle.com/javaee/6/tutorial/doc/bncdr.html" title="http://download.oracle.com/javaee/6/tutorial/doc/bncdr.html">Java Message Service Concepts - The Java EE 6
Tutorial</a>

<ul>
<li>文章圖片來源大多來自這裡</li>
</ul>
</li>
<li><a href="http://wenku.baidu.com/view/f90394aad1f34693daef3ee8.html" title="http://wenku.baidu.com/view/f90394aad1f34693daef3ee8.html">ActiveMQ in
action</a></li>
<li><a href="http://wenku.baidu.com/view/a7a05927a5e9856a5612609a.html" title="http://wenku.baidu.com/view/a7a05927a5e9856a5612609a.html">ActiveMQ in
action(中文)</a></li>
</ul>


<p>[java</p>

<p>^<a href="#fnt__1">1)</a>^ Durable Subscribe可以不用一直保持連線狀態</p>

<p>^<a href="#fnt__2">2)</a>^ message body本身是沒辦法做查詢的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JPA 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/07/12/jpa_101/"/>
    <updated>2012-07-12T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/07/12/jpa_101</id>
    <content type="html"><![CDATA[<p>Java Persistence API(JPA)</p>

<h1>Where to put the persistence.xml</h1>

<ul>
<li>for web application → WEB-INF/classes/META-INF/persistence.xml</li>
<li>for jar →</li>
<li>for maven main folder → src/main/resource/META-INF/persistence.xml</li>
<li>for maven test folder → src/test/resource/META-INF/persistence.xml</li>
</ul>


<p>If uses maven structure in Eclipse IDE, main resource and test resource
would complied to same directory(the build directory), we should avoid
using the same <strong>persistence-unit</strong> name in test and main resources</p>

<h1>presitence.xml</h1>

<h3>Hibernate</h3>

<p>```
&lt;?xml version="1.0" encoding="UTF-8"?>
<persistence version="1.0" xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"></p>

<pre><code>&lt;persistence-unit name="entity" transaction-type="RESOURCE_LOCAL"&gt;
    &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
    &lt;class&gt;com.kent.MyClass&lt;/class&gt;
    &lt;properties&gt;
        &lt;property name="hibernate.hbm2ddl.auto" value="update" /&gt;
        &lt;property name="hibernate.dialect" value="org.hibernate.dialect.MySQLDialect" /&gt;
        &lt;property name="hibernate.connection.driver_class" value="com.mysql.jdbc.Driver" /&gt;
        &lt;property name="hibernate.connection.url" value="jdbc:mysql://localhost/database_name" /&gt;
        &lt;property name="hibernate.connection.username" value="root" /&gt;
        &lt;property name="hibernate.connection.password" value="" /&gt;
                    &lt;property name="hibernate.show_sql" value="true" /&gt;
    &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre>

<p></persistence>
```</p>

<p>set property bernate.show_sql to true to output HSQL → SQL in console.</p>

<p>```</p>

<pre><code>&lt;property name="hibernate.dialect" value="org.hibernate.dialect.MySQLDialect" /&gt;
&lt;property name="hibernate.connection.driver_class" value="com.mysql.jdbc.Driver" /&gt;
&lt;property name="hibernate.connection.url" value="jdbc:mysql://localhost/database_name" /&gt;
</code></pre>

<p>```</p>

<p>```</p>

<pre><code>&lt;property name="hibernate.connection.url" value="jdbc:hsqldb:mem:database_name"/&gt;
&lt;property name="hibernate.connection.driver_class" value="org.hsqldb.jdbcDriver"/&gt;
&lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/&gt;
</code></pre>

<p>```</p>

<p>```</p>

<pre><code>&lt;property name="hibernate.connection.url" value="jdbc:derby:memory:database_name"/&gt;
&lt;property name="hibernate.connection.driver_class" value="org.apache.derby.jdbc.EmbeddedDriver"/&gt;
&lt;property name="hibernate.dialect" value="org.hibernate.dialect.DerbyDialect"/&gt;
</code></pre>

<p>```</p>

<p>```</p>

<pre><code>&lt;property name="hibernate.connection.url" value="jdbc:postgresql://localhost:5432/databaseName"/&gt;
&lt;property name="hibernate.connection.driver_class" value="org.postgresql.Driver"/&gt;
&lt;property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/&gt;
</code></pre>

<p>```</p>

<p>MySQL encoding issue. If you encountered encoding issue when result set
contains CJK code, you can add this property to url connection string.
<code>?useUnicode=true&amp;amp;characterEncoding=UTF-8</code> ex:</p>

<p><code>
  jdbc:mysql://localhost/database_name?useUnicode=true&amp;amp;characterEncoding=UTF-8
</code></p>

<h3>EclipseLink - MySQL</h3>

<p>```
&lt;?xml version="1.0" encoding="UTF-8"?>
<persistence version="1.0" xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"></p>

<pre><code>&lt;persistence-unit name="entity" transaction-type="RESOURCE_LOCAL"&gt;
&lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;class&gt;com.kent.MyClass&lt;/class&gt;
    &lt;properties&gt;
        &lt;property name="eclipselink.target-database" value="MYSQL"/&gt;
        &lt;property name="eclipselink.jdbc.url" value="jdbc:mysql://localhost/database_name"/&gt;
        &lt;property name="eclipselink.jdbc.driver" value="com.mysql.jdbc.Driver"/&gt;
        &lt;property name="eclipselink.jdbc.user" value="root"/&gt;
        &lt;property name="eclipselink.jdbc.password" value=""/&gt;
        &lt;property name="eclipselink.ddl-generation" value="update-tables"/&gt;
        &lt;property name="eclipselink.logging.level" value="SEVERE"/&gt;
    &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre>

<p></persistence>
```</p>

<h3>EclipseLink - HSQL</h3>

<p>```
&lt;?xml version="1.0" encoding="UTF-8"?>
<persistence version="1.0" xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"></p>

<pre><code>&lt;persistence-unit name="entity" transaction-type="RESOURCE_LOCAL"&gt;
&lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;class&gt;com.kent.MyClass&lt;/class&gt;
    &lt;properties&gt;
        &lt;property name="eclipselink.target-database" value="HSQL"/&gt;
        &lt;property name="eclipselink.jdbc.url" value="jdbc:hsqldb:mem:database_name"/&gt;
        &lt;property name="eclipselink.jdbc.driver" value="org.hsqldb.jdbcDriver"/&gt;
        &lt;property name="eclipselink.jdbc.user" value="sa"/&gt;
        &lt;property name="eclipselink.jdbc.password" value=""/&gt;
        &lt;property name="eclipselink.ddl-generation" value="create-tables"/&gt;
        &lt;property name="eclipselink.logging.level" value="SEVERE"/&gt;
    &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre>

<p></persistence>
```</p>

<h1>Properties</h1>

<p>EclipseLink does NOT support the property <code>show sql</code> like hibernate, but
we can turn the logging system to <code>FINE</code> level
(<code>&lt;property name=“eclipselink.logging.level” value=“FINE”/&gt;</code>), the
interpret SQL would be dumped.</p>

<h1>CRUD</h1>

<p><strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete operations in JPA</p>

<p>Read類型的methods像find(), getReference(), refresh(), detach() and read
queries，可以在transaction外執行(沒有tx.begin()/tx.commit()的包覆).</p>

<h4>Create</h4>

<p><code>
entityManager.getTransaction().begin();
Employee newEmployee = new Employee(5);
entityManager.persist(newEmployee);
entityManager.getTransaction().commit();
</code></p>

<h4>Read</h4>

<p><code>
entityManager.find(Employee.class, 1);
// lazy load (as same as hibernate load() method)
entityManager.getReference(Employee.class, 1);
entityManager.createQuery("select employee from Employee employee");
</code></p>

<ul>
<li>for single result uses <code>query.getSingleResult()</code>;</li>
<li>for multiple results (result set) uses <code>query.getResultList()</code>;</li>
</ul>


<h4>Update</h4>

<p><code>
entityManager.getTransaction().begin();
Employee existingEmployee = entityManager.find(Employee.class, 5);
existingEmployee.setLastName("NewLastName");
entityManager.getTransaction().commit();
</code></p>

<p>or</p>

<p><code>
Employee existingEmployee = entityManager.find(Employee.class, 5);
existingEmployee.setLastName("NewLastName");
 
entityManager.getTransaction().begin();
entityManager.getTransaction().commit();
</code></p>

<h4>Delete</h4>

<p><code>
entityManager.getTransaction().begin();
Employee existingEmployee = entityManager.find(Employee.class, 5);
entityManager.remove(existingEmployee);
entityManager.getTransaction().commit();
</code></p>

<h3>Bulk Update / Delete</h3>

<h4>Bulk Update</h4>

<p>```
EntityManager entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();
String jpqlUpdate = "update Customer set name = :newName where name = :oldName"
int updatedEntities = entityManager.createQuery( jpqlUpdate )</p>

<pre><code>                        .setParameter( "newName", newName )
                        .setParameter( "oldName", oldName )
                        .executeUpdate();
</code></pre>

<p>entityManager.getTransaction().commit();
entityManager.close();
```</p>

<h4>Bulk Delete</h4>

<p>```
EntityManager entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();
String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = entityManager.createQuery( hqlDelete )</p>

<pre><code>                        .setParameter( "oldName", oldName )
                        .executeUpdate();
</code></pre>

<p>entityManager.getTransaction().commit();
entityManager.close();
```</p>

<h1>Tips</h1>

<ul>
<li>Using wrapper type rather than primitive type to avoid <a href="http://stackoverflow.com/questions/2565352/whats-difference-between-primitive-and-wrapper-class-in-jpa-hibernate-column-m" title="http://stackoverflow.com/questions/2565352/whats-difference-between-primitive-and-wrapper-class-in-jpa-hibernate-column-m">null
assinged
issue</a>.</li>
</ul>


<h1>FK constraint violation</h1>

<p>Sometime the forgine key constraint that export by DDL tools would be a
problem when doing unit testing. But there is no way to disable
hibernate FK constraints exports. In the situation we can rewrite the
Dialect to prevent FK constraints exported.</p>

<p>In this case, we created our own H2Dialet (for <a href="http://www.h2database.com/html/main.html" title="http://www.h2database.com/html/main.html">H2
database</a>)
and let <code>getAddForeignKeyConstraintString()</code> method empty. Which will
disable the original <code>org.hibernate.dialect.H2Dialect</code> constraint
generating statement.</p>

<p>```
package com.kent.hibernate.dialect;</p>

<p>public class H2Dialect extends org.hibernate.dialect.H2Dialect {</p>

<pre><code>@Override
public String getAddForeignKeyConstraintString(String constraintName, String[] foreignKey, String referencedTable, String[] primaryKey, boolean referencesPrimaryKey) {
    return "";
}
</code></pre>

<p>}
```</p>

<p>Once we have the Dialect, we need apply it our persistence.xml, after
done, when the schema be generated, the schema will not include any FK
constraint.</p>

<p>```
&lt;?xml version="1.0" encoding="UTF-8"?>
<persistence version="1.0" xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"></p>

<pre><code>&lt;persistence-unit name="entity-test" transaction-type="RESOURCE_LOCAL"&gt;
    &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
             ...
    &lt;properties&gt;
        ...
        &lt;property name="hibernate.hbm2ddl.auto" value="create-drop" /&gt;
                    &lt;property name="hibernate.dialect" value="com.kent.hibernate.dialect.H2Dialect"/&gt;
        ...
    &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre>

<p></persistence>
```</p>

<h1>JPA Query</h1>

<p>JPA Query supports</p>

<ol>
<li>query</li>
<li><strong>update</strong></li>
<li><strong>delete</strong></li>
</ol>


<p>function to retrieves, modify, remove data from database.</p>

<h5>IS [NOT] EMPTY</h5>

<p>JPA provides a <strong>empty</strong> to test a collection empty or not:</p>

<p><code>
select book from Book book where book.chapters is not empty
</code></p>

<h5>Join Fetch</h5>

<p>JPA tries to fetch any entity as LAZY as possible whatever uses JPA QL
or get by API.</p>

<p>Fetch lazy or eager is by JPA vendor implementation, not all field type
can fetch as LAZY</p>

<h3>Local Manager Transaction</h3>

<p>In a non-managed environment, an EntityManagerFactory is usually
responsible for its own database connection pool. The application
developer has to manually set transaction boundaries, in other words,
begin, commit, or rollback database transactions itself</p>

<p>If using local manager transaction, better to apply this template in
code.</p>

<p>```
// Non-managed environment idiom
EntityManager em = emf.createEntityManager();
EntityTransaction tx = null;
try {</p>

<pre><code>tx = em.getTransaction();
tx.begin();
// do some work
...
tx.commit();
</code></pre>

<p>} catch (RuntimeException e) {</p>

<pre><code>if ( tx != null &amp;&amp; tx.isActive() ) tx.rollback();
throw e; // or display error message
</code></pre>

<p>} finally {</p>

<pre><code>em.close(); // make sure you always close and never outside of guaranteed finally block
</code></pre>

<p>}
```</p>

<h3>Joins and Fetches</h3>

<ol>
<li>inner join = join</li>
<li>left out join = left join</li>
<li>fetch = 用一個select把屬性或集合一次取回</li>
<li>fetch all = 如果有lazy properties，可用fetch all去init all lazy</li>
</ol>


<h1>Expressions</h1>

<ul>
<li>is empty, is not empty</li>
<li>member of, not member of 僅適用於embedded object</li>
<li>elements 測試某個element是否在elements中</li>
<li>minimum, maximum, minindex, maxindex 可用於 array, list, map</li>
<li>KEY() and VALUE() 可用於map</li>
<li>any, some, all, exists, in 這幾個可以和elements,minimum, maximum,
minindex, maxinde 搭配使用</li>
<li>current_date(), current_time(), current_timestamp()</li>
<li>second(…), minute(…), hour(…), day(…), month(…), year(…), (specific
to HQL)</li>
<li>coalesce() and nullif() coalesce（） 取回第一個非NULL的值</li>
<li>TYPE … in …</li>
<li>cast(… as …)</li>
<li>Java public static final constants eg.Color.TABBY</li>
</ul>


<h5>member of</h5>

<p><code>
'867-5309' MEMBER OF p.phoneNumbers
</code></p>

<h5>coalesce</h5>

<p><code>
SELECT COALESCE( NULL, 34, 13, 0 )
// return 34
</code></p>

<h5>any, some, all, exists, in</h5>

<p><a href="http://twpug.net/docs/postgresql-doc-8.0-zh_TW/functions-subquery.html" title="http://twpug.net/docs/postgresql-doc-8.0-zh_TW/functions-subquery.html">any, some, all, exists,
in</a>在SQL-92中的定義</p>

<p><code>
select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)
</code></p>

<p><code>
select p from NameList list, Person p where p.name = some elements(list.names)
</code></p>

<p><code>
select cat from Cat cat where exists elements(cat.kittens)
</code></p>

<p><code>
select cat from Player p where 3 &gt; all elements(p.scores)
</code></p>

<p><code>
select cat from Show show where 'fizard' in indices(show.acts)
</code></p>

<h5>index</h5>

<p><code>
select order from Order order where order.items[0].id = 1234
</code></p>

<h5>KEY(),VALUE()</h5>

<p><code>
select i.name, VALUE(p) FROM Item i JOIN i.photos p WHERE KEY(p) LIKE ‘%egret’
</code></p>

<p>Data in collection</p>

<p><code>
public List&lt;Role&gt; listRolesByPermissions(Set&lt;String&gt; permissions) {
  String ql = "select role from Role role left join role.permissions p where p in (:perms)";
  Query q = entityManager.createQuery(ql).setParameter("perms", permissions);
  return q.getResultList();
}
</code></p>

<p>上面的例子採用naming parameter可以正常動作，但下面採用position
parameter的方式卻不行？</p>

<p><code>
public List&lt;Role&gt; listRolesByPermissions(Set&lt;String&gt; permissions) {
  String ql = "select role from Role role left join role.permissions p where p in (?)";
  Query q = entityManager.createQuery(ql).setParameter(1, permissions);
  return q.getResultList();
}
</code></p>

<h1>Implementation Restrictions</h1>

<p>To avoid conflicts with the original database operation that fires the
entity lifecycle event (which is still in progress) callback methods
should not call <code>EntityManager</code> or <code>Query</code> methods and should not access
other entity objects.</p>

<p>If a callback method throws an exception within an active transaction,
the transaction is marked for rollback and no more callback methods are
invoked for that operation.</p>

<h1>Architecture</h1>

<h4>EntityManagerFactory</h4>

<p>建立時會比較耗時耗資源，所以應隨server啟動而啟動，關閉而關閉.</p>

<h4>EntityManager</h4>

<p>The EntityManager API is used to access a database in a particular unit
of work. 正常來說，EntityManager的life cycle應該是一個database
transaction(也就是說，應隨著transaction committed而close),
但也可以跨多個database
transactions(跟hibernate的session一樣，可以跟多個transaction).
如果發生任何例外的話，應該要立即呼叫<code>EntityManager.close()</code>，並且棄用EntityManager
instance.</p>

<h1>Annotations</h1>

<p>如果需要讓boolean有預設值，可透過<code>@Column</code>的<code>columnDefinition</code>屬性</p>

<p><code>
@Column(columnDefinition = "bool default false")
private boolean   boolField;
</code></p>

<p>如果要讓欄位接受null，要宣告成物件型別(Object
type)而非原生型別(primitive type)</p>

<h1>Resources</h1>

<ul>
<li><a href="http://wiki.eclipse.org/Using_EclipseLink_JPA_Extensions_%28ELUG%29" title="http://wiki.eclipse.org/Using_EclipseLink_JPA_Extensions_%28ELUG%29">EclipseLink
properties</a></li>
<li><a href="http://docs.jboss.org/hibernate/stable/annotations/reference/en/html_single/" title="http://docs.jboss.org/hibernate/stable/annotations/reference/en/html_single/">hibernate annotations reference
manual</a></li>
<li><a href="http://docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/index.html" title="http://docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/index.html">hibernate Entity Manager reference
manual</a></li>
<li><a href="http://en.wikibooks.org/wiki/Java_Persistence" title="http://en.wikibooks.org/wiki/Java_Persistence">JPA 2 on
wikibook</a></li>
<li><a href="http://wiki.kent-chiu.com/lib/exe/fetch.php?media=java:jpa_mapping.pdf" title="java:jpa_mapping.pdf">A JavaTM Persistence API Mapping Magical Mystery
Tour</a>

<ul>
<li>相當清晰的MAPPING介紹</li>
</ul>
</li>
<li><a href="http://uaihebert.com/?p=1274" title="http://uaihebert.com/?p=1274">JPA Queries and
Tips</a> -
JPA的使用實例，有不到best practices的使用</li>
</ul>


<p>[java</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Weld 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/20/weld_101/"/>
    <updated>2012-03-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/20/weld_101</id>
    <content type="html"><![CDATA[<ul>
<li>@Model = @Named + @RequestScoped</li>
<li>The @Named annotation just makes it possible to reference the bean
from the EL</li>
<li>it isn't necessary to create a getter or setter method to inject one
bean into another. CDI can access an injected field directly (even
if it's private!)</li>
<li>Bean could be invoked by Unified EL.</li>
<li>A bean type is a user-defined class or interface.</li>
<li>Bean types may be restricted to an explicit set by annotating the
bean with the @Typed annotation</li>
<li>If an injection point does not explicitly specify a qualifier, it
has the default qualifier, @Default.</li>
<li>Don't assign a scope other than @Dependent to an entity class</li>
<li>@Produces used in factory method.

<ul>
<li>@Alternative usually used in testing and must be enabled by config</li>
</ul>
</li>
<li></li>
</ul>


<h1>Fixing unsatisfied and ambiguous dependencies</h1>

<h4>To fix an unsatisfied dependency, either:</h4>

<ul>
<li>create a bean which implements the bean type and has all the
qualifier types of the injection point,</li>
<li>make sure that the bean you already have is in the classpath of the
module with the injection point, or</li>
<li>explicitly enable an @Alternative bean that implements the bean type
and has the appropriate qualifier types, using beans.xml.</li>
</ul>


<h4>To fix an ambiguous dependency, either:</h4>

<ul>
<li>introduce a qualifier to distinguish between the two implementations
of the bean type,</li>
<li>disable one of the beans by annotating it @Alternative,</li>
<li>move one of the implementations to a module that is not in the
classpath of the module with the injection point, or</li>
<li>disable one of two @Alternative beans that are trying to occupy the
same space, using beans.xml.</li>
</ul>


<p>[java</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Contexts and Dependency Injection 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/20/cdi_101/"/>
    <updated>2012-03-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/20/cdi_101</id>
    <content type="html"><![CDATA[<p>除了一般DI的功能外，CDI多了Context
Sensitive，Context在HTTP中，指的是Request, Response, Session,
Application, …這些scopes. 當然還有搭配這些scope用的decorators,
interceptors。
使用CDI最重要的事，莫過於決定物件要binding的scopes，針對這些scopes的使用時機如下：</p>

<ul>
<li><a href="#dependent" title="java:cdi_101 ↵">Dependent</a></li>
<li><a href="#applicationscoped" title="java:cdi_101 ↵">ApplicationScoped</a></li>
<li><a href="#requestscoped" title="java:cdi_101 ↵">RequestScoped</a></li>
<li><a href="#sessionscoped" title="java:cdi_101 ↵">SessionScoped</a></li>
<li><a href="#conversationscoped" title="java:cdi_101 ↵">ConversationScoped</a></li>
<li><a href="#stateless" title="java:cdi_101 ↵">Stateless</a> ^<a href="#fn__1">1)</a>^</li>
</ul>


<h3>Dependent</h3>

<p><strong>預設</strong>的scope，生命週期與被@injected的物件相同。</p>

<h3>ApplicationScoped</h3>

<p>跟著application server啟動而啟動，停止而停止的。</p>

<p>適用於比較特別的services(stateful), helper classes, 或sharing
data(全局的權限或計數器)。</p>

<p>read only的service也很適合，因為不需要考慮thread safe的問題</p>

<h3>RequestScoped</h3>

<p>http request的scope。</p>

<p>適用於做http request溝通，常被當作網頁與程式邏輯間的DTO使用。</p>

<h3>SessionScoped</h3>

<p>http session的scope，隨sesion的建立而開始，session消滅而結束。</p>

<p>適用需要跟著使用者跑的資料或服務(像認證資訊或權限資訊)。</p>

<h3>ConversationScoped</h3>

<p>沒用過，不清楚，文件上是說常通比session短，但比request長的一個scope.</p>

<h3>Stateless</h3>

<p>這個應該不算是一個scope，但一般的service methods
(objects)應該都屬stateless的。</p>

<h1>TBD</h1>

<ol>
<li>EL操作webbean方式</li>
<li>單元測試</li>
<li>CDI與JPA</li>
<li>decorators</li>
<li>interceptors</li>
<li>events</li>
<li>@Producers</li>
<li>@Disposers</li>
</ol>


<p>[java</p>

<p>^<a href="#fnt__1">1)</a>^ 並沒有這種scope</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bean Validator 101(JSR 303)]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/20/bean_validator_101/"/>
    <updated>2012-03-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/20/bean_validator_101</id>
    <content type="html"><![CDATA[<h5>@Valid</h5>

<p>當需要對field為其他複雜物件型別(Complex Object
Type)進行驗証時，可以透過<code>@Valid</code>.也可以對collection類別進行驗証。也就是說，可以對以下型別進行驗証：</p>

<ol>
<li>arrays</li>
<li>implement java.lang.Iterable (especially Collection, List and Set)</li>
<li>implement java.util.Map</li>
</ol>


<p>```</p>

<pre><code>package javax.validation;
 
import java.util.Set;
import javax.validation.metadata.BeanDescriptor;
 
public interface Validator {
    /**
     * Validates all constraints on object.
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups);
 
    /**
     * Validates all constraints placed on the property of object
     * named propertyName.
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object, String propertyName, Class&lt;?&gt;... groups);
 
    /**
     * Validates all constraints placed on the property named propertyName
     * of the class beanType would the property value be value
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType, String propertyName, Object value, Class&lt;?&gt;... groups);
 
    /**
     * Return the descriptor object describing bean constraints.
     * The returned object (and associated objects including
     * ConstraintDescriptors) are immutable.
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);
 
    /**
     * Return an instance of the specified type allowing access to
     * provider-specific APIs.  If the Bean Validation provider
     * implementation does not support the specified class,
     * ValidationException is thrown.
     */
    public &lt;T&gt; T unwrap(Class&lt;T&gt; type);
}
</code></pre>

<p>```</p>

<h3>Validating groups</h3>

<p>驗証群組功能，驗証郡組是可以就多個Entities的某些規則郡組化(grouping)並針對group<strong>s</strong>做驗証</p>

<h3>Payload</h3>

<p>用來夾帶(attch)客制的metadata。</p>

<p>[java</p>
]]></content>
  </entry>
  
</feed>
