<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: best_practice | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/best-practice/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2014-06-27T00:01:08+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective Java Item List]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/05/25/effective_java_item_list/"/>
    <updated>2012-05-25T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/05/25/effective_java_item_list</id>
    <content type="html"><![CDATA[<p>This item list come for <a href="http://java.sun.com/docs/books/effective/toc.html" title="http://java.sun.com/docs/books/effective/toc.html">Effective Java Second Edition</a></p>

<h1>Creating and Destroying Objects</h1>

<h4>Item 1: Consider static factory methods instead of constructors</h4>

<h4>Item 2: Consider a builder when faced with many constructor parameters</h4>

<h4>Item 3: Enforce the singleton property with a private constructor or an enum type</h4>

<h4>Item 4: Enforce noninstantiability with a private constructor</h4>

<h4>Item 5: Avoid creating unnecessary objects</h4>

<h4>Item 6: Eliminate obsolete object references</h4>

<h4>Item 7: Avoid finalizers</h4>

<h1>Methods Common to All Objects</h1>

<h4>Item 8: Obey the general contract when overriding equals</h4>

<h4>Item 9: Always override hashCode when you override equals</h4>

<h4>Item 10: Always override toString</h4>

<h4>Item 11: Override clone judiciously</h4>

<h4>Item 12: Consider implementing Comparable</h4>

<h1>Classes and Interfaces</h1>

<h4>Item 13: Minimize the accessibility of classes and members</h4>

<h4>Item 14: In public classes, use accessor methods, not public fields</h4>

<h4>Item 15: Minimize mutability</h4>

<h4>Item 16: Favor composition over inheritance</h4>

<h4>Item 17: Design and document for inheritance or else prohibit it</h4>

<h4>Item 18: Prefer interfaces to abstract classes</h4>

<h4>Item 19: Use interfaces only to define types</h4>

<h4>Item 20: Prefer class hierarchies to tagged classes</h4>

<h4>Item 21: Use function objects to represent strategies</h4>

<h4>Item 22: Favor static member classes over nonstatic</h4>

<p>除非member classes有存取到outter class的nonstatic
method，不然，應該把member classes宣告為statics</p>

<h1>Generics</h1>

<h4>Item 23: Don't use raw types in new code</h4>

<h4>Item 24: Eliminate unchecked warnings</h4>

<h4>Item 25: Prefer lists to arrays</h4>

<h4>Item 26: Favor generic types</h4>

<h4>Item 27: Favor generic methods</h4>

<p>```</p>

<pre><code>// Generic method
public static &lt;E&gt;Set&lt;E&gt;union(Set&lt;E&gt;s1, Set&lt;E&gt;s2) {
    Set&lt;E&gt;result = new HashSet&lt;E&gt;(s1);
    result.addAll(s2);
    return result;
}
</code></pre>

<p>```</p>

<h4>Item 28: Use bounded wildcards to increase API flexibility</h4>

<h4>Item 29: Consider typesafe heterogeneous containers</h4>

<p>利用加上Class&lt;T>來確定T的型別</p>

<p>```</p>

<pre><code>// Typesafe heterogeneous container pattern - API
public class Favorites {
public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);
public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);
}
</code></pre>

<p>```</p>

<h1>Enums and Annotations</h1>

<h4>Item 30: Use enums instead of int constants</h4>

<h4>Item 31: Use instance fields instead of ordinals</h4>

<h4>Item 32: Use EnumSet instead of bit fields</h4>

<p>如果要用位元開關的效果，可以考慮用EnumSet</p>

<h4>Item 33: Use EnumMap instead of ordinal indexing</h4>

<p>如果需要對Enum進行排序，可以用EnumMap</p>

<h4>Item 34: Emulate extensible enums with interfaces</h4>

<p>Enum是無法繼承的，如果需要類似的功能，可以考慮用interfaces</p>

<p>```</p>

<pre><code>// Emulated extensible enum using an interface
public interface Operation {
    double apply(double x, double y);
}
 
public enum BasicOperation implements Operation {
    PLUS("+") {
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS("-") {
        public double apply(double x, double y) {
            return x - y;
        }
    },
    TIMES("*") {
        public double apply(double x, double y) {
            return x * y;
        }
    },
    DIVIDE("/") {
        public double apply(double x, double y) {
            return x / y;
        }
 
        private final String  symbol;
 
        BasicOperation(String symbol) {
            this.symbol = symbol;
        }
 
        @Override
        public String toString() {
            return symbol;
        }
    }
};
 
// Emulated extension enum
public enum ExtendedOperation implements Operation {
    EXP("^") {
        public double apply(double x, double y) {
            return Math.pow(x, y);
        }
    },
    REMAINDER("%") {
        public double apply(double x, double y) {
            return x % y;
        }
    };
    private final String  symbol;
 
    ExtendedOperation(String symbol) {
        this.symbol = symbol;
    }
 
    @Override
    public String toString() {
        return symbol;
    }
}
</code></pre>

<p>```</p>

<h4>Item 35: Prefer annotations to naming patterns</h4>

<p>只要想到要用method
name的rule做判斷邏輯時，可以考慮用annotations或許會更彈性</p>

<h4>Item 36: Consistently use the Override annotation</h4>

<h4>Item 37: Use marker interfaces to define types</h4>

<h1>Methods</h1>

<h4>Item 38: Check parameters for validity</h4>

<h4>Item 39: Make defensive copies when needed</h4>

<h4>Item 40: Design method signatures carefully</h4>

<h4>Item 41: Use overloading judiciously</h4>

<h4>Item 42: Use varargs judiciously</h4>

<h4>Item 43: Return empty arrays or collections, not nulls</h4>

<h4>Item 44: Write doc comments for all exposed API elements</h4>

<h1>General Programming</h1>

<h4>Item 45: Minimize the scope of local variables</h4>

<h4>Item 46: Prefer for-each loops to traditional for loops</h4>

<h4>Item 47: Know and use the libraries</h4>

<h4>Item 48: Avoid float and double if exact answers are required</h4>

<h4>Item 49: Prefer primitive types to boxed primitives</h4>

<h4>Item 50: Avoid strings where other types are more appropriate</h4>

<h4>Item 51: Beware the performance of string concatenation</h4>

<h4>Item 52: Refer to objects by their interfaces</h4>

<h4>Item 53: Prefer interfaces to reflection</h4>

<h4>Item 54: Use native methods judiciously</h4>

<h4>Item 55: Optimize judiciously</h4>

<h4>Item 56: Adhere to generally accepted naming conventions</h4>

<h1>Exceptions</h1>

<h4>Item 57: Use exceptions only for exceptional conditions</h4>

<h4>Item 58: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors</h4>

<p>checked exceptions應該是來被rescue的，只有能被復原的狀況，才用check
exception</p>

<h4>Item 59: Avoid unnecessary use of checked exceptions</h4>

<h4>Item 60: Favor the use of standard exceptions</h4>

<h4>Item 61: Throw exceptions appropriate to the abstraction</h4>

<h4>Item 62: Document all exceptions thrown by each method</h4>

<h4>Item 63: Include failure-capture information in detail messages</h4>

<h4>Item 64: Strive for failure atomicity</h4>

<h4>Item 65: Don't ignore exceptions</h4>

<h1>Concurrency</h1>

<h4>Item 66: Synchronize access to shared mutable data</h4>

<h4>Item 67: Avoid excessive synchronization</h4>

<h4>Item 68: Prefer executors and tasks to threads</h4>

<h4>Item 69: Prefer concurrency utilities to wait and notify</h4>

<h4>Item 70: Document thread safety</h4>

<h4>Item 71: Use lazy initialization judiciously</h4>

<h4>Item 72: Don't depend on the thread scheduler</h4>

<h4>Item 73: Avoid thread groups</h4>

<h1>Serialization</h1>

<h4>Item 74: Implement Serializable judiciously</h4>

<h4>Item 75: Consider using a custom serialized form</h4>

<h4>Item 76: Write readObject methods defensively</h4>

<h4>Item 77: For instance control, prefer enum types to readResolve</h4>

<h4>Item 78: Consider serialization proxies instead of serialized instances</h4>
]]></content>
  </entry>
  
</feed>
