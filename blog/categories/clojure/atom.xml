<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2014-09-18T16:50:57+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java 8 lambda]]></title>
    <link href="http://blog.kent-chiu.com/blog/2014/03/14/java-8-lambda/"/>
    <updated>2014-03-14T12:47:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2014/03/14/java-8-lambda</id>
    <content type="html"><![CDATA[<p>基本語法:</p>

<p>``` java</p>

<pre><code>    (parameters) -&gt; expression
or
    (parameters) -&gt; { statements; }

(parameters) -&gt; expression
(x, y) -&gt; x + y;    // 計算 x + y 的結果
(String name) -&gt; System.out.println("Hi! " + name); 

(parameters) -&gt; { statements; }
x -&gt; { x + 1; x + 2; x + 3; return x; } 
</code></pre>

<p>```</p>

<p>參數的型別如果沒有指定的，會進行類型推斷(type infer)</p>

<h4>functional interface</h4>

<p>只有定義一個抽象方法的interface叫"functional interface"，functional interface主要的用途是做 lambda expression.</p>

<p>在對lambda的使用還不熟悉時，可以先用anonymous class來一步一步轉換成lambda</p>

<p>``` java</p>

<pre><code>// Stream裡filter method的宣告，filter method需要傳入一個Predicate的interface
public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; {
    Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);
}    

// Predicate主要是透過test這個method來解決結果是true，或false 
@FunctionalInterface
public interface Predicate&lt;T&gt; {
    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);
}
</code></pre>

<p>```</p>

<p>sample:</p>

<p>``` java</p>

<pre><code>    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    list.add(1);
    list.add(2);
    list.add(3);
    list.add(4);
    list.add(5);

    // 先用anonymous實作，這邊就可以看出來，如果Predicate有超過一個的abstract method，
    Predicate&lt;Integer&gt; predicate = new Predicate&lt;Integer&gt;() {
        @Override
        public boolean test(Integer i) {
            return i &gt; 3;
        }
    };

    // 執行後，results會只包含list中大於3的數，所以為4,5這兩個數字    
    List&lt;Integer&gt; results = list.stream().filter(predicate).collect(Collectors.toList());

    // 傳成lambda時，因為Predicate是function interface，只有一個abstract method，
    // 所以，我們可以很清楚的知道，我們要實作的method是`public boolean test(Integer i)`
    // 傳入的參數為Integer, 而實作的logic為判斷參數是否大於3
    Predicate&lt;Integer&gt; predicate = (Integer i) -&gt; {return i &gt; 3;};

    // java8的compier類型推斷(type infer)能力變強了，可以compiler可以由程式的上下文(context)猜出正確的型別，
    // lambda expression可以再簡化如下
    Predicate&lt;Integer&gt; predicate = (i) -&gt; {return i &gt; 3;};

    // 再把冗餘的括號點去掉，lambda expression預設會return最後一行的值，所以，return也可以去掉    
    Predicate&lt;Integer&gt; predicate = i -&gt; i &gt; 3;

    // 在filter中套上predicate
    List&lt;Integer&gt; results = list.stream().filter(predicate).collect(Collectors.toList());

    // 對predicate執行 inline variable的refactory
    List&lt;Integer&gt; results = list.stream().filter(i -&gt; i &gt; 3).collect(Collectors.toList());
</code></pre>

<p>```</p>

<p>在Predicate中，還有幾個default method，主要是用來輔助Predicate的使用，例如我們想取出上面相反的結果(不是大於3的值)，
直覺的方式，就是判斷的邏輯 <code>i&gt;3</code> 改寫成 <code>!(i &gt; 3)</code>，而Predicate.negate()這個default method就是在做這件事</p>

<p>``` java</p>

<pre><code>    Predicate&lt;Integer&gt; predicate = i -&gt; i &gt; 3;  // 先把lambda express從filter method中extract出來
    Predicate&lt;Integer&gt; negate = predicate.negate(); // 取反向的值 
    List&lt;Integer&gt; results = list.stream().filter(negate).collect(Collectors.toList()); // 得到的results為 1, 2, 3
</code></pre>

<p>```</p>

<p>可以看到，我們用<code>predicate.negate()</code>就不用直接改寫原來的邏輯，只要直接對predicate做negate的運算即可。</p>

<p>Predicate還有幾個default methods都是在做Predicate運算時常會用到的，功用跟<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Predicates.html">guava lib中的Predicats</a>類型，
Predicate function interface 的完整程式如下</p>

<p>``` java</p>

<pre><code>    @FunctionalInterface
    public interface Predicate&lt;T&gt; {
        boolean test(T t);

        default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) {
            Objects.requireNonNull(other);
            return (t) -&gt; test(t) &amp;&amp; other.test(t);
        }

        default Predicate&lt;T&gt; negate() {
            return (t) -&gt; !test(t);
        }

        default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) {
            Objects.requireNonNull(other);
            return (t) -&gt; test(t) || other.test(t);
        }
        static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) {
            return (null == targetRef)
                    ? Objects::isNull
                    : object -&gt; targetRef.equals(object);
        }
    }
</code></pre>

<p>```</p>

<h4>lambda expression</h4>

<p>A lambda expression is an instance of a functional interface</p>

<h4>lambda expression常見的參數為</h4>

<ul>
<li>Predicate：接受一個參數，對參數做評估後返回一個boolean的值
ex: 過濾條件時，傳入過濾條件的參數，如果成立(true) 就進行過濾</li>
<li>Function：接受一個參數並產出結果
ex: 輸入字串，返回數字</li>
<li>Supplier：不接受参數，並返回結果
ex: 對stream中的元素計算後產生資料</li>
<li>Consumer：接受一個參數，但不返回結果(返回void)
ex: 經function運算後，影響輸入的結果(副作用)</li>
</ul>


<p>上面的class都是零元或一元運算子，還有二元運算子，功能類似，差異之處是在都是接受兩個參數</p>

<ul>
<li>BiConsumer</li>
<li>BiFunction</li>
<li>BiPredicate</li>
</ul>


<h1>RESOURCE</h1>

<ul>
<li><a href="http://www.techempower.com/blog/2013/03/26/everything-about-java-8/">http://www.techempower.com/blog/2013/03/26/everything-about-java-8/</a></li>
<li><a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/">http://winterbe.com/posts/2014/03/16/java-8-tutorial/</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html">http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html</a> - reduce</li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html">http://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html</a> - Java 8 中的 Streams API 详解</li>
</ul>

]]></content>
  </entry>
  
</feed>
