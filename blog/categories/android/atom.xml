<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2014-01-01T17:07:48+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 模擬器 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/12/28/android_emulator_101/"/>
    <updated>2012-12-28T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/12/28/android_emulator_101</id>
    <content type="html"><![CDATA[<p>Android Emulator是
QEMU-based的應用程式，主要功能是在PC上建立一個虛擬的Android平台環境，並提供一個GUI的仿手機介面以供操作。
Android
Emulator可以模擬任何Android平台的任何功能，可以模擬手機應用程式執行情形，也可以模擬Native
Code的功能。
模擬器有可客制化功能，可以在runtime時選定要用那一種角析度的LCD，要支援什麼樣的硬體設備(攝影機、錄音功能、簡訊、GPS…)</p>

<h3>啟動</h3>

<p>可以透過EclipseADT啟動，也可以直接從Command Line啟動</p>

<h4>透過Eclipse ADT啟動</h4>

<p><img src="http://blog.kent-chiu.com/images/2012-12-28/android_emulator_101_01.png" alt="android_emulator_101_01.png" /></p>

<p>你可以加入許多<a href="http://developer.android.com/guide/developing/tools/emulator.html#startup-options" title="http://developer.android.com/guide/developing/tools/emulator.html#startup-options">啟動參數</a>來設定啟動後的環境，
比如說是否啟用debug mode，是否套用特定的skin等。</p>

<p>在Eclipse ADT中加入啟動參數的方法是在menu > Run Configuration > Target
tab</p>

<p><img src="http://blog.kent-chiu.com/images/2012-12-28/android_emulator_101_03.png" alt="android_emulator_101_03.png" /></p>

<h4>從Command Line啟動</h4>

<p>透過command line啟動的方式如下：</p>

<p><code>
emulator -avd AVD2
</code></p>

<p>AVD2是上圖的ADV Name，那個是建立<strong>A</strong>ndroid <strong>V</strong>irtual
<strong>D</strong>evice建，其中一個步驟要求輸入的內容</p>

<h5>啟動後的畫面</h5>

<p>啟動時需要幾秒到幾分鐘的時間(一個完整的OS在VM中啟動，當然要花些時間)，啟動後，你可以一直讓模擬器維持開啟狀況，不必隨著你的程式的關閉而關閉。</p>

<p><img src="http://blog.kent-chiu.com/images/2012-12-28/android_emulator_101_02.png" alt="android_emulator_101_02.png" /></p>

<h1>解析度</h1>

<ul>
<li>QVGA 320×240, 120dpi, 3.3</li>
<li>WQVGA432 432×240, 120dpi, 3.9</li>
<li>HVGA 480×320, 160dpi, 3.6</li>
<li>WVGA800 800×480, 240dpi, 3.9</li>
<li>WVGA854 854×480, 240dpi, 4.1</li>
</ul>


<p><img src="http://cdn3.techbang.com.tw/system/images/23074/original/ex_1_wv1.jpg" alt="" /></p>

<p>圖片來源
<a href="http://www.techbang.com.tw/posts/3053-search-text-to-explain-words-wvga-high-resolution-handheld-devices-necessary?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+techbang+%28T%E5%AE%A2%E9%82%A6+%E6%9C%80%E6%96%B0%E6%96%87%E7%AB%A0%29&amp;utm_content=Google+Reader" title="http://www.techbang.com.tw/posts/3053-search-text-to-explain-words-wvga-high-resolution-handheld-devices-necessary?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+techbang+%28T%E5%AE%A2%E9%82%A6+%E6%9C%80%E6%96%B0%E6%96%87%E7%AB%A0%29&amp;utm_content=Google+Reader">T客邦</a></p>

<p>在啟動模擬器前，還有一個啟動選項(Launch Options)畫面，將scale to real
size勾選，可以讓模擬器瑩幕的大小跟實際在手機上看到比較接近。
這樣可以確定實際按鍵的大小，比較容易評量會不會因為按鍵太小而不容易操作。</p>

<p><img src="http://blog.kent-chiu.com/images/2012-12-28/android_emulator_101_004.png" alt="android_emulator_101_004.png" /></p>

<h1>Resources</h1>

<ul>
<li><a href="http://developer.android.com/guide/developing/tools/emulator.html" title="http://developer.android.com/guide/developing/tools/emulator.html">Android Emulator</a></li>
<li><a href="http://developer.android.com/guide/developing/tools/avd.html" title="http://developer.android.com/guide/developing/tools/avd.html">Android Virtual Devices</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Tips & Tricks]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/05/14/tips_and_tricks/"/>
    <updated>2012-05-14T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/05/14/tips_and_tricks</id>
    <content type="html"><![CDATA[<h3>WebView</h3>

<h5>讓WebView的內容符合手機的畫面</h5>

<p>webview常常需要去存取現在的網頁，但大部份的網頁沒有針對moible特別做處理，所以用手機去瀏灠網頁時(透過webview)，通常需要左右的捲動才要辦法看到完整的內容。
解決的方式為</p>

<pre><code>WebView webview = new WebView(getContext());
webview.getSettings().setLoadWithOverviewMode(true);
webview.getSettings().setUseWideViewPort(true);
</code></pre>

<h5>防止webview開成新的瀏灠器</h5>

<p>通常採用webview時，會希望webview
embbeded在客制的APP裡面，但預設的webview開啟url時，會開啟成新的完整的瀏灠器(含url
bar)，可以透過以下的code來防止這個行為。</p>

<pre><code>WebView webview = new WebView(getContext());
webview.setWebViewClient(new WebViewClient());
</code></pre>

<h5>防止Rotate後webview reload</h5>

<p>手機在直放改成橫放(或橫放改直放)時，activity會呼叫onCreate()重新建立activity，如果activity裡面webview元件，會造成weview的內容消失。
，可以在AndroidManifest.xml加入如下的設定來避免這種情現</p>

<pre><code>    &lt;activity android:name=".MyActivity" 
              android:label="@string/app_name" 
              android:configChanges="orientation|keyboard|keyboardHidden"&gt; 
</code></pre>

<h3>Storage</h3>

<h5>Internal Memory</h5>

<pre><code>Context.getFilesDir: /data/data/package_name/files
Context.getDir: /data/data/package_name/app_
Context.getCacheDir(): /data/data/package_name/cache
Environment.getDataDirectory(): /data
Environment.getDownloadCacheDirectory(): /cache
</code></pre>

<h5>SDCard</h5>

<pre><code>Environment.getExternalStoragePublicDirectory(): /mnt/sdcard
</code></pre>

<h3>Activity</h3>

<h4>Launch Mode</h4>

<p>Activity Launch Mode是<a href="http://developer.android.com/guide/topics/fundamentals/tasks-and-back-stack.html" title="http://developer.android.com/guide/topics/fundamentals/tasks-and-back-stack.html">current
task</a>怎麼去啟動的Activity的方式。
可以透過manifest或programming的方式來設定，但有些設定值，只有manifest有提供，沒辦法在runtime設定。</p>

<ol>
<li>standard
預設模組，一個activity可以有多個實體，每個實體分屬不同的task，一個task內也可存在多個實體</li>
<li>singleTop
如果有四個activies啟動在task內是<code>A→B→C→D</code>，D在最上面，一般模式下再啟動一次D會變<code>A→B→C→D→D</code>，但如果D是singleTop，不論啟動多少次D，都只會是<code>A→B→C→D</code></li>
<li>singleTask
如果不存在任何task中時，會建新另一個新的task，如果存在task中時，會呼叫其他task中的activity，並讓它成為top</li>
<li>singleInstance
永遠會建立最新的，但如果目前該activity已經是top，那就不會再建立</li>
</ol>


<h4>Handling Runtime Changes</h4>

<p>手機翻轉時，會重建整個Activity以便loading最新的配置內容，但有時，我們會希望可以保持Activity的部份狀態，要達到這個目的，可以透以下幾種機制</p>

<ol>
<li>透過 onSaveInstanceState()</li>
<li>透過 onRetainNonConfigurationInstance()</li>
<li>透過修改配置檔disable掉config change的事件</li>
</ol>


<h5>透過 onSaveInstanceState</h5>

<p>這個方式適用到保持可以序列化的值，像原生型別(數值，字串…)
主要是在onSaveInstanceState()被觸發時，把狀態保持在Intent，然後再onCreate()取得原本的狀態</p>

<h5>透過 onRetainNonConfigurationInstance</h5>

<p>onSaveInstanceState會有一個明顯的限制，就是不能處理太複雜或太大的資料，因為會做序列化，不但耗時，而且會佔不少記憶體空間。
如果要保留比較複雜的資料，可以透過onRetainNonConfigurationInstance()把物件的reference
hold住，之後，可以下次activity
restart時，透過getLastNonConfigurationInstance()取出</p>

<pre><code>@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
 
    final MyDataObject data = (MyDataObject) getLastNonConfigurationInstance();
    if (data == null) {
        data = loadMyData();
    }
    ...
}
</code></pre>

<p>要被hold住的物件不能跟context有任何關係，不然不旦會造成錯誤，還會造成memory
leaking</p>

<h5>透過修改配置檔disable掉config change的事件</h5>

<p>這種方式，是直接告訴activty要忽略某些configuration change</p>

<pre><code>&lt;activity
 android:configChanges="orientation|keyboardHidden"
</code></pre>

<p>一個簡單的翻轉動作，可能同時會觸發多次onConfigurationChanged()，所以，要把相關的設定都關掉，才不會有問題</p>

<h3>List View</h3>

<h5>下拉後更新 (Pull to refresh)</h5>

<p>在許多listview的應用裡可以見到這樣的應用</p>

<p><img src="http://blog.kent-chiu.com/images/2012-05-14/android-pull-to-refresh.png" alt="android-pull-to-refresh.png" /></p>

<p>這個效果的做法的基本原理，是在listview的header放一個layout，在偵測到listview的scroll事件後，讓layout進行動畫播放，再callback一個AsyncTask去取得資料再更新listview。</p>

<p>GitHub上有兩個這樣的library可用</p>

<ol>
<li><a href="https://github.com/johannilsson/android-pulltorefresh" title="https://github.com/johannilsson/android-pulltorefresh">https://github.com/johannilsson/android-pulltorefresh</a>

<ul>
<li>基本的list view pull to refresh</li>
</ul>
</li>
<li><a href="https://github.com/chrisbanes/Android-PullToRefresh" title="https://github.com/chrisbanes/Android-PullToRefresh">https://github.com/chrisbanes/Android-PullToRefresh</a>

<ul>
<li>這個專案目前比較活躍，另外也提供WebView, GridView,
PullToRefreshExpandableListView的下拉後更新，程式結構也比較清晰</li>
</ul>
</li>
</ol>


<h3>TextEdit</h3>

<h5>讓edit text不會一開始就彈出軟體鍵盤</h5>

<p>```
&lt;activity android:name="MyActivity"</p>

<pre><code>      android:windowSoftInputMode="adjustUnspecified|stateHidden"
      android:configChanges="orientation|keyboardHidden"/&gt;
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Action Bar]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/04/20/actionbar/"/>
    <updated>2012-04-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/04/20/actionbar</id>
    <content type="html"><![CDATA[<p>android 3.0+ (API level 11)</p>

<p><img src="http://developer.android.com/design/media/action_bar_basics.png" alt="img" /></p>

<ol>
<li>具有 tab 的效果，可以在多個 fragments 間切換</li>
<li>具有 options menu 的功能， options menu 在 3.0 之後會用改採 action
item 的實作呈現</li>
</ol>


<p>基本的 actionbar
應用，可以參數<a href="http://developer.android.com/design/patterns/actionbar.html" title="http://developer.android.com/design/patterns/actionbar.html">這裡</a></p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-20/actionbar_001.png" alt="actionbar_001.png" /></p>

<h5>移除 ActionBar</h5>

<p><code>
&lt;activity android:theme="@android:style/Theme.Holo.NoActionBar"&gt;
</code></p>

<p>移除後，在程式裡面呼叫 <code>getActionBar()</code> 會得到 null</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-20/actionbar_002.png" alt="actionbar_002.png" /></p>

<h5>隱藏 ActionBar</h5>

<p><code>
ActionBar actionBar = getActionBar();
actionBar.hide();
</code></p>

<h3>建立 Action Item</h3>

<p>建立 Action Item 的方式跟之前建立 Option Menu 的方式一樣，只是有些 xml
屬性不一樣</p>

<p>```</p>

<pre><code>@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.menu_foobar, menu);
    return true;
}
</code></pre>

<p>```</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"></p>

<pre><code>&lt;item android:id="@+id/menu_save"
      android:icon="@drawable/ic_menu_save"
      android:title="@string/menu_save"
      android:showAsAction="ifRoom|withText" /&gt;
</code></pre>

<p></menu>
```</p>

<p>主要的差別在 <code>android:showAsAction</code> 屬性 <strong>ifRoom</strong>
是指如果空間夠的話，放呈現該item ， <strong>withText</strong> 則是該 item 需不需要
title 。 不過，就算指定了 title ，如果空間不足時，還是 title
還是有可能不會出現，但基本上，把 id, icon, titile 視為必要屬性就好了。</p>

<h3>建立 Action View</h3>

<p>```</p>

<pre><code>&lt;item
    android:id="@+id/menu_my_action_vew"
    android:actionViewClass="com.kentchiu.MyActionView"
    android:icon="@android:drawable/ic_dialog_alert"
    android:showAsAction="always"
    android:title="my test action view"/&gt;
</code></pre>

<p>```</p>

<p>```
package com.kentchiu;
 
import android.content.Context;
import android.view.LayoutInflater;
import android.widget.LinearLayout;
 
public class MyActionView extends LinearLayout {
 </p>

<pre><code>public MyActionView(Context context) {
    super(context);
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    inflater.inflate(R.layout.action_test, this, true);
}
</code></pre>

<p>}
```</p>

<p>如果需要支援 Collapsible 的動作，就要實作
<code>android.view.CollapsibleActionView</code>。</p>

<h1>TBC</h1>

<ol>
<li>Action Provider</li>
<li>Navigation Tabs</li>
<li>Drop-down Navigation</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Drawable 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/04/17/drawable_101/"/>
    <updated>2012-04-17T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/04/17/drawable_101</id>
    <content type="html"><![CDATA[<p>這篇文章裡的原始碼我放在GITHUB上 :
<a href="https://github.com/DraculaCwg/android_exercise" title="https://github.com/DraculaCwg/android_exercise">https://github.com/DraculaCwg/android_exercise</a></p>

<p>在android中，要設計出美觀的ui，通常都跟<code>Drawable</code>相關的物件脫離不了關係，<code>Drawable</code>翻成中文為”可繪的”，</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-17/drawable_101_001.png" alt="drawable_101_001.png" /></p>

<p>由上面的類別結構圖可以得知，圖檔、顏色、動畫、圖形，漸層這些都是屬於<code>Drawable</code>的子類別。
回過頭來看所有gui元件的祖先<code>View</code>
class，裡面跟<code>Drawable</code>有關的是setBackground開頭的幾個method，
也就是說，對於所有的元件，我們都可以透過圖片、形狀、顏色、…等<code>Drawable</code>的子類別來改變元件的外觀。</p>

<p>```</p>

<pre><code>public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {
    public void setBackgroundColor(int color) {
        setBackgroundDrawable(new ColorDrawable(color));
    }
 
    public void setBackgroundColor(int color) {
       ...
    }
 
    @RemotableViewMethod
    public void setBackgroundResource(int resid) {
        if (resid != 0 &amp;&amp; resid == mBackgroundResource) {
            return;
        }
 
        Drawable d= null;
        if (resid != 0) {
            d = mResources.getDrawable(resid);
        }
        setBackgroundDrawable(d);
 
        mBackgroundResource = resid;
    }
 
    public void setBackgroundDrawable(Drawable d) {
        ...
    }
}
</code></pre>

<p>```</p>

<p>實務上比較常用的做法，是透過xml來設定元件的background，而官網文件上的<a href="http://developer.android.com/guide/topics/resources/drawable-resource.html" title="http://developer.android.com/guide/topics/resources/drawable-resource.html">Drawable
Resources</a>
裡面的xml tag都可以找到跟上面的類別相對應的tag，需要特別注意的是 .png,
.9.png,.jpg, or
.gif這些圖檔只要放在res\drawable的目錄下，就會自動依檔名變成可以直接在XML裡引用的Drawable
Resource，不需額外的tag
而另外常用的還有<code>Shape Drawable</code>這種resource，他裡面包含了處理顏色、形狀，外框的子tags</p>

<p>基本上，只要透過圖片跟Shape
Drawable，就可以玩出很多效果了，先從簡單的來好了:</p>

<h3>圖片</h3>

<p>要改變元件的外觀，最快的方式就是把元件加上背景圖片，下圖效果都是單純的把元件的背景圖片換掉而已</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-17/drawable_101_002.png" alt="drawable_101_002.png" /></p>

<p>上圖三個view，分別是用這三個圖片當底圖 (圖片來源 :
<a href="http://www.dibbus.com/2011/03/9patch-images-in-android/" title="http://www.dibbus.com/2011/03/9patch-images-in-android/">http://www.dibbus.com/2011/03/9patch-images-in-android/</a>)</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-17/drawable_101_003.png" alt="drawable_101_003.png" />
<img src="http://blog.kent-chiu.com/images/2012-04-17/drawable_101_004.png" alt="drawable_101_004.png" />
<img src="http://blog.kent-chiu.com/images/2012-04-17/drawable_101_005.png" alt="drawable_101_005.png" /></p>

<p>透過把android:background設定成圖片的resource就可以達到上面的效果</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="vertical" &gt;
</code></pre>

<p> </p>

<pre><code>&lt;TextView
    android:id="@+id/bule"
    android:layout_width="match_parent"
    android:layout_height="100dp"
    android:background="@drawable/btn_blue_matte"
    android:gravity="center"
    android:text="bule"
    android:textColor="@color/White" /&gt;
</code></pre>

<p> </p>

<pre><code>&lt;TextView
    android:id="@+id/bule_glossy"
    android:layout_width="match_parent"
    android:layout_height="100dp"
    android:background="@drawable/btn_blue_glossy"
    android:gravity="center"
    android:text="bule glossy"
    android:textColor="@color/White" /&gt;
</code></pre>

<p> </p>

<pre><code>&lt;TextView
    android:id="@+id/corner"
    android:layout_width="match_parent"
    android:layout_height="100dp"
    android:background="@drawable/btn_blue_pink_glossy"
    android:gravity="center"
    android:text="blue glossy with pink"
    android:textColor="@color/White" /&gt;
</code></pre>

<p> 
</LinearLayout>
```</p>

<h3>Shape Drawable</h3>

<p>除了用圖片，也可以用<code>Shape Drawable</code>的方式來改變元件的外觀，Shape
Drawable可以運用的tag如下</p>

<ol>
<li>&lt;corners> 圖形的四個角的形狀</li>
<li>&lt;gradient> 漸層</li>
<li>&lt;padding> 內部圖文</li>
<li>&lt;size></li>
<li>&lt;solid> 填滿的顏色</li>
<li>&lt;stroke> 外框的線條效果</li>
</ol>


<p>下面就是透過設定<code>Shape Drawable</code>的tag達到的效果</p>

<ol>
<li>第一個view是使用了數個子tag達到的</li>
<li>第二個view是只使用<code>&lt;gradient&gt;</code>做漸層</li>
<li>第三個view是只使用<code>&lt;corners&gt;</code>來設定圖形為圓角(round)</li>
<li>第四個view是只使用<code>&lt;solid&gt;</code>設定背景為綠色</li>
<li>第五個view是只使用<code>&lt;stroke&gt;</code>來設定外框的效果</li>
</ol>


<p><img src="http://blog.kent-chiu.com/images/2012-04-17/drawable_101_006.png" alt="drawable_101_006.png" /></p>

<p>```</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" &gt;
 
    &lt;TextView
        android:id="@+id/all"
        android:layout_width="match_parent"
        android:layout_height="75dp"
        android:gravity="center"
        android:background="@drawable/shape_all"
        android:textColor="@color/Black"
        android:text="shape mix" /&gt;
 
    &lt;TextView
        android:id="@+id/gradient"
        android:layout_width="match_parent"
        android:layout_height="75dp"
        android:gravity="center"
        android:background="@drawable/shape_gradient"
        android:textColor="@color/Black"
        android:text="gradient" /&gt;
 
    &lt;TextView
        android:id="@+id/corner"
        android:layout_width="match_parent"
        android:layout_height="75dp"
        android:gravity="center"
        android:background="@drawable/shape_corners"
        android:textColor="@color/Black"
        android:text="corner" /&gt;
 
 
    &lt;TextView
        android:id="@+id/corner"
        android:layout_width="match_parent"
        android:layout_height="75dp"
        android:gravity="center"
        android:background="@drawable/shape_solid"
        android:textColor="@color/Black"
        android:text="corner" /&gt;
    &lt;TextView
        android:id="@+id/stroke"
        android:layout_width="match_parent"
        android:layout_height="75dp"
        android:gravity="center"
        android:background="@drawable/shape_stroke"
        android:textColor="@color/White"
        android:text="stroke" /&gt;
 
&lt;/LinearLayout&gt;
</code></pre>

<p>```</p>

<p>```</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" &gt;
    &lt;gradient
        android:centerColor="@color/WhiteSmoke"
        android:endColor="@color/Yellow"
        android:startColor="@color/Blue" /&gt;
    &lt;corners android:radius="50dp" /&gt;
    &lt;stroke
        android:dashGap="5dp"
        android:dashWidth="3dp"
        android:width="5dp"
        android:color="@color/DarkSalmon" /&gt;
&lt;/shape&gt;
</code></pre>

<p>```</p>

<h5>漸層</h5>

<p>```</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" &gt;
 
    &lt;gradient
        android:angle="90"
        android:centerColor="@color/WhiteSmoke"
        android:endColor="@color/Yellow"
        android:startColor="@color/Blue" /&gt;
 
&lt;/shape&gt;
</code></pre>

<p>```</p>

<h5>圓角</h5>

<p>```</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" &gt;
    &lt;corners android:radius="50dp"/&gt;
    &lt;solid android:color="@color/White"/&gt;
&lt;/shape&gt;
</code></pre>

<p>```</p>

<h5>背景色</h5>

<p>```</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" &gt;
 
    &lt;solid android:color="@color/Green" /&gt;
 
&lt;/shape&gt;
</code></pre>

<p>```</p>

<h5>外框</h5>

<p>```</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" &gt;
    &lt;stroke android:width="5dp"
        android:color="@color/Red"
        android:dashWidth="3dp"
        android:dashGap="5dp"
        /&gt;
&lt;/shape&gt;
</code></pre>

<p>```</p>

<h3>半透明效果</h3>

<p>像下圖的半透明效果(Smoked
Glass)，可以直接透過設定backgroud的顏色的透明度來達到，</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-17/drawable_101_007.png" alt="drawable_101_007.png" /></p>

<p>上圖的效果，主要就是在下面的這張圖上，放了一個半透明的text
view，要讓view半透明就是設定View的backgroud屬性，<code>android:background=”#77000000”</code>
#77000000是傳統的RGB前面加上一個透明度(alpha)，以傳統的RGB值#000000是全黑，#FFFFFF是全白，而前面的alpha的值也是00\~FF，這邊設成77剛好是一半。</p>

<p>[[android:drawable_101_008.png][]</p>

<p>```</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
 
&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/frameLayout1"
    android:layout_width="match_parent"
    android:layout_height="200dp"
    android:background="@drawable/google_doodle" &gt;
 
    &lt;TextView
        android:id="@android:id/text2"
        android:layout_width="fill_parent"
        android:layout_height="100dp"
        android:background="#77000000"
        android:gravity="center_vertical"
        android:text="smoked glass"
        android:textColor="#ffffffff"
        android:textSize="30dip" /&gt;
 
&lt;/FrameLayout&gt;
</code></pre>

<p>```</p>

<p>透明度的效果好不好，會跟後面的背景有關，有時，同一個透明度的值，在不同的背景下，效果就會差很多</p>

<h1>Resource</h1>

<ul>
<li><a href="http://www.dibbus.com/2011/03/9patch-images-in-android/" title="http://www.dibbus.com/2011/03/9patch-images-in-android/">http://www.dibbus.com/2011/03/9patch-images-in-android/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Unit Test 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/04/13/unit_testing_in_android/"/>
    <updated>2012-04-13T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/04/13/unit_testing_in_android</id>
    <content type="html"><![CDATA[<p>這邊並不算真正的unit
test，因為整個測試還是需要模擬器或實機執行，而且很依賴測試環境的context，如果有需要
也是會去連網路或資料庫。</p>

<h1>準備工作</h1>

<p>要進行Android Testing通常是把test cases建立在另一個Test
Project而不是像一般的java(maven base)目錄結構一樣
在同一個project建立test folder.</p>

<p>Testing project可透過eclipse的android project
wizard建立，建立後記得先把production project裡用到的lib export出來給test
project使用</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_003.png" alt="unit_testing_in_android_003.png" /></p>

<p>而測試專案只需要放只有測試時會用到的lib，因為Tesing
Project有reference到Production Project，所以會一併引用Production Project
export 出來的lib。</p>

<p>一般習慣把被測的程式的專案叫Production
project(或<a href="http://xunitpatterns.com/SUT.html" title="http://xunitpatterns.com/SUT.html">SUT</a>)，
而測試程式專案叫Testing Project</p>

<h1>Android測試架構</h1>

<ul>
<li>測試方式是透過建立測試專案來測試待測專案(<a href="http://xunitpatterns.com/SUT.html" title="http://xunitpatterns.com/SUT.html">SUT</a>)</li>
<li>需啟動Android
OS，所以是屬於整合測試，而不是單元測試(像是eclipse的plugin測試方式)</li>
<li>需繼承特定的TestCase以便可以取得一些測試的基本功能</li>
</ul>


<p><img src="http://developer.android.com/images/testing/android_test_framework.png" alt="" /></p>

<p>Android應用程式跟測試程式透過Instrumentation Test
Runner執行在同一個Process, 所以，在執行測試時，需透過Instrumentation
Test Runner。</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_001.png" alt="unit_testing_in_android_001.png" /></p>

<p>測試分為兩大類</p>

<ol>
<li>Instrumentation Testing</li>
<li>Android Testing</li>
</ol>


<h3>Instrumentation Testing</h3>

<p>這類型的testing會啟動instrumentation Test Runner。
Instrumentation可以使用instrumentation framework，有了Instrumentation
framework，可以透過Android的事件處理系統傳送訊息給Android應用程式，以便於模擬像”收到mail”，”收到簡訊”，”有電話calling進來”等等的動作，或者是對UI進行自動化測試。</p>

<p><code>``
TestCase
 |
</code>- InstrumentationTestCase</p>

<pre><code>|
`- ActivityTestCase
|  |
|  `- ActivityInstrumentationTestCase&lt;T&gt;
|  |
|  `- ActivityInstrumentationTestCase2&lt;T&gt;
|  |
|  `- ActivityUnitTestCase&lt;T&gt;
|
`- ProviderTestCase&lt;T&gt;
|
`- SingleLaunchActivityTestCase&lt;T&gt;
|
`- SyncBaseInstrumentation
</code></pre>

<p>```</p>

<h3>Android Testing</h3>

<p>提供Context給測試程式</p>

<p>以下的TestCase提供跟Android應用程式相關的Context，透過Context，可以取到Android的檔案系統，資料庫，資源檔…。</p>

<p><code>``
TestCase
 |
</code>- AndroidTestCase</p>

<pre><code>|
`- ProviderTestCase2&lt;T&gt;
|
`- ServiceTestCase&lt;T&gt;
|
`- ApplicationTestCase&lt;T&gt;
</code></pre>

<p>```</p>

<p>XxxTestCase2&lt;T>中的<code>tempalte &lt;T&gt;</code>在使用時要宣告成要被測試的class，就像泛型容器的用法一樣
ex: <code>List&lt;MyClass&gt;</code></p>

<h3>AndroidTestCase Or InstrumentationTestCase</h3>

<h5>AndroidTestCase V.S InstrumentationTestCase</h5>

<p>如果測試的對象是ui元件的話，那就必需要用InstrumentationTestCase體系的test
cases，如果要測試non-UI的功能，像permissions之類的功能，那使用AndroidTestCase體系的的test
case即可。
@UiThreadTest(android.test.UiThreadTest)是使用在InstrumentationTestCase的test
method上，用來標明該method會存取UI元件，需要在main thread執行。
或者是，測試時需要使用到test project裡才有的resource(assets, res, …
目錄下的東西)，那就得使用InstrumentationTestCase，因為InstrumentationTestCase才會去處理test
project下的AndroidManifest.xml。</p>

<p>元件測試或應用程式測試，元件測試主要是以下三種</p>

<ol>
<li><a href="http://developer.android.com/guide/topics/testing/activity_testing.html" title="http://developer.android.com/guide/topics/testing/activity_testing.html">Activity
Testing</a></li>
<li><a href="http://developer.android.com/guide/topics/testing/contentprovider_testing.html" title="http://developer.android.com/guide/topics/testing/contentprovider_testing.html">Content Provider
Testing</a></li>
<li><a href="http://developer.android.com/guide/topics/testing/service_testing.html" title="http://developer.android.com/guide/topics/testing/service_testing.html">Service
Testing</a></li>
</ol>


<p>而應該程式測試測是測試<a href="http://developer.android.com/reference/android/app/Application.html" title="http://developer.android.com/reference/android/app/Application.html">Application</a></p>

<ol>
<li><a href="http://developer.android.com/guide/topics/testing/service_testing.html" title="http://developer.android.com/guide/topics/testing/service_testing.html">ApplicationTestCase</a></li>
</ol>


<p><a href="http://developer.android.com/reference/android/test/TouchUtils.html" title="http://developer.android.com/reference/android/test/TouchUtils.html">TouchUtils</a>
(android.test.TouchUtils)可用來產生touch
events，通常在InstrumentationTestCase or
ActivityInstrumentationTestCase2中使用。</p>

<h1>TestCases</h1>

<ul>
<li><p><a href="#androidtestcase" title="android:unit_testing_in_android ↵">AndroidTestCase</a></p>

<ol>
<li><a href="#providertestcase2" title="android:unit_testing_in_android ↵">ProviderTestCase2</a></li>
<li><a href="#servicetestcase" title="android:unit_testing_in_android ↵">ServiceTestCase</a></li>
<li><a href="#applicationtestcase" title="android:unit_testing_in_android ↵">ApplicationTestCase</a></li>
</ol>
</li>
<li><p><a href="#instrumentationtestcase" title="android:unit_testing_in_android ↵">InstrumentationTestCase</a></p>

<ol>
<li><p><a href="#activitytestcase" title="android:unit_testing_in_android ↵">ActivityTestCase</a></p>

<ol>
<li><a href="#activityinstrumentationtestcase" title="android:unit_testing_in_android ↵">ActivityInstrumentationTestCase</a></li>
<li><a href="#activityinstrumentationtestcase2" title="android:unit_testing_in_android ↵">ActivityInstrumentationTestCase2</a></li>
<li><a href="#activityunittestcase" title="android:unit_testing_in_android ↵">ActivityUnitTestCase</a></li>
</ol>
</li>
<li><p><a href="#providertestcase" title="android:unit_testing_in_android ↵">ProviderTestCase</a></p></li>
<li><a href="#singlelaunchactivitytestcase" title="android:unit_testing_in_android ↵">SingleLaunchActivityTestCase</a></li>
<li><a href="#syncbaseinstrumentation" title="android:unit_testing_in_android ↵">SyncBaseInstrumentation</a></li>
</ol>
</li>
</ul>


<h3>AndroidTestCase</h3>

<p>提供context是在Android
Framework中最重要的一個物件，在許多地方都會用到它，<code>這邊的context是test project的context</code>。
AndroidTestCase啟動時，會先做自我檢測，先驗証測試環境是否ready to
use.有提供幾個預先定義好的assert.</p>

<h3>ProviderTestCase2</h3>

<p>測試Provider的test
case,如果要測試資料而非UI的話，那測試的對象應該是<a href="http://developer.android.com/guide/topics/providers/content-providers.html" title="http://developer.android.com/guide/topics/providers/content-providers.html">Content
Provider</a>及Content
Provider用到的相關物件。</p>

<p>Android Test Framework有提供ProviderTestCase2可以Content
Provider進行獨立的測試。使用方式如下：</p>

<p>```
public class MyContentProviderTest extends ProviderTestCase2<MyContentProvider> {
 </p>

<pre><code>public MyContentProviderTest() {
    super(MyContentProvider.class, MyContentProvider.class.getName());
}
</code></pre>

<p> </p>

<pre><code>@Override
protected void setUp() throws Exception {
    super.setUp();
}
</code></pre>

<p> </p>

<pre><code>public void testInsert() throws Exception {
    ContentValues values = new ContentValues();
    values.put("name", "foo");
    getProvider().insert("context://xxx/xx", values);
    // do assert here
}
</code></pre>

<p> </p>

<pre><code>public void testQuery() throws Exception {
    getProvider().query("context://xxx/xx", null, null, null, null);
    // do assert here
}
</code></pre>

<p>}
```</p>

<p>此例中，測是對象為MyContentProvider,使用上要注意的有：</p>

<ol>
<li><p>Testcase要繼承自<a href="http://developer.android.com/reference/android/test/ProviderTestCase2.html" title="http://developer.android.com/reference/android/test/ProviderTestCase2.html">ProviderTestCase2</a></p>

<ul>
<li>可以將<code>ProviderTestCase2&lt;T&gt;</code>的template
&lt;T>指定成對象為MyContentProvider，這樣可以testcase內就會引用MyContentProvider而非ContentProvider</li>
</ul>
</li>
<li><p>必須要建立一個無參數的建構子(Constructor)</p></li>
<li><p>Constructor裡必須呼叫<code>super(MyContentProvider.class, MyContentProvider.class.getName());</code></p>

<ul>
<li>因為MyContentProvider的Authority為<code>MyContentProvider.class.getName()</code></li>
</ul>
</li>
<li><p>Testcase中透過getProvider()來取得MyContentProvider的instance，而不是自已創建MyContentProvider的instance</p></li>
</ol>


<h3>ServiceTestCase</h3>

<p>ServiceTestCase可以用來測試Android Service,ServiceTestCase</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_002.png" alt="unit_testing_in_android_002.png" /></p>

<p>基本的使用方式如下：</p>

<ol>
<li>宣告class時，把<code>template &lt;T&gt;</code>換成要被測試的Service(Service Under
Test)</li>
<li>建立default的constructor，並呼叫parent的constructor，代入class name</li>
<li>setUp()時，ServiceTestCase會將real context儲存到systemContext</li>
<li>透過startService()或bindService()啟動service
(呼叫service.onCreate())</li>
<li>test case的tearDown()會stop 跟 destroy service</li>
<li>如果有需要的話，可以透過setCotext()或setApplication()換掉test
case裡的context跟application.</li>
</ol>


<p>ServiceTestCase預設是使用MockApplication + Test Proejct的Context</p>

<p>```</p>

<pre><code>public abstract class ServiceTestCase&lt;T extends Service&gt; extends AndroidTestCase {
    protected void setupService() {
        mService = null;
        try {
            mService = mServiceClass.newInstance();
        } catch (Exception e) {
            assertNotNull(mService);
        }
        if (getApplication() == null) {
            setApplication(new MockApplication());  // 使用mock版的Application()，而不是真正的
        }
        mService.attach(getContext(), null,  mServiceClass.getName(), null, getApplication(), null);
        assertNotNull(mService);
        mServiceId = new Random().nextInt();
        mServiceAttached = true;
    }
} 
</code></pre>

<p>```</p>

<p>Android有提供<a href="#renamingdelegatingcontext" title="android:unit_testing_in_android ↵">RenamingDelegatingContext</a>,
<a href="#contextwrapper" title="android:unit_testing_in_android ↵">ContextWrapper</a>,
<a href="#isolatedcontext" title="android:unit_testing_in_android ↵">IsolatedContext</a>跟<a href="#mockcontext" title="android:unit_testing_in_android ↵">MockContext</a>來換原MockContext，也可以自已Mock一個</p>

<p>```
public class MyServiceTest extends ServiceTestCase<MyService> {</p>

<pre><code>public MyServiceTest() {
    super(MyService.class);
}
</code></pre>

<p>}
```</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_002.png" alt="unit_testing_in_android_002.png" /></p>

<p>ServiceTestCase提供<code>getService()</code>可以取得要被測試的service，<code>getSystemContext()</code>可以取得test
project context</p>

<h5>getContext() vs getSystemContext()</h5>

<p>在預設的情況下，如果沒有特別去設定context，getContext(),getSystemContext()是同一個instance，但是
如果有設定mock版的context，ex:
<code>setConext(new MockContext());</code>，那麼getContext()會取到mock版的，
而getSystemContext()會取到原來的(測試專案的)。</p>

<h3>ApplicationTestCase</h3>

<p>測試Application的test case</p>

<h3>InstrumentationTestCase</h3>

<h3>ActivityTestCase</h3>

<h3>ActivityInstrumentationTestCase</h3>

<h3>ActivityInstrumentationTestCase2</h3>

<h3>ActivityUnitTestCase</h3>

<h3>ProviderTestCase</h3>

<h3>SingleLaunchActivityTestCase</h3>

<h3>SyncBaseInstrumentation</h3>

<h1>要測那些東西</h1>

<h5>Activity lifecycle events</h5>

<p>如果有在Activity lifecycle events像是onCreate(), onResume(), onPause(),
…中保存activity的狀態，那麼應該要對這些methods進行測式，而當
Configuration-changed事件發生時，也需要確定這些event的動作都正確。</p>

<p><img src="http://developer.android.com/images/activity_lifecycle.png" alt="" /></p>

<p>TestCase :
<a href="#activityinstrumentationtestcase2" title="android:unit_testing_in_android ↵">ActivityInstrumentationTestCase2</a>
(大多數情況用這個),
<a href="#activitytestcase" title="android:unit_testing_in_android ↵">ActivityTestCase</a>,
<a href="#singlelaunchactivitytestcase" title="android:unit_testing_in_android ↵">SingleLaunchActivityTestCase</a></p>

<h5>Content Provder</h5>

<p>Content
Provder在大部份的情況下，不需要自行建立，也不建議直接建立，所以，Content
Provder在測試時， Insert, Update, Query,
Delete等method，還有getType()這些基本的methods都要被測到，如果沒有必要的話，
儘量不要自已publish額外的method，因為在程式裡，只能取到ContentProvder型別，無法直接取得子型別(除非透過型別轉換，但不建議)，
所以，ContentProvider的子類別，應儘量避免publish額外的API.</p>

<p>TestCase :
<a href="#providertestcase2" title="android:unit_testing_in_android ↵">ProviderTestCase2</a></p>

<h5>ListView Adapter</h5>

<p>ListView用的Adapter，ListView是UI裡很重要的一個元件，幾乎每個應該程式都會用到，而ListView
Adapter又是ListView中 主要的元件，對Adapter測試的重要性，不言可喻。</p>

<p>```
public class ScriptListAdapterTest extends AndroidTestCase {
 </p>

<pre><code>public void testExtractWords_none_words() throws Exception {
    ScriptListAdapter adapter = new ScriptListAdapter(getContext(), R.layout.script_list_item, R.id.scriptLine, ImmutableList.&lt;String&gt; of());
    adapter.setRichScript("foo bar");
    assertThat(adapter.extractWord(), Matchers.&lt;String&gt; emptyIterable());
}
</code></pre>

<p> </p>

<pre><code>public void testExtractWords_one_word() throws Exception {
    ScriptListAdapter adapter = new ScriptListAdapter(getContext(), R.layout.script_list_item, R.id.scriptLine, ImmutableList.&lt;String&gt; of());
    adapter.setRichScript("foo &lt;b&gt;bar&lt;/b&gt; baz");
    Iterable&lt;String&gt; words = adapter.extractWord();
    assertThat(words, hasItem("bar"));
}
</code></pre>

<p> </p>

<pre><code>public void testExtractWords_two_words() throws Exception {
    ScriptListAdapter adapter = new ScriptListAdapter(getContext(), R.layout.script_list_item, R.id.scriptLine, ImmutableList.&lt;String&gt; of());
    adapter.setRichScript("&lt;b&gt;foo&lt;/b&gt; bar &lt;b&gt;baz&lt;/b&gt;");
    Iterable&lt;String&gt; words = adapter.extractWord();
    assertThat(words, hasItems("foo", "baz"));
    assertThat(words, not(hasItem("bar")));
}
</code></pre>

<p> </p>

<pre><code>public void testRichText() throws Exception {
    ScriptListAdapter adapter = new ScriptListAdapter(getContext(), R.layout.script_list_item, R.id.scriptLine, ImmutableList.&lt;String&gt; of());
    CharSequence text = adapter.richText("this is a foo bar string", ImmutableList.of("foo", "string"));
    System.out.println(text);
</code></pre>

<p> </p>

<pre><code>}
</code></pre>

<p>}
```</p>

<p>TestCase :
<a href="#androidtestcase" title="android:unit_testing_in_android ↵">AndroidTestCase</a></p>

<h5>Database &amp; File</h5>

<p>我通常會對DatabaseHelper進行測試，以確定table可以正確的被建立或版更</p>

<p>```
public class DatabaseHelperTest extends TestCase {</p>

<pre><code>private DatabaseHelper    helper;
private SQLiteDatabase    db;
</code></pre>

<p> </p>

<pre><code>@Override
public void tearDown() {
    helper.close();
}
</code></pre>

<p> </p>

<pre><code>public void testDictionaryBankTable() throws Exception {
    Cursor c = db.query(DatabaseHelper.DICTIONARY_TABLE_NAME, null, null, null, null, null, null);
    assertEquals(4, c.getColumnCount());
}
</code></pre>

<p> </p>

<pre><code>public void testPodcastTable() throws Exception {
    Cursor c = db.query(DatabaseHelper.PODCAST_TABLE_NAME, null, null, null, null, null, null);
    assertEquals(13, c.getColumnCount());
}
</code></pre>

<p> </p>

<pre><code>public void testWordBankTable() throws Exception {
    Cursor c = db.query(DatabaseHelper.WORD_BANK_TABLE_NAME, null, null, null, null, null, null);
    assertEquals(2, c.getColumnCount());
}
</code></pre>

<p> </p>

<pre><code>@Override
protected void setUp() throws Exception {
    super.setUp();
    db = SQLiteDatabase.create(null);
    helper = new DatabaseHelper(null, "podcast.db", null);
    helper.onOpen(db);
    helper.onCreate(db);
}
</code></pre>

<p>}
```</p>

<p>TestCase: 沒有用到android 的context，只需用Junit內建的TestCase即可</p>

<h5>Helper &amp; Utils</h5>

<p>Helper跟Utils指的是跟Android比較無關類別，有可能用到網路或檔案系統等的class，可視情況選擇用TestCase,
AndroidTestCase, InstrumentationTestCase
通常我都是先用最簡單的，如果不適合，再找次簡單的。</p>

<h1>Test Helper</h1>

<h3>Mock Objects</h3>

<p>Android Test Framework也有提供一列系的mock
objects，如果在測試時採用Depedency Injection的方式把這些mock
object注入，會讓測試更簡單，更獨立。 這些mock
oject被放在<a href="http://developer.android.com/reference/android/test/mock/package-summary.html" title="http://developer.android.com/reference/android/test/mock/package-summary.html">android.test.mock
package</a>內，主要有下列這些mock
objects</p>

<ol>
<li>MockApplication A mock Application class.</li>
<li>MockContentProvider Mock implementation of ContentProvider.</li>
<li>MockContentResolver An extension of ContentResolver that is designed
for testing.</li>
<li>MockContext A mock Context class.</li>
<li>MockCursor A mock Cursor class that isolates the test code from real
Cursor implementation.</li>
<li>MockDialogInterface A mock DialogInterface class.</li>
<li>MockPackageManager A mock PackageManager class.</li>
<li>MockResources A mock Resources class.</li>
</ol>


<p>這些class採的mock
strategy是stubbing而不是mocking，也就是說，使用時必須overwrite掉要提供資訊的methods</p>

<p>曾經試著將在Android test framework上使用幾個mock
framework，都失敗了，目前都是直接使用Android test
framework內建的mocks，雖不好用但可以接受。</p>

<ol>
<li>mockito 1.8.5 - 無法通過編譯，殘念</li>
<li>easymock 3 - extension的部份無法通過編譯，也就是只能mock
interface，殘念</li>
<li>powermock - 還是需要mocktio或easymock的jar，殘念</li>
<li>jmock - 沒試</li>
</ol>


<p><a href="https://sites.google.com/site/androiddevtesting/" title="https://sites.google.com/site/androiddevtesting/">這裡</a>有篇文章說明為何大多數的Mock
framework在Android上的無法正常動作， 只要是Mock
Framework有用到CGLib就無法在Dalvik
VM上執行，ex:EasyMock,Mockito都有用到這個lib</p>

<p>2012/3/16 己經有android team的member在將mockito
porting到android上了，或許不久的將來就有android
compatible的mockito可以用了 :) ，詳情 :
<a href="http://code.google.com/p/mockito/issues/detail?id=308" title="http://code.google.com/p/mockito/issues/detail?id=308">http://code.google.com/p/mockito/issues/detail?id=308</a></p>

<h3>Context For Testing</h3>

<p>Context的type hierarchy</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_002.png" alt="unit_testing_in_android_002.png" /></p>

<p>跟測試比較相關的有</p>

<ol>
<li><a href="#contextwrapper" title="android:unit_testing_in_android ↵">ContextWrapper</a></li>
<li><a href="#isolatedcontext" title="android:unit_testing_in_android ↵">IsolatedContext</a></li>
<li><a href="#renamingdelegatingcontext" title="android:unit_testing_in_android ↵">RenamingDelegatingContext</a></li>
<li><a href="#mockcontext" title="android:unit_testing_in_android ↵">MockContext</a></li>
</ol>


<h5>ContextWrapper</h5>

<p>嚴格來說，這個並不算是testing專用的，其他不少context也是從這個開始繼承的，他的實作很簡單
，就是把被wrapped的context的delegate給ContextWrapper，所以，每個method大多長這樣</p>

<p>```
/<em>*
 * Proxying implementation of Context that simply delegates all of its calls to
 * another Context.  Can be subclassed to modify behavior without changing
 * the original Context.
 </em>/
public class ContextWrapper extends Context {</p>

<pre><code>Context mBase;

@Override
public AssetManager getAssets() {
    return mBase.getAssets();
}

@Override
public Resources getResources()
{
    return mBase.getResources();
}

@Override
public PackageManager getPackageManager() {
    return mBase.getPackageManager();
}
...
</code></pre>

<p>}
```</p>

<h5>IsolatedContext</h5>

<p>這個Context把跟設備相關的method改掉掉，讓context不與設備直接溝通，但又提供足夠的功能以測試可以進行。
被IsolatedContext改寫掉的methods如下</p>

<p>(圖丟了 XD)</p>

<h5>RenamingDelegatingContext</h5>

<p>正常來說，如果production code裡用到的db 叫
foo.db跟一個檔案叫bar.txt，但測試時，希望不要去動到原來的foo.db,bar.txt
，而是提供一組測試用的foo.db跟bar.txt那就可以用RenamingDelegatingContext處理，可以把測試的命名成
test_foo.db跟test_bar.txt，然後跟RenamingDelegatingContext測試用的contxt是以”test_”當prefix即可，這樣所有測試用的
的檔案名稱跟DB名稱就是原來的名稱加上”test_”，用以避免prodcution
code跟testing code互相感染。</p>

<p>RenamingDelegatingContext是用來處理檔案都是放在application
project中的情況，但實際使用上，在測試專案上的相同的位置放上一個同檔名的檔案，會比用RenamingDelegatingContext適合，
不過，如果取得測試案專案的resource，就得繼承自InstrumentationTestCase而非AndroidTestCase體系</p>

<h5>MockContext</h5>

<p>Mock版的Context，裡面的implement就是丟出UnsupportedOperationException，所以如果要用這個context，那
測試中有用到的method，就要自行改寫，不然就等著接UnsupportedOperationException。</p>

<p>```
/<em>*
 * A mock {@link android.content.Context} class.  All methods are non-functional and throw
 * {@link java.lang.UnsupportedOperationException}.  You can use this to inject other dependencies,
 * mocks, or monitors into the classes you are testing.
 </em>/
public class MockContext extends Context {
 </p>

<pre><code>@Override
public AssetManager getAssets() {
    throw new UnsupportedOperationException();
}
</code></pre>

<p> </p>

<pre><code>@Override
public Resources getResources() {
    throw new UnsupportedOperationException();
}
</code></pre>

<p> </p>

<pre><code>@Override
public PackageManager getPackageManager() {
    throw new UnsupportedOperationException();
}
...
</code></pre>

<p>}
```</p>

<h3>Assertion classes</h3>

<p>除了基本的Junit Assertions外，Android Test Framework還提供了</p>

<ol>
<li><a href="http://developer.android.com/reference/android/test/MoreAsserts.html" title="http://developer.android.com/reference/android/test/MoreAsserts.html">More
Asserts</a>

<ul>
<li>一些android testing
assertions的延伸，不過我覺得<a href="http://wiki.kent-chiu.com/doku.php?id=java:hamcrest_101" title="java:hamcrest_101">hamcrest</a>更好用</li>
</ul>
</li>
<li><a href="http://developer.android.com/reference/android/test/ViewAsserts.html" title="http://developer.android.com/reference/android/test/ViewAsserts.html">View
Asserts</a>

<ul>
<li>一些跟view有關的assertions，像是view跟view之間的關係、對齊方式、…</li>
</ul>
</li>
</ol>


<p>目前Android Test Framework(Android
2.3)還都是基於Junit3,Junit3的assertions在使用上沒有Junit4的來方便(powered
by Hamcrest)，Junit3沒有內建<code>assertThat()</code>，
Hamcrest的assertions是一個獨立的lib，所以，還是可以拿來跟Junit3搭著用，但是，Hamrcest的jar檔(1.3-R.C2)丟到Eclipse
ADT時，無法順利通過編譯，<a href="http://wiki.kent-chiu.com/doku.php?id=java:hamcrest_101#hamcrest_android" title="java:hamcrest_101">這裡有提供解決的方式</a>
，至於Hamcrest的assertion，可以參閱<a href="http://code.google.com/p/hamcrest/wiki/Tutorial" title="http://code.google.com/p/hamcrest/wiki/Tutorial">Hamcrest網站的教學</a>或<a href="http://wiki.kent-chiu.com/doku.php?id=java:hamcrest_101" title="java:hamcrest_101">這裡</a>也有一個簡單的說明。</p>

<h4>MISC</h4>

<ol>
<li>RenamingDelegating - Product
code用的是一個名字，測試時用的是另一個名字(檔案或資料庫)，用來避開testing
code改到product code的內容</li>
<li>ActivityMonitor -
android.app.Instrumentation.ActivityMonitor是Instrumentation的內部類別，可以用來monitor系統的行為。</li>
</ol>


<p>如果test proejct跟production project有用到相同的jars，只需由production
project export出jars讓testing project使用即可，如果testing
project有跟production project相同的lib，可能compile time會出錯</p>

<h1>Resources</h1>

<ul>
<li><a href="http://developer.android.com/resources/tutorials/testing/helloandroid_test.html" title="http://developer.android.com/resources/tutorials/testing/helloandroid_test.html">Hello World
Test</a></li>
<li><a href="http://developer.android.com/guide/topics/testing/testing_android.html" title="http://developer.android.com/guide/topics/testing/testing_android.html">Testing and
Instrumentation</a></li>
<li><a href="http://developer.android.com/guide/developing/testing/testing_eclipse.html" title="http://developer.android.com/guide/developing/testing/testing_eclipse.html">Testing In Eclipse, with
ADT</a></li>
<li><a href="http://codinghard.wordpress.com/2009/06/04/a-first-look-at-the-android-testing-framework/" title="http://codinghard.wordpress.com/2009/06/04/a-first-look-at-the-android-testing-framework/">http://codinghard.wordpress.com/2009/06/04/a-first-look-at-the-android-testing-framework/</a></li>
<li><a href="http://code.google.com/p/nativedriver/" title="http://code.google.com/p/nativedriver/">Native
Driver</a>

<ul>
<li>google官方的ui test
api，webdriver(<a href="http://code.google.com/p/selenium/" title="http://code.google.com/p/selenium/">selenium</a>)
like的測試工具</li>
</ul>
</li>
<li><p>RenamingDelegatingContext的使用方式可以參考下面的資料</p>

<ol>
<li><a href="http://blog.jayway.com/2011/10/10/using-renamingdelegatingcontext-to-mock-contentresolver-in-android/" title="http://blog.jayway.com/2011/10/10/using-renamingdelegatingcontext-to-mock-contentresolver-in-android/">http://blog.jayway.com/2011/10/10/using-renamingdelegatingcontext-to-mock-contentresolver-in-android/</a></li>
<li><a href="https://docs.google.com/View?id=ddwc44gs_21737cgtvfj" title="https://docs.google.com/View?id=ddwc44gs_21737cgtvfj">https://docs.google.com/View?id=ddwc44gs_21737cgtvfj</a></li>
</ol>
</li>
<li><p><a href="http://www.slideshare.net/dtmilano/introduction-to-android-testing" title="http://www.slideshare.net/dtmilano/introduction-to-android-testing">http://www.slideshare.net/dtmilano/introduction-to-android-testing</a></p>

<ul>
<li>android testing的簡介投影片，有每個test case使用上的差異</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
