<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: shiro | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/shiro/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2013-07-11T21:59:18+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apache Shiro 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/20/shiro_101/"/>
    <updated>2012-03-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/20/shiro_101</id>
    <content type="html"><![CDATA[<p>Apache <a href="http://shiro.apache.org/" title="http://shiro.apache.org/">Shiro</a>
(之前叫JSecurity)是<a href="http://en.wikipedia.org/wiki/Role-based_access_control" title="http://en.wikipedia.org/wiki/Role-based_access_control">RBAC</a>權限系統，也就是以角色為主的權限。
目前survey過的幾套java base的權限系統有</p>

<ol>
<li><a href="http://static.springsource.org/spring-security/site/index.html" title="http://static.springsource.org/spring-security/site/index.html">Spring
Security</a>(之前叫Acige
Security)</li>
<li><a href="http://jpasecurity.sourceforge.net/" title="http://jpasecurity.sourceforge.net/">JPA
Security</a></li>
<li><a href="http://incubator.apache.org/shiro/index.html" title="http://incubator.apache.org/shiro/index.html">Apache
Shiro</a>(之前叫JSecurity或ki)</li>
</ol>


<h5>Spring Security</h5>

<p>之前做文件管理系統時有採用過，很強大，但使用上也很複雜，特點是透過AOP來管控access，
而且可以依權限產生相對的Query (sql query or JPA query).
但目前一定要搭著Spring使用<img src="http://wiki.kent-chiu.com/lib/images/smileys/icon_sad.gif" alt=":-(" /></p>

<h5>JPA Security</h5>

<p>透過Annotation控管權限，特點是owner-ship(擁有權)的處理，而且會依不同的權限，產生不同的query條件(where
conditions)</p>

<h5>Apache Shiro</h5>

<p>Apache
Shiro的特色在permission的管控，所有的permission是透過特定格式的文字來記錄，語法大概像這樣
<code>domain:operations:instance</code>，並搭配wildcard(通配字元)進行較大範圍的控制。</p>

<h1>WildcardPermission</h1>

<p>Format:</p>

<p><code>
domain:action:instances
</code></p>

<h4>Simple Usage</h4>

<p><code>
editNewsletter 新聞編輯的權限
*              所有的權限(root)
</code></p>

<h4>Multiple Levels</h4>

<p><code>
newsletter:edit             新聞編輯的權限
newsletter:edit,remove,add  新聞編輯、移除、加入的權限
newsletter:*                新聞所有的權限
*:view                      所有VIEW的權限
</code></p>

<h4>Instance-level Access Control</h4>

<p><code>
newsletter:edit:12,13,18   對12,13,18這三則新聞編輯的權限
newsletter:*:12,13,18      對12,13,18這三則新聞所有的權限
newsletter:*:*             對所有新聞的所有權限
</code></p>

<h1>Modeling</h1>

<p>以下是Shiro的創建者Les Hazlewood建議的modeling方式</p>

<p>Les general rule of thumb:</p>

<ol>
<li>a Role is a named Set of permissions</li>
<li>a User 'has' a Set of one or more Roles</li>
<li>a User 'has' a Set of permissions for <strong>that-user-only</strong> permissions
(not shared with anyone else - otherwise they'd go in a Role)</li>
<li>a Group is a named Set of 'Party' objects (a User is a Party and a
Group is a Party - allowing for instances of both to exist in
hierarchical Party trees)</li>
</ol>


<p>Les並建議不要採用deney的方式modeling權限，而且採用Aggregated Roles的方式
(<a href="http://shiro-user.582556.n2.nabble.com/Permission-Implementation-td3554707.html#a3554707" title="http://shiro-user.582556.n2.nabble.com/Permission-Implementation-td3554707.html#a3554707">原文參考</a>)</p>

<p>針對第三點，Kent還是偏好用<strong>that-user-only</strong>
role，而不是直接把permission指派給user</p>

<h3>Instance Level範例</h3>

<p>權限系統中，Kent個人認為，最關鍵也是最麻煩的地方在對Instance Level
resource的管控。
也就怎如何控制，具有相同角色(也就是擁有相同的權限)的人對相同類型的資源，有不同的控制能力。
舉例來說： IT Manager跟ServiceDesk
Manager都具有部門主管的角色，所以都擁有業務審核(auditing)的權限，
但因為IT Manager是IT部門主管，Service Desk
Manager是ServiceDesk主管，所以</p>

<ul>
<li>IT Manager只能審核IT部門的業務</li>
<li>Service Desk Manager只能審核ServiceDesk部門的業務</li>
</ul>


<p>正常來說設計成</p>

<ul>
<li>部門主管擁有審核的權限</li>
</ul>


<p>會比</p>

<ul>
<li>IT Manager只能審核IT部門的業務</li>
<li>Service Desk Manager只能審核Service Desk部門的業務</li>
</ul>


<p>來的直覺，而且比較符合Business
Rules，而且不會造成角色爆炸問題(如果有100個部門，就要需100個角色^<a href="#fn__1">1)</a>^)</p>

<p>要達到第一種的設計方式，就是要從Instance Level的權限來做管控。 像這樣:</p>

<p>```</p>

<h1>IT Manager</h1>

<p>performance:auditing:it_department_id</p>

<h1>Service Desk Manager</h1>

<p>performance:auditing:it_servicedesk_id
```</p>

<p><code>performance:auditing:it_department_id</code>或<code>performance:auditing:it_servicedesk_id</code>指派給Manager
Role時 Manager Role會同時具有IT, ServiceDesk
Manager的權限，可是，我們要的是讓每個部門的Manager有專屬的權限，此時就需要把權限指派給
User，更好的方式是讓每個User擁有自已專屬的Role，然後指<code>performance:auditing:it_department_id</code>或<code>performance:auditing:it_servicedesk_id</code>指派給User的role，並讓user具有manager的role
。這樣，不但可以保持只有一個叫<code>Manager</code>的Role，而且IT manager跟Service
Desk的權限是不同的。 ^<a href="#fn__2">2)</a>^</p>

<h1>Things that need to know</h1>

<ol>
<li>Shiro的實際運用上，permission會比role更實用，實作時，
應該是針對permission。</li>
<li>Shiro會cache住AuthorizationInfo，你可以透過<code>clearCachedAuthorizationInfo</code>來refresh
caching</li>
<li>Shiro並未提供直接的API去異動role, permission…，必須自行extend
Realm以達到這個功能</li>
<li>Shiro並未提供直接Group，Role Hierarchal, Role(Group)
Inheritance等data model，但有需要的話，可以自行實作
(<a href="http://shiro-user.582556.n2.nabble.com/Privilages-inheritance-in-groups-td3253048.html#a3253048" title="http://shiro-user.582556.n2.nabble.com/Privilages-inheritance-in-groups-td3253048.html#a3253048">範例</a>)</li>
</ol>


<h1>Resources</h1>

<ul>
<li><a href="http://incubator.apache.org/shiro/permissions.html" title="http://incubator.apache.org/shiro/permissions.html">Shiro
permissions</a></li>
</ul>


<p>^<a href="#fnt__1">1)</a>^
也有人主張可以把權限直接直派給<strong>人</strong>而不是角色，來解決這樣的問題,詳見note說明</p>

<p>^<a href="#fnt__2">2)</a>^ 或許有更好的解法</p>
]]></content>
  </entry>
  
</feed>
