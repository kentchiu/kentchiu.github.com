<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: concurrency | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/concurrency/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2014-08-30T16:30:59+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Concurrency 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/20/concurrency_101/"/>
    <updated>2012-03-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/20/concurrency_101</id>
    <content type="html"><![CDATA[<p>本文是關於併行處理，多工處理(Multi Threads)的相關議題。</p>

<h5>Process v.s Thread</h5>

<p>Process(行程)擁有各自獨立的記憶體空間，不能與其他process共享，而Thread間可以共享記憶體。Process所使用的資源(memory,
CPU time)由作業系統直接分配。</p>

<h4>Java對Concurrency語法上的支援</h4>

<h5>synchronized</h5>

<p>宣告在synchronized block的程式，保證同時只有一個threaad會存取</p>

<h5>volatile</h5>

<p>宣告 volatile (揮發性) 的變數，java保證會讀到最新狀態的變數</p>

<p>善用Immutable的物件來確保程式是ThreadSafe的</p>

<h3>任務管理</h3>

<p>毫無限制的使用thread，通常會帶來更大的效能問題，如果需要用到較多的threads時，就必須對thread進行管理，決定
那些threads執行順序、同時執行的數量、thread的重用等，也就是進行任務管理。</p>

<h5>Thread注意事項</h5>

<ul>
<li>採用多個thread不建得會帶來更高的效益</li>
<li>建立thread的動作很耗資源，反而可能成為效能上的瓶頸</li>
<li>建立過多thread，CPU需花更多的時間做thread的切換跟管理，甚至可能使用超過預期的記憶體數量</li>
</ul>


<h4>Executor</h4>

<p>要進行任務管理，我們的thread就不能像這樣簡單的直接執行了
<code>new Thread(runnable).start();</code> 而是要透過
<a href="http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html" title="http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html">Executor</a></p>

<p>```</p>

<pre><code>public interface Executor { 
  void execute(Runnable command);
}
</code></pre>

<p>```</p>

<p>Executor只有定義出實作的類別要可以執行Runnable的method，如果需要知道Executor的生命周期資訊，可以用java.util.concurrent.ExecutorService</p>

<p><img src="http://blog.kent-chiu.com/images/2012-03-20/concurrency_101_001.png" alt="concurrency_101_001.png" /></p>

<p>Executor的會依execution
policy(執行政策)的不同會許多的實作，java.util.concurrent內建的execution
policy可參閱上圖。 java.util.concurrent
package裡有一個java.util.concurrent.Executors提供許多factory
methods來建立executor.</p>

<p><img src="http://blog.kent-chiu.com/images/2012-03-20/concurrency_101_002.png" alt="concurrency_101_002.png" /></p>

<p>```</p>

<pre><code>Executor executionPolicy = Executors.newFixedThreadPool(5);
executionPolicy.execute(runnable)
</code></pre>

<p>```</p>

<p>如果需要更多的彈性，可以直接使用ThreadPoolExecutor，而不是透過Executor</p>

<p>```</p>

<pre><code>    /**
     * Creates a new {@code ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param maximumPoolSize the maximum number of threads to allow in the
     *        pool
     * @param keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     * @param unit the time unit for the {@code keepAliveTime} argument
     * @param workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {@code Runnable}
     *        tasks submitted by the {@code execute} method.
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;
     *         {@code corePoolSize &lt; 0}&lt;br&gt;
     *         {@code keepAliveTime &lt; 0}&lt;br&gt;
     *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;
     *         {@code maximumPoolSize &lt; corePoolSize}
     * @throws NullPointerException if {@code workQueue}
     *         or {@code threadFactory} or {@code handler} is null
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
</code></pre>

<p>```</p>

<h1>Resource</h1>

<ul>
<li><a href="http://www.vogella.de/articles/JavaConcurrency/article.html" title="http://www.vogella.de/articles/JavaConcurrency/article.html">Java Concurrency /
Multithreading</a>

<ul>
<li>簡單的介紹，不錯的入門材料</li>
</ul>
</li>
<li><a href="http://www.ibm.com/developerworks/java/tutorials/j-concur/index.html" title="http://www.ibm.com/developerworks/java/tutorials/j-concur/index.html">Concurrency in JDK
5.0</a>

<ul>
<li>IBM developerworks上的文章，滿完整的</li>
</ul>
</li>
<li><a href="http://tutorials.jenkov.com/java-util-concurrent/executorservice.html" title="http://tutorials.jenkov.com/java-util-concurrent/executorservice.html">http://tutorials.jenkov.com/java-util-concurrent/executorservice.html</a>

<ul>
<li>ExecutorService的使用說明</li>
</ul>
</li>
<li><a href="http://tutorials.jenkov.com/java-util-concurrent/index.html" title="http://tutorials.jenkov.com/java-util-concurrent/index.html">http://tutorials.jenkov.com/java-util-concurrent/index.html</a>

<ul>
<li>一系列的Concurrency教學，很完整</li>
</ul>
</li>
<li><a href="http://www.blogjava.net/xylz/archive/2010/07/08/325587.html" title="http://www.blogjava.net/xylz/archive/2010/07/08/325587.html">《深入浅出 Java
Concurrency》</a>

<ul>
<li>簡體中文的Concurrency教學，很完整</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
