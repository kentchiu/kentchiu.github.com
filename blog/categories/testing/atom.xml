<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2013-07-16T15:15:50+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Unit Test 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/04/13/unit_testing_in_android/"/>
    <updated>2012-04-13T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/04/13/unit_testing_in_android</id>
    <content type="html"><![CDATA[<p>這邊並不算真正的unit
test，因為整個測試還是需要模擬器或實機執行，而且很依賴測試環境的context，如果有需要
也是會去連網路或資料庫。</p>

<h1>準備工作</h1>

<p>要進行Android Testing通常是把test cases建立在另一個Test
Project而不是像一般的java(maven base)目錄結構一樣
在同一個project建立test folder.</p>

<p>Testing project可透過eclipse的android project
wizard建立，建立後記得先把production project裡用到的lib export出來給test
project使用</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_003.png" alt="unit_testing_in_android_003.png" /></p>

<p>而測試專案只需要放只有測試時會用到的lib，因為Tesing
Project有reference到Production Project，所以會一併引用Production Project
export 出來的lib。</p>

<p>一般習慣把被測的程式的專案叫Production
project(或<a href="http://xunitpatterns.com/SUT.html" title="http://xunitpatterns.com/SUT.html">SUT</a>)，
而測試程式專案叫Testing Project</p>

<h1>Android測試架構</h1>

<ul>
<li>測試方式是透過建立測試專案來測試待測專案(<a href="http://xunitpatterns.com/SUT.html" title="http://xunitpatterns.com/SUT.html">SUT</a>)</li>
<li>需啟動Android
OS，所以是屬於整合測試，而不是單元測試(像是eclipse的plugin測試方式)</li>
<li>需繼承特定的TestCase以便可以取得一些測試的基本功能</li>
</ul>


<p><img src="http://developer.android.com/images/testing/android_test_framework.png" alt="" /></p>

<p>Android應用程式跟測試程式透過Instrumentation Test
Runner執行在同一個Process, 所以，在執行測試時，需透過Instrumentation
Test Runner。</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_001.png" alt="unit_testing_in_android_001.png" /></p>

<p>測試分為兩大類</p>

<ol>
<li>Instrumentation Testing</li>
<li>Android Testing</li>
</ol>


<h3>Instrumentation Testing</h3>

<p>這類型的testing會啟動instrumentation Test Runner。
Instrumentation可以使用instrumentation framework，有了Instrumentation
framework，可以透過Android的事件處理系統傳送訊息給Android應用程式，以便於模擬像”收到mail”，”收到簡訊”，”有電話calling進來”等等的動作，或者是對UI進行自動化測試。</p>

<p><code>``
TestCase
 |
</code>- InstrumentationTestCase</p>

<pre><code>|
`- ActivityTestCase
|  |
|  `- ActivityInstrumentationTestCase&lt;T&gt;
|  |
|  `- ActivityInstrumentationTestCase2&lt;T&gt;
|  |
|  `- ActivityUnitTestCase&lt;T&gt;
|
`- ProviderTestCase&lt;T&gt;
|
`- SingleLaunchActivityTestCase&lt;T&gt;
|
`- SyncBaseInstrumentation
</code></pre>

<p>```</p>

<h3>Android Testing</h3>

<p>提供Context給測試程式</p>

<p>以下的TestCase提供跟Android應用程式相關的Context，透過Context，可以取到Android的檔案系統，資料庫，資源檔…。</p>

<p><code>``
TestCase
 |
</code>- AndroidTestCase</p>

<pre><code>|
`- ProviderTestCase2&lt;T&gt;
|
`- ServiceTestCase&lt;T&gt;
|
`- ApplicationTestCase&lt;T&gt;
</code></pre>

<p>```</p>

<p>XxxTestCase2&lt;T>中的<code>tempalte &lt;T&gt;</code>在使用時要宣告成要被測試的class，就像泛型容器的用法一樣
ex: <code>List&lt;MyClass&gt;</code></p>

<h3>AndroidTestCase Or InstrumentationTestCase</h3>

<h5>AndroidTestCase V.S InstrumentationTestCase</h5>

<p>如果測試的對象是ui元件的話，那就必需要用InstrumentationTestCase體系的test
cases，如果要測試non-UI的功能，像permissions之類的功能，那使用AndroidTestCase體系的的test
case即可。
@UiThreadTest(android.test.UiThreadTest)是使用在InstrumentationTestCase的test
method上，用來標明該method會存取UI元件，需要在main thread執行。
或者是，測試時需要使用到test project裡才有的resource(assets, res, …
目錄下的東西)，那就得使用InstrumentationTestCase，因為InstrumentationTestCase才會去處理test
project下的AndroidManifest.xml。</p>

<p>元件測試或應用程式測試，元件測試主要是以下三種</p>

<ol>
<li><a href="http://developer.android.com/guide/topics/testing/activity_testing.html" title="http://developer.android.com/guide/topics/testing/activity_testing.html">Activity
Testing</a></li>
<li><a href="http://developer.android.com/guide/topics/testing/contentprovider_testing.html" title="http://developer.android.com/guide/topics/testing/contentprovider_testing.html">Content Provider
Testing</a></li>
<li><a href="http://developer.android.com/guide/topics/testing/service_testing.html" title="http://developer.android.com/guide/topics/testing/service_testing.html">Service
Testing</a></li>
</ol>


<p>而應該程式測試測是測試<a href="http://developer.android.com/reference/android/app/Application.html" title="http://developer.android.com/reference/android/app/Application.html">Application</a></p>

<ol>
<li><a href="http://developer.android.com/guide/topics/testing/service_testing.html" title="http://developer.android.com/guide/topics/testing/service_testing.html">ApplicationTestCase</a></li>
</ol>


<p><a href="http://developer.android.com/reference/android/test/TouchUtils.html" title="http://developer.android.com/reference/android/test/TouchUtils.html">TouchUtils</a>
(android.test.TouchUtils)可用來產生touch
events，通常在InstrumentationTestCase or
ActivityInstrumentationTestCase2中使用。</p>

<h1>TestCases</h1>

<ul>
<li><p><a href="#androidtestcase" title="android:unit_testing_in_android ↵">AndroidTestCase</a></p>

<ol>
<li><a href="#providertestcase2" title="android:unit_testing_in_android ↵">ProviderTestCase2</a></li>
<li><a href="#servicetestcase" title="android:unit_testing_in_android ↵">ServiceTestCase</a></li>
<li><a href="#applicationtestcase" title="android:unit_testing_in_android ↵">ApplicationTestCase</a></li>
</ol>
</li>
<li><p><a href="#instrumentationtestcase" title="android:unit_testing_in_android ↵">InstrumentationTestCase</a></p>

<ol>
<li><p><a href="#activitytestcase" title="android:unit_testing_in_android ↵">ActivityTestCase</a></p>

<ol>
<li><a href="#activityinstrumentationtestcase" title="android:unit_testing_in_android ↵">ActivityInstrumentationTestCase</a></li>
<li><a href="#activityinstrumentationtestcase2" title="android:unit_testing_in_android ↵">ActivityInstrumentationTestCase2</a></li>
<li><a href="#activityunittestcase" title="android:unit_testing_in_android ↵">ActivityUnitTestCase</a></li>
</ol>
</li>
<li><p><a href="#providertestcase" title="android:unit_testing_in_android ↵">ProviderTestCase</a></p></li>
<li><a href="#singlelaunchactivitytestcase" title="android:unit_testing_in_android ↵">SingleLaunchActivityTestCase</a></li>
<li><a href="#syncbaseinstrumentation" title="android:unit_testing_in_android ↵">SyncBaseInstrumentation</a></li>
</ol>
</li>
</ul>


<h3>AndroidTestCase</h3>

<p>提供context是在Android
Framework中最重要的一個物件，在許多地方都會用到它，<code>這邊的context是test project的context</code>。
AndroidTestCase啟動時，會先做自我檢測，先驗証測試環境是否ready to
use.有提供幾個預先定義好的assert.</p>

<h3>ProviderTestCase2</h3>

<p>測試Provider的test
case,如果要測試資料而非UI的話，那測試的對象應該是<a href="http://developer.android.com/guide/topics/providers/content-providers.html" title="http://developer.android.com/guide/topics/providers/content-providers.html">Content
Provider</a>及Content
Provider用到的相關物件。</p>

<p>Android Test Framework有提供ProviderTestCase2可以Content
Provider進行獨立的測試。使用方式如下：</p>

<p>```
public class MyContentProviderTest extends ProviderTestCase2<MyContentProvider> {
 </p>

<pre><code>public MyContentProviderTest() {
    super(MyContentProvider.class, MyContentProvider.class.getName());
}
</code></pre>

<p> </p>

<pre><code>@Override
protected void setUp() throws Exception {
    super.setUp();
}
</code></pre>

<p> </p>

<pre><code>public void testInsert() throws Exception {
    ContentValues values = new ContentValues();
    values.put("name", "foo");
    getProvider().insert("context://xxx/xx", values);
    // do assert here
}
</code></pre>

<p> </p>

<pre><code>public void testQuery() throws Exception {
    getProvider().query("context://xxx/xx", null, null, null, null);
    // do assert here
}
</code></pre>

<p>}
```</p>

<p>此例中，測是對象為MyContentProvider,使用上要注意的有：</p>

<ol>
<li><p>Testcase要繼承自<a href="http://developer.android.com/reference/android/test/ProviderTestCase2.html" title="http://developer.android.com/reference/android/test/ProviderTestCase2.html">ProviderTestCase2</a></p>

<ul>
<li>可以將<code>ProviderTestCase2&lt;T&gt;</code>的template
&lt;T>指定成對象為MyContentProvider，這樣可以testcase內就會引用MyContentProvider而非ContentProvider</li>
</ul>
</li>
<li><p>必須要建立一個無參數的建構子(Constructor)</p></li>
<li><p>Constructor裡必須呼叫<code>super(MyContentProvider.class, MyContentProvider.class.getName());</code></p>

<ul>
<li>因為MyContentProvider的Authority為<code>MyContentProvider.class.getName()</code></li>
</ul>
</li>
<li><p>Testcase中透過getProvider()來取得MyContentProvider的instance，而不是自已創建MyContentProvider的instance</p></li>
</ol>


<h3>ServiceTestCase</h3>

<p>ServiceTestCase可以用來測試Android Service,ServiceTestCase</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_002.png" alt="unit_testing_in_android_002.png" /></p>

<p>基本的使用方式如下：</p>

<ol>
<li>宣告class時，把<code>template &lt;T&gt;</code>換成要被測試的Service(Service Under
Test)</li>
<li>建立default的constructor，並呼叫parent的constructor，代入class name</li>
<li>setUp()時，ServiceTestCase會將real context儲存到systemContext</li>
<li>透過startService()或bindService()啟動service
(呼叫service.onCreate())</li>
<li>test case的tearDown()會stop 跟 destroy service</li>
<li>如果有需要的話，可以透過setCotext()或setApplication()換掉test
case裡的context跟application.</li>
</ol>


<p>ServiceTestCase預設是使用MockApplication + Test Proejct的Context</p>

<p>```</p>

<pre><code>public abstract class ServiceTestCase&lt;T extends Service&gt; extends AndroidTestCase {
    protected void setupService() {
        mService = null;
        try {
            mService = mServiceClass.newInstance();
        } catch (Exception e) {
            assertNotNull(mService);
        }
        if (getApplication() == null) {
            setApplication(new MockApplication());  // 使用mock版的Application()，而不是真正的
        }
        mService.attach(getContext(), null,  mServiceClass.getName(), null, getApplication(), null);
        assertNotNull(mService);
        mServiceId = new Random().nextInt();
        mServiceAttached = true;
    }
} 
</code></pre>

<p>```</p>

<p>Android有提供<a href="#renamingdelegatingcontext" title="android:unit_testing_in_android ↵">RenamingDelegatingContext</a>,
<a href="#contextwrapper" title="android:unit_testing_in_android ↵">ContextWrapper</a>,
<a href="#isolatedcontext" title="android:unit_testing_in_android ↵">IsolatedContext</a>跟<a href="#mockcontext" title="android:unit_testing_in_android ↵">MockContext</a>來換原MockContext，也可以自已Mock一個</p>

<p>```
public class MyServiceTest extends ServiceTestCase<MyService> {</p>

<pre><code>public MyServiceTest() {
    super(MyService.class);
}
</code></pre>

<p>}
```</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_002.png" alt="unit_testing_in_android_002.png" /></p>

<p>ServiceTestCase提供<code>getService()</code>可以取得要被測試的service，<code>getSystemContext()</code>可以取得test
project context</p>

<h5>getContext() vs getSystemContext()</h5>

<p>在預設的情況下，如果沒有特別去設定context，getContext(),getSystemContext()是同一個instance，但是
如果有設定mock版的context，ex:
<code>setConext(new MockContext());</code>，那麼getContext()會取到mock版的，
而getSystemContext()會取到原來的(測試專案的)。</p>

<h3>ApplicationTestCase</h3>

<p>測試Application的test case</p>

<h3>InstrumentationTestCase</h3>

<h3>ActivityTestCase</h3>

<h3>ActivityInstrumentationTestCase</h3>

<h3>ActivityInstrumentationTestCase2</h3>

<h3>ActivityUnitTestCase</h3>

<h3>ProviderTestCase</h3>

<h3>SingleLaunchActivityTestCase</h3>

<h3>SyncBaseInstrumentation</h3>

<h1>要測那些東西</h1>

<h5>Activity lifecycle events</h5>

<p>如果有在Activity lifecycle events像是onCreate(), onResume(), onPause(),
…中保存activity的狀態，那麼應該要對這些methods進行測式，而當
Configuration-changed事件發生時，也需要確定這些event的動作都正確。</p>

<p><img src="http://developer.android.com/images/activity_lifecycle.png" alt="" /></p>

<p>TestCase :
<a href="#activityinstrumentationtestcase2" title="android:unit_testing_in_android ↵">ActivityInstrumentationTestCase2</a>
(大多數情況用這個),
<a href="#activitytestcase" title="android:unit_testing_in_android ↵">ActivityTestCase</a>,
<a href="#singlelaunchactivitytestcase" title="android:unit_testing_in_android ↵">SingleLaunchActivityTestCase</a></p>

<h5>Content Provder</h5>

<p>Content
Provder在大部份的情況下，不需要自行建立，也不建議直接建立，所以，Content
Provder在測試時， Insert, Update, Query,
Delete等method，還有getType()這些基本的methods都要被測到，如果沒有必要的話，
儘量不要自已publish額外的method，因為在程式裡，只能取到ContentProvder型別，無法直接取得子型別(除非透過型別轉換，但不建議)，
所以，ContentProvider的子類別，應儘量避免publish額外的API.</p>

<p>TestCase :
<a href="#providertestcase2" title="android:unit_testing_in_android ↵">ProviderTestCase2</a></p>

<h5>ListView Adapter</h5>

<p>ListView用的Adapter，ListView是UI裡很重要的一個元件，幾乎每個應該程式都會用到，而ListView
Adapter又是ListView中 主要的元件，對Adapter測試的重要性，不言可喻。</p>

<p>```
public class ScriptListAdapterTest extends AndroidTestCase {
 </p>

<pre><code>public void testExtractWords_none_words() throws Exception {
    ScriptListAdapter adapter = new ScriptListAdapter(getContext(), R.layout.script_list_item, R.id.scriptLine, ImmutableList.&lt;String&gt; of());
    adapter.setRichScript("foo bar");
    assertThat(adapter.extractWord(), Matchers.&lt;String&gt; emptyIterable());
}
</code></pre>

<p> </p>

<pre><code>public void testExtractWords_one_word() throws Exception {
    ScriptListAdapter adapter = new ScriptListAdapter(getContext(), R.layout.script_list_item, R.id.scriptLine, ImmutableList.&lt;String&gt; of());
    adapter.setRichScript("foo &lt;b&gt;bar&lt;/b&gt; baz");
    Iterable&lt;String&gt; words = adapter.extractWord();
    assertThat(words, hasItem("bar"));
}
</code></pre>

<p> </p>

<pre><code>public void testExtractWords_two_words() throws Exception {
    ScriptListAdapter adapter = new ScriptListAdapter(getContext(), R.layout.script_list_item, R.id.scriptLine, ImmutableList.&lt;String&gt; of());
    adapter.setRichScript("&lt;b&gt;foo&lt;/b&gt; bar &lt;b&gt;baz&lt;/b&gt;");
    Iterable&lt;String&gt; words = adapter.extractWord();
    assertThat(words, hasItems("foo", "baz"));
    assertThat(words, not(hasItem("bar")));
}
</code></pre>

<p> </p>

<pre><code>public void testRichText() throws Exception {
    ScriptListAdapter adapter = new ScriptListAdapter(getContext(), R.layout.script_list_item, R.id.scriptLine, ImmutableList.&lt;String&gt; of());
    CharSequence text = adapter.richText("this is a foo bar string", ImmutableList.of("foo", "string"));
    System.out.println(text);
</code></pre>

<p> </p>

<pre><code>}
</code></pre>

<p>}
```</p>

<p>TestCase :
<a href="#androidtestcase" title="android:unit_testing_in_android ↵">AndroidTestCase</a></p>

<h5>Database &amp; File</h5>

<p>我通常會對DatabaseHelper進行測試，以確定table可以正確的被建立或版更</p>

<p>```
public class DatabaseHelperTest extends TestCase {</p>

<pre><code>private DatabaseHelper    helper;
private SQLiteDatabase    db;
</code></pre>

<p> </p>

<pre><code>@Override
public void tearDown() {
    helper.close();
}
</code></pre>

<p> </p>

<pre><code>public void testDictionaryBankTable() throws Exception {
    Cursor c = db.query(DatabaseHelper.DICTIONARY_TABLE_NAME, null, null, null, null, null, null);
    assertEquals(4, c.getColumnCount());
}
</code></pre>

<p> </p>

<pre><code>public void testPodcastTable() throws Exception {
    Cursor c = db.query(DatabaseHelper.PODCAST_TABLE_NAME, null, null, null, null, null, null);
    assertEquals(13, c.getColumnCount());
}
</code></pre>

<p> </p>

<pre><code>public void testWordBankTable() throws Exception {
    Cursor c = db.query(DatabaseHelper.WORD_BANK_TABLE_NAME, null, null, null, null, null, null);
    assertEquals(2, c.getColumnCount());
}
</code></pre>

<p> </p>

<pre><code>@Override
protected void setUp() throws Exception {
    super.setUp();
    db = SQLiteDatabase.create(null);
    helper = new DatabaseHelper(null, "podcast.db", null);
    helper.onOpen(db);
    helper.onCreate(db);
}
</code></pre>

<p>}
```</p>

<p>TestCase: 沒有用到android 的context，只需用Junit內建的TestCase即可</p>

<h5>Helper &amp; Utils</h5>

<p>Helper跟Utils指的是跟Android比較無關類別，有可能用到網路或檔案系統等的class，可視情況選擇用TestCase,
AndroidTestCase, InstrumentationTestCase
通常我都是先用最簡單的，如果不適合，再找次簡單的。</p>

<h1>Test Helper</h1>

<h3>Mock Objects</h3>

<p>Android Test Framework也有提供一列系的mock
objects，如果在測試時採用Depedency Injection的方式把這些mock
object注入，會讓測試更簡單，更獨立。 這些mock
oject被放在<a href="http://developer.android.com/reference/android/test/mock/package-summary.html" title="http://developer.android.com/reference/android/test/mock/package-summary.html">android.test.mock
package</a>內，主要有下列這些mock
objects</p>

<ol>
<li>MockApplication A mock Application class.</li>
<li>MockContentProvider Mock implementation of ContentProvider.</li>
<li>MockContentResolver An extension of ContentResolver that is designed
for testing.</li>
<li>MockContext A mock Context class.</li>
<li>MockCursor A mock Cursor class that isolates the test code from real
Cursor implementation.</li>
<li>MockDialogInterface A mock DialogInterface class.</li>
<li>MockPackageManager A mock PackageManager class.</li>
<li>MockResources A mock Resources class.</li>
</ol>


<p>這些class採的mock
strategy是stubbing而不是mocking，也就是說，使用時必須overwrite掉要提供資訊的methods</p>

<p>曾經試著將在Android test framework上使用幾個mock
framework，都失敗了，目前都是直接使用Android test
framework內建的mocks，雖不好用但可以接受。</p>

<ol>
<li>mockito 1.8.5 - 無法通過編譯，殘念</li>
<li>easymock 3 - extension的部份無法通過編譯，也就是只能mock
interface，殘念</li>
<li>powermock - 還是需要mocktio或easymock的jar，殘念</li>
<li>jmock - 沒試</li>
</ol>


<p><a href="https://sites.google.com/site/androiddevtesting/" title="https://sites.google.com/site/androiddevtesting/">這裡</a>有篇文章說明為何大多數的Mock
framework在Android上的無法正常動作， 只要是Mock
Framework有用到CGLib就無法在Dalvik
VM上執行，ex:EasyMock,Mockito都有用到這個lib</p>

<p>2012/3/16 己經有android team的member在將mockito
porting到android上了，或許不久的將來就有android
compatible的mockito可以用了 :) ，詳情 :
<a href="http://code.google.com/p/mockito/issues/detail?id=308" title="http://code.google.com/p/mockito/issues/detail?id=308">http://code.google.com/p/mockito/issues/detail?id=308</a></p>

<h3>Context For Testing</h3>

<p>Context的type hierarchy</p>

<p><img src="http://blog.kent-chiu.com/images/2012-04-13/unit_testing_in_android_002.png" alt="unit_testing_in_android_002.png" /></p>

<p>跟測試比較相關的有</p>

<ol>
<li><a href="#contextwrapper" title="android:unit_testing_in_android ↵">ContextWrapper</a></li>
<li><a href="#isolatedcontext" title="android:unit_testing_in_android ↵">IsolatedContext</a></li>
<li><a href="#renamingdelegatingcontext" title="android:unit_testing_in_android ↵">RenamingDelegatingContext</a></li>
<li><a href="#mockcontext" title="android:unit_testing_in_android ↵">MockContext</a></li>
</ol>


<h5>ContextWrapper</h5>

<p>嚴格來說，這個並不算是testing專用的，其他不少context也是從這個開始繼承的，他的實作很簡單
，就是把被wrapped的context的delegate給ContextWrapper，所以，每個method大多長這樣</p>

<p>```
/<em>*
 * Proxying implementation of Context that simply delegates all of its calls to
 * another Context.  Can be subclassed to modify behavior without changing
 * the original Context.
 </em>/
public class ContextWrapper extends Context {</p>

<pre><code>Context mBase;

@Override
public AssetManager getAssets() {
    return mBase.getAssets();
}

@Override
public Resources getResources()
{
    return mBase.getResources();
}

@Override
public PackageManager getPackageManager() {
    return mBase.getPackageManager();
}
...
</code></pre>

<p>}
```</p>

<h5>IsolatedContext</h5>

<p>這個Context把跟設備相關的method改掉掉，讓context不與設備直接溝通，但又提供足夠的功能以測試可以進行。
被IsolatedContext改寫掉的methods如下</p>

<p>(圖丟了 XD)</p>

<h5>RenamingDelegatingContext</h5>

<p>正常來說，如果production code裡用到的db 叫
foo.db跟一個檔案叫bar.txt，但測試時，希望不要去動到原來的foo.db,bar.txt
，而是提供一組測試用的foo.db跟bar.txt那就可以用RenamingDelegatingContext處理，可以把測試的命名成
test_foo.db跟test_bar.txt，然後跟RenamingDelegatingContext測試用的contxt是以”test_”當prefix即可，這樣所有測試用的
的檔案名稱跟DB名稱就是原來的名稱加上”test_”，用以避免prodcution
code跟testing code互相感染。</p>

<p>RenamingDelegatingContext是用來處理檔案都是放在application
project中的情況，但實際使用上，在測試專案上的相同的位置放上一個同檔名的檔案，會比用RenamingDelegatingContext適合，
不過，如果取得測試案專案的resource，就得繼承自InstrumentationTestCase而非AndroidTestCase體系</p>

<h5>MockContext</h5>

<p>Mock版的Context，裡面的implement就是丟出UnsupportedOperationException，所以如果要用這個context，那
測試中有用到的method，就要自行改寫，不然就等著接UnsupportedOperationException。</p>

<p>```
/<em>*
 * A mock {@link android.content.Context} class.  All methods are non-functional and throw
 * {@link java.lang.UnsupportedOperationException}.  You can use this to inject other dependencies,
 * mocks, or monitors into the classes you are testing.
 </em>/
public class MockContext extends Context {
 </p>

<pre><code>@Override
public AssetManager getAssets() {
    throw new UnsupportedOperationException();
}
</code></pre>

<p> </p>

<pre><code>@Override
public Resources getResources() {
    throw new UnsupportedOperationException();
}
</code></pre>

<p> </p>

<pre><code>@Override
public PackageManager getPackageManager() {
    throw new UnsupportedOperationException();
}
...
</code></pre>

<p>}
```</p>

<h3>Assertion classes</h3>

<p>除了基本的Junit Assertions外，Android Test Framework還提供了</p>

<ol>
<li><a href="http://developer.android.com/reference/android/test/MoreAsserts.html" title="http://developer.android.com/reference/android/test/MoreAsserts.html">More
Asserts</a>

<ul>
<li>一些android testing
assertions的延伸，不過我覺得<a href="http://wiki.kent-chiu.com/doku.php?id=java:hamcrest_101" title="java:hamcrest_101">hamcrest</a>更好用</li>
</ul>
</li>
<li><a href="http://developer.android.com/reference/android/test/ViewAsserts.html" title="http://developer.android.com/reference/android/test/ViewAsserts.html">View
Asserts</a>

<ul>
<li>一些跟view有關的assertions，像是view跟view之間的關係、對齊方式、…</li>
</ul>
</li>
</ol>


<p>目前Android Test Framework(Android
2.3)還都是基於Junit3,Junit3的assertions在使用上沒有Junit4的來方便(powered
by Hamcrest)，Junit3沒有內建<code>assertThat()</code>，
Hamcrest的assertions是一個獨立的lib，所以，還是可以拿來跟Junit3搭著用，但是，Hamrcest的jar檔(1.3-R.C2)丟到Eclipse
ADT時，無法順利通過編譯，<a href="http://wiki.kent-chiu.com/doku.php?id=java:hamcrest_101#hamcrest_android" title="java:hamcrest_101">這裡有提供解決的方式</a>
，至於Hamcrest的assertion，可以參閱<a href="http://code.google.com/p/hamcrest/wiki/Tutorial" title="http://code.google.com/p/hamcrest/wiki/Tutorial">Hamcrest網站的教學</a>或<a href="http://wiki.kent-chiu.com/doku.php?id=java:hamcrest_101" title="java:hamcrest_101">這裡</a>也有一個簡單的說明。</p>

<h4>MISC</h4>

<ol>
<li>RenamingDelegating - Product
code用的是一個名字，測試時用的是另一個名字(檔案或資料庫)，用來避開testing
code改到product code的內容</li>
<li>ActivityMonitor -
android.app.Instrumentation.ActivityMonitor是Instrumentation的內部類別，可以用來monitor系統的行為。</li>
</ol>


<p>如果test proejct跟production project有用到相同的jars，只需由production
project export出jars讓testing project使用即可，如果testing
project有跟production project相同的lib，可能compile time會出錯</p>

<h1>Resources</h1>

<ul>
<li><a href="http://developer.android.com/resources/tutorials/testing/helloandroid_test.html" title="http://developer.android.com/resources/tutorials/testing/helloandroid_test.html">Hello World
Test</a></li>
<li><a href="http://developer.android.com/guide/topics/testing/testing_android.html" title="http://developer.android.com/guide/topics/testing/testing_android.html">Testing and
Instrumentation</a></li>
<li><a href="http://developer.android.com/guide/developing/testing/testing_eclipse.html" title="http://developer.android.com/guide/developing/testing/testing_eclipse.html">Testing In Eclipse, with
ADT</a></li>
<li><a href="http://codinghard.wordpress.com/2009/06/04/a-first-look-at-the-android-testing-framework/" title="http://codinghard.wordpress.com/2009/06/04/a-first-look-at-the-android-testing-framework/">http://codinghard.wordpress.com/2009/06/04/a-first-look-at-the-android-testing-framework/</a></li>
<li><a href="http://code.google.com/p/nativedriver/" title="http://code.google.com/p/nativedriver/">Native
Driver</a>

<ul>
<li>google官方的ui test
api，webdriver(<a href="http://code.google.com/p/selenium/" title="http://code.google.com/p/selenium/">selenium</a>)
like的測試工具</li>
</ul>
</li>
<li><p>RenamingDelegatingContext的使用方式可以參考下面的資料</p>

<ol>
<li><a href="http://blog.jayway.com/2011/10/10/using-renamingdelegatingcontext-to-mock-contentresolver-in-android/" title="http://blog.jayway.com/2011/10/10/using-renamingdelegatingcontext-to-mock-contentresolver-in-android/">http://blog.jayway.com/2011/10/10/using-renamingdelegatingcontext-to-mock-contentresolver-in-android/</a></li>
<li><a href="https://docs.google.com/View?id=ddwc44gs_21737cgtvfj" title="https://docs.google.com/View?id=ddwc44gs_21737cgtvfj">https://docs.google.com/View?id=ddwc44gs_21737cgtvfj</a></li>
</ol>
</li>
<li><p><a href="http://www.slideshare.net/dtmilano/introduction-to-android-testing" title="http://www.slideshare.net/dtmilano/introduction-to-android-testing">http://www.slideshare.net/dtmilano/introduction-to-android-testing</a></p>

<ul>
<li>android testing的簡介投影片，有每個test case使用上的差異</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DBUnit 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/30/dbunit_101/"/>
    <updated>2012-03-30T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/30/dbunit_101</id>
    <content type="html"><![CDATA[<p>DBUnit並不是一個真正的資料庫，它只是用來方便將準備好的資料(DataSet)，新增進資料庫，
<a href="http://www.dbunit.org/components.html" title="http://www.dbunit.org/components.html">DataSet</a>類型有:</p>

<ol>
<li>FlatXml - 較簡單的xml格式，但在沒有dtd搭配下，可能會有問題</li>
<li>Xml - 建議使用這個格式</li>
<li>Excel - MS Excel</li>
<li>CSV - csv</li>
<li>Replacement - 可以用Expression Language換掉部份內容的格式</li>
<li>DefaultDataSet - 用程式控制的dataset</li>
<li><a href="http://jyaml.sourceforge.net/yaml4dbunit.html" title="http://jyaml.sourceforge.net/yaml4dbunit.html">YAML</a>

<ul>
<li>YAML格式(非官方)</li>
</ul>
</li>
<li><a href="http://www.insaneprogramming.be/?p=105" title="http://www.insaneprogramming.be/?p=105">JSON</a>

<ul>
<li>JSON格式(非官方)</li>
</ul>
</li>
</ol>


<p>```</p>

<pre><code>Connection connection = DriverManager.getConnection("jdbc:hsqldb:mem:testdb;shutdown=true");
IDatabaseConnection dbunitConnection = new HsqldbConnection(connection, null);
XmlDataSet dataSet = new XmlDataSet(this.getClass().getResourceAsStream("/export.xml"));
DatabaseOperation.CLEAN_INSERT.execute(dbunitConnection, dataSet);
</code></pre>

<p>```</p>

<p>在使用dbunit前，database應該要先建立好了，dbunit不會建立schema，它只是一個幫忙insert，update，delete的資料的工具。
一般實作上，我會採用Hibernate提供的自動建立schema工具，在啟動時自動建立schema。</p>

<h1>Resource</h1>

<ul>
<li><a href="http://danhaywood.com/2011/12/20/db-unit-testing-with-dbunit-json-hsqldb-and-junit-rules/" title="http://danhaywood.com/2011/12/20/db-unit-testing-with-dbunit-json-hsqldb-and-junit-rules/">DB unit testing with dbUnit, JSON, HSQLDB and JUnit
Rules</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing JSP in Jetty Server (Embedded Mode)]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/20/testing_jsp_in_jetty/"/>
    <updated>2012-03-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/20/testing_jsp_in_jetty</id>
    <content type="html"><![CDATA[<p>```
package com.bellwin.idcview.login.page;
 
import static org.junit.Assert.assertTrue;
 
import org.eclipse.jetty.server.Connector;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.nio.SelectChannelConnector;
import org.eclipse.jetty.webapp.WebAppContext;
import org.junit.Before;
import org.junit.BeforeClass;
 
import com.gargoylesoftware.htmlunit.WebClient;
 
public abstract class AbstractContainerTest {</p>

<pre><code>protected static PauseableServer server;
</code></pre>

<p> </p>

<pre><code>protected static final int port = 9180;
</code></pre>

<p> </p>

<pre><code>protected static final String BASEURI = "http://localhost:" + port + "/";
</code></pre>

<p> </p>

<pre><code>protected final WebClient webClient = new WebClient();
</code></pre>

<p> </p>

<pre><code>@BeforeClass
public static void startContainer() throws Exception {
    if (server == null) {
        server = new PauseableServer();
        Connector connector = new SelectChannelConnector();
        connector.setPort(port);
        server.setConnectors(new Connector[]{connector});
        server.setHandler(new WebAppContext("src/main/webapp", "/"));
        server.start();
        assertTrue(server.isStarted());
    }
}
</code></pre>

<p> </p>

<pre><code>@Before
public void beforeTest() {
    webClient.setThrowExceptionOnFailingStatusCode(true);
}
</code></pre>

<p> </p>

<pre><code>public void pauseServer(boolean paused) {
    if (server != null) {
        server.pause(paused);
    }
}
</code></pre>

<p> </p>

<pre><code>public static class PauseableServer extends Server {
    public synchronized void pause(boolean paused) {
        try {
            if (paused) {
                for (Connector connector : getConnectors()) {
                    connector.stop();
                }
            } else {
                for (Connector connector : getConnectors()) {
                    connector.start();
                }
            }
        } catch (Exception e) {
        }
    }
}
</code></pre>

<p>}
```</p>

<p>```
package com.bellwin.idcview.login.page;
 
import java.io.IOException;
import java.net.MalformedURLException;
 
import org.junit.Before;
import org.junit.Test;
 
import com.gargoylesoftware.htmlunit.ElementNotFoundException;
import com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;
import com.gargoylesoftware.htmlunit.WebAssert;
import com.gargoylesoftware.htmlunit.html.HtmlCheckBoxInput;
import com.gargoylesoftware.htmlunit.html.HtmlForm;
import com.gargoylesoftware.htmlunit.html.HtmlInput;
import com.gargoylesoftware.htmlunit.html.HtmlPage;
 
public class ContainerIntegrationTest extends AbstractContainerTest {
 </p>

<pre><code>@Before
public void logOut() throws IOException {
    // Make sure we are logged out
    final HtmlPage homePage = webClient.getPage(BASEURI);
    try {
        homePage.getAnchorByHref("/logout.jsp").click();
    }
    catch (ElementNotFoundException e) {
        //Ignore
    }
}
</code></pre>

<p> </p>

<pre><code>@Test
public void logIn() throws FailingHttpStatusCodeException, MalformedURLException, IOException, InterruptedException {
    HtmlPage page = webClient.getPage(BASEURI + "login.jsp");
    HtmlForm form = page.getFormByName("loginform");
    form.&lt;HtmlInput&gt;getInputByName("username").setValueAttribute("root");
    form.&lt;HtmlInput&gt;getInputByName("password").setValueAttribute("secret");
    page = form.&lt;HtmlInput&gt;getInputByName("submit").click();
    // This'll throw an expection if not logged in
    page.getAnchorByHref("/logout.jsp");
}
</code></pre>

<p> </p>

<pre><code>@Test
public void logInAndRememberMe() throws Exception {
    HtmlPage page = webClient.getPage(BASEURI + "login.jsp");
    HtmlForm form = page.getFormByName("loginform");
    form.&lt;HtmlInput&gt;getInputByName("username").setValueAttribute("root");
    form.&lt;HtmlInput&gt;getInputByName("password").setValueAttribute("secret");
    HtmlCheckBoxInput checkbox = form.getInputByName("rememberMe");
    checkbox.setChecked(true);
    page = form.&lt;HtmlInput&gt;getInputByName("submit").click();
    server.stop();
    server.start();
    page = webClient.getPage(BASEURI);
    // page.getAnchorByHref("/logout.jsp");
    WebAssert.assertLinkPresentWithText(page, "Log out");
    page = page.getAnchorByHref("/account").click();
    // login page should be shown again - user remembered but not authenticated
    WebAssert.assertFormPresent(page, "loginform");
}
</code></pre>

<p> 
}
```</p>

<p>You may want to logging message during Server starting.</p>

<p>```
<logger name="org.eclipse.jetty.util.log" additivity="false"></p>

<pre><code>&lt;level value="debug" /&gt;
&lt;appender-ref ref="stdout" /&gt;
</code></pre>

<p></logger>
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Exception In JUnit]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/20/test_exception_in_junit/"/>
    <updated>2012-03-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/20/test_exception_in_junit</id>
    <content type="html"><![CDATA[<p>之前遇到測exception message都還改回用try catch，原來，可以用mock
like的方式去測exception message.</p>

<p>```
@Rule
public ExpectedException thrown = ExpectedException.none();
 
@Test
public void shouldNotLetUnknownUserLogin() throws UnknownUserException {</p>

<pre><code>thrown.expect(UnknownUserException.class);
thrown.expectMessage("Unknown user: joe");
UserDao dao = mock(UserDao.class);
when(dao.findByName("joe")).thenReturn(null);
manager.setUserDao(dao);
manager.login("joe","secret");
</code></pre>

<p>}
```</p>

<p><code>
thrown.expectMessage(JUnitMatchers.containsString("joe"));
</code></p>

<p>code snippet is from
<a href="http://weblogs.java.net/blog/johnsmart/archive/2009/09/27/testing-exceptions-junit-47" title="http://weblogs.java.net/blog/johnsmart/archive/2009/09/27/testing-exceptions-junit-47">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Android進行TDD式的開發]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/20/tdd_in_android/"/>
    <updated>2012-03-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/20/tdd_in_android</id>
    <content type="html"><![CDATA[<p>網路上的android的testing教學，基本上都不太算是真正的unit
testing，而比較像是Integration
Testing(整合測試)，因為大多都需要在模擬器或實機中執行測試，這樣便與環境相關。</p>

<p>目前找到最能接近<a href="http://en.wikipedia.org/wiki/Test%20Driven%20Development" title="http://en.wikipedia.org/wiki/Test Driven Development">Test Driven
Development</a>的方式，是使用<a href="http://pivotal.github.com/robolectric/index.html" title="http://pivotal.github.com/robolectric/index.html">Robolectric</a>進行真正的Unit
Test。</p>

<h3>開發環境設定 (使用ADT)</h3>

<p>robolectric的開發環境設定比較不一樣，務必參考它網站上的教學一步一步做，主要的關鍵在Test
Project是一般的java project，透過Eclipse Link
Folder的功能，把測試程式link到Test Project。</p>

<p>照<a href="http://pivotal.github.com/robolectric/eclipse-quick-start.html" title="http://pivotal.github.com/robolectric/eclipse-quick-start.html">網站上的教學</a>做完後，會有一個試車的動作，如果run起來有出exception，可能sdk版本沒設好，1.0-rc版的Robolectric，預設是sdk
version是9
，如果沒有這一版本的sdk，就會出錯，只要設定<strong>uses-sdk</strong>即可改變Robolectric預設的版本。</p>

<p>```</p>

<pre><code>  &lt;uses-sdk android:targetSdkVersion="10" android:minSdkVersion="10"&gt;&lt;/uses-sdk&gt;
</code></pre>

<p>```</p>

<h3>開發環境設定 (使用Maven)</h3>

<p>不太建議用maven進行android的開發，maven的一些預設的設定，跟ADT產生出來的專案結構不太一樣，而且使用上也比ADT麻煩多了，除非有特殊需求(ex:android
project要上CI)，不然真的是不建議。</p>

<p>我自已是會開一個maven
base的專案，不過主要目的是為了要抓相關的lib，實際開發上，還是直接用ADT，而且不掛任何maven的plugins(eclipse的plugin，不是maven本身的plugin)</p>

<h3>Database 測試</h3>

<p>Database的測試需要特別注意，robolectric裡的Shadow
Database是用H2實作，而非SQLite，而且，H2會使用in-momery的方式建立table，所以，可能在同一個test的case的同一個method，你沒也辦法去insert一筆資料後，再透過query把它找出來，目前正在尋找適當的solution
(也有可能是我的使用方式有錯)</p>

<p>整個專案下做下來，用robolectric遇到了不少問題，讓我有IOC
container流行前做TDD的那種痛苦，很多測試都很難進行，寫測寫變成一種痛苦，而不是快樂。</p>

<p>主要的原因在於robolectric的原理是用shadow
object，很多行為都沒有真正進行實作，都是傳回物件的預設值，裡面沒有任何
behaviors, 而且又沒提供一個很容易的方式去動態的改變這種shadow
object的動作方式，造成測試上的困擾。</p>

<h1>Resource</h1>

<ul>
<li><a href="http://pivotal.github.com/robolectric/index.html" title="http://pivotal.github.com/robolectric/index.html">http://pivotal.github.com/robolectric/index.html</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
