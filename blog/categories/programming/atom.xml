<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2014-05-29T12:26:05+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clean Code閱讀筆記]]></title>
    <link href="http://blog.kent-chiu.com/blog/2013/04/22/clean-code/"/>
    <updated>2013-04-22T10:06:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2013/04/22/clean-code</id>
    <content type="html"><![CDATA[<h6>代碼被讀取的次數遠比寫的次數多</h6>

<p>之前只會以為這句是很正常不過的話，而且也認為通常是讀代碼的對象大多是自己，但 Uncle Bob 用一個 Editor Replay (讓編輯器或 IDE
有類似 Media Player replay 的功能)的例子說明，當在 coding 時，在 method 間的查閱，呼叫，引用…等，這就是在閱讀自己的代碼了。
也就是說，當要寫一個功能時，就一定會不斷的在閱讀自己的代碼了。</p>

<h6>童子軍軍規</h6>

<p>童子軍有一條軍規是<strong>讓營地比你來時更乾淨</strong>，套用在寫程式上，就是在每次的 checkin ，代碼應該都是要比 checkout 時更 clean</p>

<p>很多人都提到好的程式，不是一開始就規畫出來的，而且每天不斷不斷的重構、改進。重構這些也不用刻意安排時間去做，應該是在每次的
checkin / checkout 時就順手整理。</p>

<h2>命名</h2>

<h6>命名要能揭示他的意圖</h6>

<ul>
<li>WHY  : 要能看出為何存在</li>
<li>WHAT : 要能看出做了什麼</li>
<li>HOW  : 要能看出如何被使用 (是如何被使用，不是如何做)</li>
</ul>


<p>如果命名時還需要加上額外的注釋，就不會是個好的名字</p>

<h6>不要用不夠明確的字</h6>

<pre><code>getActiveAccount()
getActiveAccounts()
getActiveAccountInfo()
</code></pre>

<p>這三者並無法從名字上區分不同，應該要避免。 (不過個人覺得 account, accounts 是有作用的字，一個代表單數，一個代表複數資料結構)
像是 <em>Info,Object,Data</em> 這樣的字，跟 a, an, the 一樣，太含混的字，不應該用來命名</p>

<p>也不用特意在命名時加上型別， ex: NameString, CustomerObject 因為在 IDE 幫助下，已經可以很方便的知道物件的型號了，不需要特別去加上類別資訊</p>

<h6>採用技術性的命名方式，而非領域性的命名方式</h6>

<p>會去看代碼的，大多是 programmer ，所以應該是用技術性的名字，像是 JobQuery, AccountVisitor 來取名字，而不是領域上的專業術語，如果一定要用到領域上的術語
，那務必讓術語的名字與領域術語能一致。</p>

<blockquote><p>私以為有時使用領域術語命名，會比較直覺，要維護該程式，應該要對該專業領域有所瞭解</p></blockquote>

<h4>Class Name</h4>

<ul>
<li>不要有像 Info, Data, Processor這樣的字</li>
</ul>


<h4>命名的一致性</h4>

<ul>
<li>像 fetch, retrieve, get 意義上相等的字，應該只取一組就好，不要有的 method 是用 get ，有的又用 fetech，還有的用 retrieve 這樣，使用 API 的人，搞不清楚要用那一套</li>
<li>Driver, Manager, Controller 也是意義上相等的字，應該只取一組就好，因為很難從字面上分辨 DeviceManger 跟 DeviceController 會有什麼不同</li>
</ul>


<blockquote><p>如果是實作上本身就有差異性 ex: insert 跟 append，那兩個近義字同時使用，是可被接授的</p></blockquote>

<h2>Functions</h2>

<ul>
<li>function 愈短愈好，但怎樣的長度叫短呢？ Uncle Martin 認為應該像 Kent Beck 的寫作風格一樣，每個 method 都不超過5行</li>
<li>每個 if, else , while statement 的內容，應該要只有一行，可以用 function call (extract to function) 把內容濃縮成一行，
這樣不但可以讓 method 改小，也可以增加可讀性，也就是說，程式裡只要出現 nest structure 就是一個可以做 extract 的訊號</li>
<li><p><em>一個 funciton 應該只作一件事</em>，但何謂一件事呢？如果 function 可以的部份內容可以被 extract 成另一個 funciton ，
extract 後的 function 是一個完全不同於原來 function 的功能，而不只用另一個方式描述原來的功能，就代表了 function 坐了不止一件事</p>

<pre><code>  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { 
      if (isTestPage(pageData))
          includeSetupAndTeardownPages(pageData, isSuite); 
          return pageData.getHtml();
      }
  }
</code></pre>

<p>如果將上面的 function extract 成</p>

<pre><code>  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { 
      return includeSetupsAndTeardownsIfTestPage(pageData, isSuite);
  }

  public static String includeSetupsAndTeardownsIfTestPage( PageData pageData, boolean isSuite) throws Exception {     
      if (isTestPage(pageData))
          includeSetupAndTeardownPages(pageData, isSuite); 
          return pageData.getHtml();
      }
  }
</code></pre>

<p>新的 <code>includeSetupsAndTeardownsIfTestPage</code> function 只是在用另外一種方式描述 <code>renderPageWithSetupsAndTeardowns()</code> 雖然可以這樣做 extract，
但這不代表了原來的 <code>includeSetupsAndTeardownsIfTestPage</code>  做了不止一件事，因為新的 function 只是另一種方式來描述原來的 function,
而如果一個 funtion 的內容，分了成幾個斷落 (sections)，顯示的，這也表明了這個 function 做了不止一件事</p></li>
</ul>


<blockquote><p>我試著去翻出 Kent Beck 最早期的 junit (3.4) 大多的 function 也都相當的短 (10行以下)， 也有少數比較長的，但也沒超過50行
不過，讓每個 function 都小到了極致，那勢必會產生更多的 fucntions 或 classes 而造成 <em>Divergent Change（發散式變化</em> 或 <em>Shotgun Surgery（霰彈式修改)</em>
這部份，可透過package或class的重新組織，並秉持著single responsibility principle (單一職責原則)，通常就不會有太大的問題</p></blockquote>

<ul>
<li>functon 內的實作抽像等級應該要一致，不要同一個 function 內，有很高階的實作，又有很低階的實作
高階，低階是指實作的抽象性，像 getHtml() 就是比較高階，而字串相加，就是屬於比較低階的實作</li>
<li>small function 在取名上也比較容易，因為它只做一件事，就會比較容易給他一個相符的名稱，所以，如果 funciton 在命名上有困難時，也許就是該 funciton 做了不止一件事了</li>
</ul>


<h2>Arguments</h2>

<ul>
<li>參數的數量愈少愈好，如果能沒有參數最好，三個參數應該已是最大值，四個參數應該是特殊狀況了</li>
<li><em>參數數量多，程式的可測性也會降，更多的參數，將需要更多的測試</em>，因為參數的排列組合的方式會更多，需要更多的測試</li>
<li>用布林當參數時，通常代表該 function 可以被切割成兩個 function</li>
</ul>


<h4>回傳值</h4>

<ul>
<li>應儘量避免使用回傳值，如果回傳值是為了改變某個狀態，應該要直接改變物件本身</li>
</ul>


<h2>Exceptions</h2>

<ul>
<li>例外處理的 try / catch / finally 本身就是<em>一件事</em>，不可做切割</li>
<li>例外處理不要值用error code，不然會造成所有人都依賴的這個 error code，要異動時，一定得去異動 error code</li>
</ul>


<h2>Object And Data Structures</h2>

<p>這樣的code，違反了Law of Demeter</p>

<pre><code>final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
</code></pre>

<p>最好改成這樣</p>

<pre><code>Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
</code></pre>

<p>不選，如果一個 function 像這樣包含了太多相關的物件，那就應該考慮是不是有責任歸屬的問題，重新釐清每個物件的責任後，或許會有所改善</p>

<h2>Boundaries</h2>

<p>如果需要在物件間傳遞 Map, List, Set 結構時，可以將它包成物件.</p>

<h4>Learning tests</h4>

<p>使用 third-party lib 是件不同易的事，要對 thrid-party lib 整合更是不容易，我們可以透過讀閱讀過文件後，寫一些簡單來驗証 lib 行為，是不是跟我們所理解的一樣。
這樣的測試叫 Learning tests。</p>

<h2>Testings</h2>

<ul>
<li>可讀性對 test code 比 production code 更重要。</li>
<li>專業的程式員應該要將測試重構成更具描述性的表達方式</li>
<li>每個 test case 裡的 asssertions 應該要儘可能的少，有人甚至主張一個 test case 只能有一個 assertion，至少應該儘量保持 singal concept per test</li>
</ul>


<p>BDD Given/When/Then test case 的寫法</p>

<p>```</p>

<pre><code>public void testGetPageHierarchyAsXml() throws Exception { 
    givenPages("PageOne", "PageOne.ChildOne", "PageTwo");
    whenRequestIsIssued("root", "type:pages");
    thenResponseShouldBeXML();
 }


public void testGetPageHierarchyHasRightTags() throws Exception { 
    givenPages("PageOne", "PageOne.ChildOne", "PageTwo");
    whenRequestIsIssued("root", "type:pages");
    thenResponseShouldContain("&lt;name&gt;PageOne&lt;/name&gt;", "&lt;name&gt;PageTwo&lt;/name&gt;", "&lt;name&gt;ChildOne&lt;/name&gt;"); 
}
</code></pre>

<p>```</p>

<h6>F.I.R.S.T.</h6>

<ul>
<li>Fast 執行起來要夠快，才會經常去執行</li>
<li>Independent 獨立，不需要 testing code 及 production code 以外的東西，像是還要手動設定資料庫，或一定要網路連線</li>
<li>Repeatable 可重覆 (可重現)</li>
<li>Self-Validating  簡單而明確的指出測式的結果 (red bar / green bar) 跟失敗的原因</li>
<li>Timely 測試要在 proudction code 之前寫好，而不是寫好了 production code 再來寫測式 ( test first or TDD )</li>
</ul>


<h2>Classes</h2>

<p>Uncle Bob 提倡<em>報紙代排版</em>，也就是 functions 不是換按照 scope ( public -> package -> protected -> private )，而是照閱讀順序 (stepdown)，
一般以 plulic scope 的 fucntion 開始，緊接著是依該 public 裡值用到的順序做排列， 這樣會像報紙一樣，以上至下的閱讀。</p>

<blockquote><p>目前要採用這種方式， IDE (eclipse , interllij ) 目前並沒有支援，況且，如果 function 被多個 function 呼叫， 被呼叫的 function 要放那，也是一個問題。
目前 ide 都有 function 的 outline 可以快速跳掉某個 function ， eclipse 也有可以直接看另一個被呼叫的 function viewer ，
私以為 newspaper format 不是那麼必要。</p></blockquote>

<h4>保持精簡</h4>

<p>Class 應該儘可能的小，但要小到多少？用 function 的數量來計數比是那麼的精確，用檔案大小來計算，更是不容易反應出 class
的真實大小，在計算 classs 的大小採用的是所讀的<em>職責數</em>，在 OOP 五大定理原則裡有一個叫 SPR (Single Responsibility
Principle), 中文為<em>單一職責原則</em>，單一職責原則要求每個 class 應該只有一個責任（只做一件事），所以，我們可以用　class
是否做了太多的事來判斷 class 是不是太大。</p>

<blockquote><p>用比較實務上的方式來解釋<em>單一職責原則</em>的話，可以這樣說: 當同一個物件需要異動時，應該都是基於相同的理由</p></blockquote>

<pre><code>public class SuperDashboard extends JFrame implements MetaDataUser public Component getLastFocusedComponent()
public void setLastFocused(Component lastFocused)
public int getMajorVersionNumber()
public int getMinorVersionNumber()
public int getBuildNumber() }
</code></pre>

<p>以上面的 SuperDashboard class 來說，它就具備了兩個職責</p>

<ol>
<li>版本資訊</li>
<li>Java Swing的物件結構</li>
</ol>


<p>所以，當出貨時(理由一)，版本資訊需要異動， focus (GUI 元件的 foucs)異動時，也可能會改變 SuperDashboard，所以這個 class 應該再被細分。</p>

<h4>少量的 Large Class V.S. 大量的 Small Class</h4>

<p>在設計 class 時，多數人更偏好寫一個很大的 class 而不是 許多的小 classes，因為這樣可以不用在 class見跳來跳去的閱讀，可以在同一個檔
案裡找到所有需要的東西，覺得畫分成小的 class 反而是造成程式可讀性不佳的原兇。其實，<strong>這一定是個誤會</strong>，切成許多單一職責的 classes，
只要透過系統化的分類，不但可以更快的找到需要的功能。</p>

<p>舉例來說，將許多的小零件分門別類的放在工具箱的小抽遞內，一定比全部混放在一個大抽遞更能被快速的找到。所以，不要害怕 class 的切割，做好
SPR，其他的問題，可以透過系統化的組織來解決 class 過多的問題，而且 Small Class 在 reused的效果上也更好，測試上也比較容易。</p>

<h4>內聚力</h4>

<p>class 的 instance variables 的被 class 內的 methods 引用的次數愈多，表示其內聚力愈強，如果一個類別的內聚力太低時，就應該考慮是否做切割。</p>

<blockquote><p>內聚力太低時，通常也代表 instance variables 數量太多，某些可能只被特定的 methods 引用，那可能就意味這些 methods 應該被
extract 出去成為另一個獨立的 class， 這樣對兩個 classes 來說，都會有更高的內聚力</p></blockquote>

<h2>Emergence</h2>

<p>Kent Beck's Xp Simplicity Rules:</p>

<ol>
<li>Runs all the tests</li>
<li>Contains no duplication</li>
<li>Expresses the intent of the programmer</li>
<li>Minimizes the number of classes and methods</li>
</ol>


<p>ref: <a href="http://c2.com/cgi/wiki?XpSimplicityRules">http://c2.com/cgi/wiki?XpSimplicityRules</a></p>

<h4>重構的方向</h4>

<ol>
<li>去除重覆</li>
<li>可讀性</li>
<li>保持最少跟最小的 classes, methods</li>
</ol>


<h2>Resource</h2>

<ul>
<li>planetgeek.ch 整理的clean code cheetsheet <a href="http://www.planetgeek.ch/2013/06/05/clean-code-cheat-sheet/">http://www.planetgeek.ch/2013/06/05/clean-code-cheat-sheet/</a> , <a href='http://blog.kent-chiu.com/images/blog/2013-04-22/Clean-Code-V2.2.pdf'>備份檔</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Regular Expression (RE)]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/09/12/regular_expression/"/>
    <updated>2012-09-12T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/09/12/regular_expression</id>
    <content type="html"><![CDATA[<h3>The Negated Character ^</h3>

<p>Remember, a negated character class means “match a character that's not
listed” and not “don't match what is listed.”</p>

<p>Thus, [^x] doesn't mean <strong>“match unless there is an x”, but rather
match if there is something that is not x .</strong> The difference is subtle,
but important. The first concept matches a blank line, for example,
while ![^x] does not.</p>

<p>A character class, even negated, still requires a character to match.</p>

<h3>The Dot Charactor .</h3>

<p>It can be convenient when you want to have an <strong>any character here</strong>
placeholder in your expression.</p>

<h3>Parenthesis ()</h3>

<ol>
<li>capture</li>
<li>grouping</li>
<li>TBD</li>
</ol>


<h3>Lookaround</h3>

<ul>
<li>lookahead left to right</li>
<li>lookbehind right to left</li>
</ul>


<p>lookaround do <strong>NOT</strong> consume text</p>

<h3>Lookaround</h3>

<p>* (?=Expr) - zero-width positive lookahead 符合後面為exp的文字 *
(?!Expr) - zero-width negative lookahead 符合後面沒接exp的文字 *
(?⇐Expr) - zero-width positive lookbehind 符合前為為exp的文字
*(?&lt;!Expr) - zero-width negative lookbehind 符合前面沒接exp字首的文字</p>

<h4>Positive Lookaround</h4>

<p>lookahead及
lookbehind所搜尋的是目前符合之前或之後的文字，並不包含目前符合本身。這些就如同”^”及”\b”特殊字元，本身並不會對應任何文字
(用來界定位置)，也因此稱做是zero-width assertions。</p>

<p>可以想像成SQL語法的<strong>LIKE</strong>或<strong>NOT
LIKE</strong>不過行為並儘相似，反正想到可用SQL
like來處理的問題，用Lookaround來處理一定可行。</p>

<p>```</p>

<pre><code>\b\w+(?=ing\b) (字尾為ing的字，比如說filling所符合的就是fill)
</code></pre>

<p>```</p>

<p>(?⇐exp)是一個”zero-width positive lookbehind
assertion”。它指的就是符合字首為exp的文字，但不包含exp本身。</p>

<p>```</p>

<pre><code>(?&lt;=\bre)\w+\b (字首為re的字，比如說repeated所符合的就是peated)
(?&lt;=\d)\d{3}\b (在字尾的三位數字，且之前接一位數字)
(?&lt;=\s)\w+(?=\s) (由空白字元分隔開的字母數字字串)
</code></pre>

<p>```</p>

<h4>Negative Lookaround</h4>

<p>但如果只是要驗証某字元不存在而不要對應這些字元進來呢?舉個例子來說，假設要搜尋一個字，它的字母裏有q但接下來的字母不是u，可以用下列的RE來做。</p>

<p><code>
\b\w*q[^u]\w*\b (一個字，其字母裏有q但接下來的字母不是u)
</code></p>

<p>這樣的RE會有一個問題，因為[^u]要對應一個字元，所以若q是字的最後一個字母，[^u]這樣的下法就會將空白字元對應下去，結果就有可能會符合二個字，比如說”Iraq
haha”這樣的文字。使用Negative Lookaround就能解決這樣的問題。</p>

<p><code>
\b\w*q(?!u)\w*\b (一個字，其字母裏有q但接下來的字母不是u)
</code></p>

<p>這是”zero-width negative lookahead assertion”。</p>

<p><code>
\d{3}(?!\d) (三個位元的數字，其後不接一個位元數字)
</code></p>

<p>同樣的，可以使用(?&lt;!exp)，”zero-width negative lookbehind
assertion”，來符合前面沒接exp字首的文字串。</p>

<p><code>
(?&lt;![a-z ])\w{7} (七個字母數字的字串，其前面沒接字母或空格)
(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;) (HTML標籤間的文字)
</code></p>

<p>這使用lookahead及lookbehind
assertion來取出HTML間的文字，不包括HTML標籤。</p>

<h3>MISC</h3>

<p>“03[-./]19[-./]76” 與 “03[.-/]19[.-/]76”不同，因為”-“會變rang的意思</p>

<p>找gary (gery) 可用”gr[ea]y”，”grey|gray”, and even
“gr(a|e)y”，但不能用”g[a|e]ry” 因為[a|e]會被當作 a or | or e</p>

<p>“gr(a|e)y”跟”gra|ey”是後者找的是gra或者是ey</p>

<p>.-^ 等在character裡面跟外面有不同的意義</p>

<p>可有可以的字用”?” 如 ”(July|Jul)” 可用 “July?”. “4th|4” 可用 4(th)?</p>

<p>”&lt;H[1-6]
*>”.如果*前面多一個空格，表示要空n格，如果沒有空格表示n個”]”</p>

<h3>\p{class}, \P{class}</h3>

<p>\p{class} - POSIX or unicode character class \P{class} - exculde POSIX
or unicode character class</p>

<p>if pattern only contains \p(or \P) without {class}, it means all(or
excluded all) class</p>

<p>Supported class codes</p>

<p>C</p>

<p>Other</p>

<p>Cc</p>

<p>Control</p>

<p>Cf</p>

<p>Format</p>

<p>Cn</p>

<p>Unassigned</p>

<p>Co</p>

<p>Private use</p>

<p>Cs</p>

<p>Surrogate</p>

<p>L</p>

<p>Letter</p>

<p>Ll</p>

<p>Lower case letter</p>

<p>Lm</p>

<p>Modifier letter</p>

<p>Lo</p>

<p>Other letter</p>

<p>Lt</p>

<p>Title case letter</p>

<p>Lu</p>

<p>Upper case letter</p>

<p>M</p>

<p>Mark</p>

<p>Mc</p>

<p>Spacing mark</p>

<p>Me</p>

<p>Enclosing mark</p>

<p>Mn</p>

<p>Non-spacing mark</p>

<p>N</p>

<p>Number</p>

<p>Nd</p>

<p>Decimal number</p>

<p>Nl</p>

<p>Letter number</p>

<p>No</p>

<p>Other number</p>

<p>P</p>

<p>Punctuation</p>

<p>Pc</p>

<p>Connector punctuation</p>

<p>Pd</p>

<p>Dash punctuation</p>

<p>Pe</p>

<p>Close punctuation</p>

<p>Pf</p>

<p>Final punctuation</p>

<p>Pi</p>

<p>Initial punctuation</p>

<p>Po</p>

<p>Other punctuation</p>

<p>Ps</p>

<p>Open punctuation</p>

<p>S</p>

<p>Symbol</p>

<p>Sc</p>

<p>Currency symbol</p>

<p>Sk</p>

<p>Modifier symbol</p>

<p>Sm</p>

<p>Mathematical symbol</p>

<p>So</p>

<p>Other symbol</p>

<p>Z</p>

<p>Separator</p>

<p>Zl</p>

<p>Line separator</p>

<p>Zp</p>

<p>Paragraph separator</p>

<p>Zs</p>

<p>Space separator</p>

<p>中日韓文可以用 \p{InCJKUnifiedIdeographs}</p>

<h3>TBD</h3>

<p>\i - Match of capture group i</p>

<p>\cC - control character</p>

<p>\G - previous match's end</p>

<p>\A - The beginning of the input</p>

<p>&amp;&amp;</p>

<p>(Expr) - mark Expr as capture group</p>

<p>(ismd-ismd) - turn flags on or off</p>

<p>(ismd-ismd:Expr) - turn flags on or off in Expr</p>

<p>(?:Expr) - non capture group (有performance問題時才會使用)</p>

<p>(?>Expr) - non capture atomic group</p>

<h2>Lazy quantifiers</h2>

<ol>
<li>??</li>
<li>+?</li>
<li>*?</li>
<li>{n}?</li>
<li>{n,}?</li>
<li>{n,m}?</li>
</ol>


<p>minimal matching, non-greedy, and un-greedy quantifiers.</p>

<h2>Possessive quantifiers</h2>

<ol>
<li>?+</li>
<li>++</li>
<li>*+</li>
<li>{n}+</li>
<li>{n,}+</li>
<li>{n,m}+</li>
</ol>


<p>Only Java supports those quantifiers now</p>

<h2>Regex Modes and Match Modes</h2>

<ol>
<li>/i - case-insensitive mode</li>
<li>/x - free-spacing and comments mode</li>
<li>/s - dot matches-all match mode (a.k.a., single-line mode)</li>
<li>/m - enhanced line-anchor match mode (a.k.a., multiline mode)</li>
<li>\Q…\E - literal-text regex mode</li>
</ol>


<h4>free-spacing and comments mode</h4>

<p>all spaces and anything after comment mark(#) will not interpreted.</p>

<p>if you need a space in pattern, using \s instead normal space
character.</p>

<h4>dot matches-all match mode (a.k.a., single-line mode)</h4>

<p>Usually, dot does not match a newline, but in this mode, dot does.</p>

<h4>\Q...\E - literal-text regex mode</h4>

<p>\Q, \E means start/end quoting.</p>

<p>the contents of which have all meta-characters ignored (expect the \E
itself).</p>

<h3>mode modifier (?modifier)</h3>

<p>(?modifier) could be (?i) or (?-i) to enabled/disabled case-sensitive
matching.</p>

<p>the modifier can be i, x ,m ,s mode of <a href="#regex_modes_and_match_modes" title="prog:regular_expression ↵">Regex Modes and Match
Modes</a></p>

<h2>Capture (\1) ,(?&lt;Name>...) or(?P&lt;Name>...)</h2>

<p>Here's a <strong>PHP</strong> regular expression for matching *nested* parentheses
(e.g. blocks of code):</p>

<p>```</p>

<pre><code>((?:[^()]++|\((?1)\))*)
</code></pre>

<p>```</p>

<p>The ?1 is a recursive reference to the regex marked by the outermost
parentheses. It is a feature of the PHP regex engine.</p>

<p>See Jeffrey Friedl's Mastering Regular Expressions, 3rd ed., p. 476,
“Recursive reference to a set of capturing parentheses”.</p>

<p>Another potentially useful regex technique is “named capture”:</p>

<p>```</p>

<pre><code>^(?P&lt;protocol&gt;https?)://(?P&lt;host&gt;[^/:]+)(?::(?P&lt;port&gt;\d+))?
</code></pre>

<p>```</p>

<p>Here you can use either \$matches[0], \$matches[1], \$matches[2] or
\$matches['protocol'], \$matches['host'], \$matches['port'].</p>

<p>This favour has difference implementation in difference language
(library), you should check manual of yours.</p>

<h2>Greediness (貪婪)</h2>

<p>regexp 的搜尋引擎有一個特性, 叫做 greediness – 能吃多少,
就盡量吃多少。克服貪婪可用以下方式</p>

<p><code>
[^...] "除了 ... 之外的任何一個字元"    
</code></p>

<p>也可利用<a href="#lazy_quantifiers" title="prog:regular_expression ↵">lazy greedy</a></p>

<p><code>
.??  或 .*?
</code></p>

<p>Lazy quantifiers是要用在<code>.*</code>後面，end of match的前面</p>

<p>```</p>

<pre><code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- #BeginLibraryItem "/library/page_header.lbi" --&gt;
content of /page_header.lbi
&lt;!-- #EndLibraryItem --&gt;
&lt;!-- #BeginLibraryItem "/library/page_center.lbi" --&gt;
content of /page_center.lbi
&lt;!-- #EndLibraryItem --&gt;
&lt;!-- #BeginLibraryItem "/library/page_footer.lbi" --&gt;
content of /page_footer.lbi
&lt;!-- #EndLibraryItem --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>```</p>

<p>在使用Single-Line (Dot All) mode下，
如果是以上面這個RE做條件，會從第8行選到第16行，所以這樣會有三個matchs</p>

<p>```</p>

<!--\s*#BeginLibraryItem.*#EndLibraryItem\s*-->


<p>```</p>

<p>```</p>

<!-- #BeginLibraryItem "/library/page_header.lbi" -->


<p>content of /page_header.lbi</p>

<!-- #EndLibraryItem -->


<!-- #BeginLibraryItem "/library/page_center.lbi" -->


<p>content of /page_center.lbi</p>

<!-- #EndLibraryItem -->


<!-- #BeginLibraryItem "/library/page_footer.lbi" -->


<p>content of /page_footer.lbi</p>

<!-- #EndLibraryItem -->


<p>```</p>

<p>但是如果利用lazy quantifiers <code>*?</code>
，就只會選到第一個#EndLibraryItem(第8行到第10行)，所以這樣會有三個matchs</p>

<p>```</p>

<!--\s*#BeginLibraryItem.*?#EndLibraryItem\s*-->


<p>```</p>

<p>```</p>

<!-- #BeginLibraryItem "/library/page_header.lbi" -->


<p>content of /page_header.lbi</p>

<!-- #EndLibraryItem -->


<p>```</p>

<p>```</p>

<!-- #BeginLibraryItem "/library/page_center.lbi" -->


<p>content of /page_center.lbi</p>

<!-- #EndLibraryItem -->


<p>```</p>

<p>```</p>

<!-- #BeginLibraryItem "/library/page_footer.lbi" -->


<p>content of /page_footer.lbi</p>

<!-- #EndLibraryItem -->


<p>```</p>

<h2>The Backtracking</h2>

<p><strong>TBD</strong></p>

<h2>參考資源</h2>

<ul>
<li>洪朝貴教授的<a href="http://fsoss.fcu.org.tw/2004/hong-chaogui/08-regexp.html" title="http://fsoss.fcu.org.tw/2004/hong-chaogui/08-regexp.html">一輩子受用的 Regular
Expressions</a></li>
<li><a href="http://tw2.php.net/manual/en/reference.pcre.pattern.modifiers.php" title="http://tw2.php.net/manual/en/reference.pcre.pattern.modifiers.php">PHP patter
modifierss</a></li>
<li><a href="http://tw2.php.net/manual/en/regexp.reference.php" title="http://tw2.php.net/manual/en/regexp.reference.php">PHP RE
details</a></li>
<li><a href="http://www.regular-expressions.info/completelines.html" title="http://www.regular-expressions.info/completelines.html">http://www.regular-expressions.info/completelines.html</a>

<ul>
<li>a lot of RE examples</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Smell]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/06/27/bad_smell/"/>
    <updated>2012-06-27T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/06/27/bad_smell</id>
    <content type="html"><![CDATA[<p>程式碼的臭味，來自Martin的Refactory一書，用來形容程式碼中邏輯上沒問題，但<strong>感覺</strong>起來怪怪的(或聞起來臭臭的)地方。你必須知道程式那裡在發臭，才有辦法去除臭。</p>

<p>這些文章很重要呀，一定要不斷的讀，甚至每隔幾周、幾月就重複的看一次，因為當你有實作經驗後，讀起來會有更深刻的體驗呀。</p>

<h2>Code Smell Within Classes</h2>

<ol>
<li>Comments</li>
<li>Long Method （過長函式）</li>
<li>Long Parameter List</li>
<li>Duplicated code （重複的程式碼）</li>
<li>Conditional Complexity</li>
<li>Combinitorial Explosion</li>
<li>Large Class</li>
<li>Type Embedded in Name</li>
<li>Uncommunicative Name</li>
<li>Inconsistent Names</li>
<li>Dead Code</li>
<li>Speculative Generality</li>
<li>Oddball Solution</li>
<li>Temporary Field</li>
</ol>


<h2>Code Smells Between Classes</h2>

<ol>
<li>Alternative Classes</li>
<li>Primitive Obsession</li>
<li>Data Class</li>
<li>Data Clumps</li>
<li>Refused Bequest</li>
<li>Inappropriate</li>
<li>Indecent Exposure</li>
<li>Feature Envy</li>
<li>Lazy Class</li>
<li>Message Chains</li>
<li>Middle Man</li>
<li>Divergent Change</li>
<li>Shotgun Surgery</li>
<li>Parallel Inheritance Hierarchies</li>
<li>Incomplete Library Class</li>
<li>Solution Sprawl</li>
</ol>


<h2>Code Smells Category</h2>

<p>以下內容均取自重構一書。</p>

<h3>Duplicated Code（重複的程式碼）</h3>

<p>臭味行列中首當其衝的就是Duplicated
Code。如果你在一個以上的地點看到相同的程式結構，那麼當可肯定：設法將它們合而為一，程式會變得更好。</p>

<p>最單純的Duplicated Code 就是「<strong>同一個class
內的兩個函式含有相同算式（expression）</strong>」。這時候你需要做的就是採用Extract
Method（110）提煉出重複的程式碼，然後讓這兩個地點都呼叫被提煉出來的那一段程式碼。</p>

<p>另一種常見情況就是「<strong>兩個互為兄弟（sibling）的subclasses
內含相同算式</strong>」。要避免這種情況，只需對兩個classes 都使用Extract
Method（110），然後再對被提煉出來的程式碼使用Pull Up
Method（332），將它推入superclass
內。如果程式碼之間只是類似，並非完全相同，那麼就得運用Extract
Method（110）將相似部分和差異部分割開，構成單獨一個函式。然後你可能發現或許可以運用Form
TemplateMethod（345）獲得一個Template Method
設計範式。如果有些函式以不同的演算法做相同的事，你可以擇定其中較清晰的一個，並使用Substitute
Algorithm（139）將其他函式的演算法替換掉。</p>

<p>如果兩個毫<strong>不相關的classes 內出現Duplicated
Code</strong>，你應該考慮對其中一個使用Extract
Class（149），將重複程式碼提煉到一個獨立class中，然後在另一個class內使用這個新class。但是，重複程式碼所在的函式也可能的確只應該屬於某個class，另一個class只能呼叫它，抑或這個函式可能屬於第三個class，而另個classes應該引用這第三個class。你必須決定這個函式放在哪兒最合適，並確保它被安置後就不會再在其他任何地方出現。</p>

<h3>Long Method（過長函式）</h3>

<p>擁有「短函式」（short
methods）的物件會活得比較好、比較長。不熟悉物件導向技術的人，常常覺得物件程式中只有無窮無盡的delegation（委託），根本沒有進行任何計算。和此類程式共同生活數年之後，你才會知道，這些小小函式有多大價值。「間接層」所能帶來的全部利益
— 解釋能力、共享能力、選擇能力 — 都是由小型函式支援的（請看p.61
的「間接層和重構」）。</p>

<p>很久以前程式員就已認識到：程式愈長愈難理解。早期的編程語言中，「子程式叫用動作」需要額外開銷，這使得人們不太樂意使用small
method。現代OO語言幾乎已經完全免除了行程（process）內的「函式叫用動作額外開銷」。不過程式碼閱讀者還是得多費力氣，因為他必須經常轉換上下文去看看子程式做了什麼。某些開發環境允許使用者同時看到兩個函式，這可以幫助你省去部分麻煩，但是讓small
method
容易理解的真正關鍵在於一個好名字。如果你能給函式起個好名字，讀者就可以通過名字了解函式的作用，根本不必去看其中寫了些什麼。</p>

<p>最終的效果是：你應該更積極進取地分解函式。我們遵循這樣一條原則：每<strong>當感覺需要以註釋來說明點什麼的時候</strong>，我們就把需要說明的東西寫進一個獨立函式中，並以其用途（而非實現手法）命名。我們可以對一組或甚至短短一行程式碼做這件事。哪怕替換後的函式呼叫動作比函式本身還長，只要函式名稱能夠解釋其用途，我們也該毫不猶豫地那麼做。關鍵不在於函式的長度，而在於函式「做什麼」和「如何做」之間的語意距離。</p>

<p>百分之九十九的場合裡，要把函式變小，只需使用Extract
Method（110）。找到函式中適合集在一起的部分，將它們提煉出來形成一個新函式。</p>

<p>如果<strong>函式內有大量的參數和暫時變數</strong>，它們會對你的函式提煉形成阻礙。如果你嘗試運用Extract
Method（110），最終就會把許多這些參數和暫時變數當做參數，傳遞給被提煉出來的新函式，導致可讀性幾乎沒有任何提昇。啊是的，你可以經常運用Replace
Temp with Query（120）來消除這些暫時元素。Introduce
ParameterObject（295）和Preserve Whole
Object（288）則可以將過長的參數列變得更簡潔一些。</p>

<p>如果你已經這麼做了，仍然有太多暫時變數和參數，那就應該使出我們的殺手翦：Replace
Method with Method Object（135）。</p>

<p>如何確定該提煉哪一段程式碼呢？一個很好的技巧是：尋找註釋。它們通常是指出「程式碼用途和實現手法間的語意距離」的信號。如果程式碼前方有一行註釋，就是在提醒你：可以將這段程式碼替換成一個函式，而且可以在註釋的基礎上給這個函式命名。就算只有一行程式碼，如果它需要以註釋來說明，那也值得將它提煉到獨立函式去。</p>

<p><strong>條件式和迴圈常常也是提煉的信號</strong>。你可以使用Decompose
Conditional（238）處理條件式。至於迴圈，你應該將迴圈和其內的程式碼提煉到一個獨立函式中。</p>

<h3>Large Class（過大類別）</h3>

<p>如果想利用單一class 做太多事情，其內往往就會<strong>出現太多instance
變數</strong>。一旦如此，Duplicated Code 也就接踵而至了。</p>

<p>你可以運用Extract Class（149）將數個變數一起提煉至新class
內。提煉時應該選擇class 內彼此相關的變數，將它們放在一起。例如
“depositAmount” 和”depositCurrency”
可能應該隸屬同一個class。通常如果class
內的<strong>數個變數有著相同的字首或字尾</strong>，這就意味有機會把它們提煉到某個組件內。如果這個組件適合作為一個subclass，你會發現Extract
Subclass（330）往往比較簡單。有時候class
並非在所有時刻都使用所有instance
變數。果真如此，你或許可以多次使用Extract Class（149）或Extract
Subclass（330）。</p>

<p>和「太多instance 變數」一樣，<strong>class
內如果有太多程式碼</strong>，也是「程式碼重複、混亂、死亡」的絕佳滋生地點。最簡單的解決方案（還記得嗎，我們喜歡簡單的解決方案）是把贅餘的東西消弭於class
內部。如果有五個「百行函式」，它們之中很多程式碼都相同，那麼或許你可以把它們變成五個「十行函式」和十個提煉出來的「雙行函式」。</p>

<p>和「擁有太多instance變數」一樣，一個class
如果擁有太多程式碼，往往也適合使用Extract Class（149）和Extract
Subclass（330）。這裡有個有用技巧：先確定客戶端如何使用它們，然後運用Extract
Interface（341）為每一種使用方式提煉出一個介面。這或許可以幫助你看清楚如何分解這個class。</p>

<p>如果你的Large Class 是個GUI
class，你可能需要把資料和行為移到一個獨立的領域物件（domain
object）去。你可能需要兩邊各保留一些重複資料，並令這些資料同步（sync.）。Duplicate
Observed
Data（189）告訴你該怎麼做。這種情況下，特別是如果你使用舊式Abstract
Windows Toolkit（AWT）組件，你可以採用這種方式去掉GUI class
並代以Swing組件。</p>

<h5>Long Parameter List（過長參數列）</h5>

<p>剛開始學習編程的時候，老師教我們：把函式所需的所有東西都以參數傳遞進去。這可以理解，因為除此之外就只能選擇全域資料，而全域資料是邪惡的東西。物件技術改變了這一情況，因為如果你手上沒有你所需要的東西，總可以叫另一個物件給你。因此，有了物件，你就不必把函式需要的所有東西都以參數傳遞給它了，你只需傳給它足夠的東西、讓函式能從中獲得自己需要的所有東西就行了。<strong>函式需要的東西多半可以在函式的宿主類別（host
class）中找到</strong>。物件導向程式中的函式，其參數列通常比在傳統程式中短得多。</p>

<p>這是好現象，因為太長的參數列難以理解，太多參數會造成前後不一致、不易使用，而且一旦你需要更多資料，就不得不修改它。如果將物件傳遞給函式，大多數修改都將沒有必要，因為你很可能只需（在函式內）增加一兩條請求（requests），就能得到更多資料。</p>

<p>如果「向既有物件發出一條請求」就可以取得原本位於參數列上的一份資料，那麼你應該啟動重構準則Replace
Parameter with Method（292）。上述的既有物件可能是函式所屬class
內的一個資料欄（field），也可能是另一個參數。你還可以運用Preserve Whole
Object（288）將來自同一物件的一堆資料收集起來，並以該物件替換它們。如果某些資料缺乏合理的物件歸屬，可使用Introduce
ParameterObject（295）為它們製造出一個「參數物件」。</p>

<p>此間存在一個重要的例外。有時候你明顯不希望造成「被叫用之物件」與「較大物件」間的某種依存關係。這時候將資料從物件中拆解出來單獨作為參數，也很合情合理。但是請注意其所引發的代價。如果參數列太長或變化太頻繁，你就需要重新考慮自己的依存結構（dependency
structure）了。</p>

<h3>Divergent Change（發散式變化）</h3>

<p>我們希望軟體能夠更容易被修改 —
畢竟軟體再怎麼說本來就該是「軟」的。一旦需要修改，我們希望能夠跳到系統的某一點，只在該處作修改。如果不能做到這點，你就嗅出兩種緊密相關的刺鼻味道中的一種了。</p>

<p>如果某個class經常因為不同的原因在不同的方向上發生變化，Divergent
Change就出現了。當你看著一個class
說：『呃，如果新加入一個資料庫，我必須修改這三個函式；如果新出現一種金融工具，我必須修改這四個函式』，那麼此時也許將這個物件分成兩個會更好，這麼一來每個物件就可以只因一種變化而需要修改。</p>

<p>當然，往往只有在加入新資料庫或新金融工具後，你才能發現這一點。針對某一<strong>外界變化的所有相應修改，都只應該發生在單一class
中</strong>，而這個新class
內的所有內容都應該反應該外界變化。為此，你應該找出因著某特定原因而造成的所有變化，然後運用Extract
Class（149）將它們提煉到另一個class 中。</p>

<h3>Shotgun Surgery（霰彈式修改）</h3>

<p><strong>Shotgun Surgery類似Divergent
Change，但恰恰相反</strong>。如果每遇到某種變化， 你都必須在許多不同的classes
內作出許多小修改以回應之，你所面臨的壞味道就 是Shotgun
Surgery。如果需要修改的程式碼散佈四處，你不但很難找到它們，
也很容易忘記某個重要的修改。</p>

<p>這種情況下你應該使用Move Method（142）和Move
Field（146）<strong>把所有需要修改的程式碼放進同一個class</strong>。如果眼下沒有合適的class
可以安置這些程式碼，就創造一個。通常你可以運用Inline
Class（154）把一系列相關行為放進同一個class。這可能會造成少量Divergent
Change，但你可以輕易處理它。</p>

<p>Divergent Change 是指「一個class 受多種變化的影響」，Shotgun Surgery
則是指「一種變化引發多個classes
相應修改」。這兩種情況下你都會希望整理程式碼，取得「外界變化」與「待改類別」呈現一對一關係的理想境地。</p>

<h3>Feature Envy（依戀情結）</h3>

<p>物件技術的全部要點在於：這是一種「將資料和加諸其上的操作行為包裝在一起」的技術。有一種經典氣味是：<strong>函式對某個class
的興趣高過對自己所處之host
class的興趣</strong>。這種孺慕之情最通常的焦點便是資料。無數次經驗裡，我們看到某個函式為了計算某值，從另一個物件那兒呼叫幾乎半打的取值函式（getting
method）。療法顯而易見：把這個函式移至另一個地點。你應該使用Move
Method（142）把它移到它該去的地方。有時候函式中只有一部分受這種依戀之苦，這時候你應該使用Extract
Method（110）把這一部分提煉到獨立函式中，再使用Move
Method（142）帶它去它的夢中家園。</p>

<p>當然，並非所有情況都這麼簡單。一個函式往往會用上數個classes
特性，那麼它究竟該被置於何處呢？我們的原則是：判斷哪個class
擁有最多「被此函式使用」的資料，然後就把這個函式和那些資料擺在一起兒。如果先以Extract
Method（110）將這個函式分解為數個較小函式並分別置放於不同地點，上述步驟也就比較容易完成了。</p>

<p>有數個複雜精巧的範式（patterns）破壞了這個規則。說起這個話題，「四巨頭」
[Gangof Four] 的Strategy和Visitor立刻跳入我的腦海，Kent Beck的Self
Delegation[Beck] 也在此列。使用這些範式是為了對抗壞味道Divergent
Change。最根本的原則是：將總是一起變化的東西放在一塊兒。「資料」和「引用這些資料」的行為總是一起變化的，但也有例外。如果例外出現，我們就搬移那些行為，保持「變化只在一地發生」。Strategy
和Visitor
使你得以輕鬆修改函式行為，因為它們將少量需被覆寫（overridden）的行為隔離開來
— 當然也付出了「多一層間接性」的代價。</p>

<h3>Data Clumps（資料泥團）</h3>

<p>資料項（data
items）就像小孩子：喜歡成群結隊地待在一塊兒。你常常可以在很多地方看到相同的三或四筆資料項：<strong>兩個classes
內的相同欄位（field）</strong>、<strong>許多函式署名式（signature）中的相同參數</strong>。這些「總是綁在一起出現的資料」真應該放進屬於它們自己的物件中。首先請找出這些資料的欄位形式（field）出現點，運用Extract
Class（149）將它們提煉到一個獨立物件中。然後將注意力轉移到函式署名式（signature）上頭，運用Introduce
Parameter Object（295）或Preserve
WholeObject（288）為它減肥。這麼做的直接好處是可以將很多參數列縮短，簡化函式呼叫動作。是的，不必因為Data
Clumps
只用上新物件的一部分欄位而在意，只要你以新物件取代兩個（或更多）欄位，你就值回票價了。</p>

<p>一個好的評斷辦法是：刪掉眾多資料中的一筆。其他資料有沒有因而失去意義？如果它們不再有意義，這就是個明確信號：你應該為它們產生一個新物件。</p>

<p>縮短欄位個數和參數個數，當然可以去除一些壞味道，但更重要的是：一旦擁有新物件，你就有機會讓程式散發出一種芳香。得到新物件後，你就可以著手尋找Feature
Envy，這可以幫你指出「可移至新class」中的種種程式行為。不必太久，所有classes都將在它們的小小社會中充分發揮自己的生產力。</p>

<h3>Primitive Obsession（基本型別偏執）</h3>

<p>大多數編程環境都有兩種資料：結構型別（record types）允許你將資料組織成有
意義的形式；基本型別（primitive
types）則是構成結構型別的積木塊。結構總是
會帶來一定的額外開銷。它們有點像資料庫中的表格，或是那些得不償失（只為
做一兩件事而創建，卻付出太大額外開銷）的東西。</p>

<p>物件的一個極具價值的東西是：它們模糊（甚至打破）了橫亙於基本資料和體積
較大的classes 之間的界限。你可以輕鬆編寫出一些與語言內建（基本）型別無異
的小型classes。例如Java就以基本型別表示數值，而以class 表示字串和日期 —
這 兩個型別在其他許多編程環境中都以基本型別表現。</p>

<p><strong>物件技術的新手通常不願意在小任務上運用小物件 — 像是結合數值和幣別的
money class、含一個起始值和一個結束值的range
class、電話號碼或郵遞區號（ZIP） 等等的特殊strings。</strong>你可以運用Replace
Data Value with Object（175）將原本單
獨存在的資料值替換為物件，從而走出傳統的洞窟，進入炙手可熱的物件世界。
如果欲替換之資料值是type code（型別代碼），而它並不影響行為，你可以運用
Replace Type Code with Class（218）將它換掉。如果你有相依於此type
code的條 件式，可運用Replace Type Code with Subclass（213）或Replace
Type Code with State/Strategy（227）加以處理。</p>

<p>如果你有一組應該總是被放在一起的欄位（fields），可運用Extract
Class（149）。 如果你在參數列中看到基本型資料，不妨試試Introduce
Parameter Object（295）。
如果你發現自己正從array中挑選資料，可運用Replace Array with
Object（186）。</p>

<h3>Switch Statements（switch 驚悚現身）</h3>

<p>物件導向程式的一個最明顯特徵就是：<strong>少用switch（或case）述句</strong>。從本質上說，switch
述句的問題在於重複（duplication）。你常會發現同樣的switch
述句散佈於不同地點。如果要為它添加一個新的case
子句，你必須找到所有switch述句並修改它們。物件導向中的多型（polymorphism）概念可為此帶來優雅的解決辦法。</p>

<p>大多數時候，一看到switch
述句你就應該考慮以「多型」來替換它。問題是多型該出現在哪兒？switch
述句常常根據type code（型別代碼）進行選擇，你要的是「與該type
code相關的函式或class」。所以你應該使用Extract Method（110）將switch
述句提煉到一個獨立函式中，再以Move
Method（142）將它搬移到需要多型性的那個class
裡頭。此時你必須決定是否使用Replace Type Code
withSubclasses（223）或Replace Type Code with
State/Strategy（227）。一旦這樣完成繼承結構之後，你就可以運用Replace
Conditional with Polymorphism（255）了。</p>

<p>如果你只是在單一函式中有些選擇事例，而你並不想改動它們，那麼「多型」就有點殺雞用牛刀了。這種情況下Replace
Parameter with Explicit
Methods（285）是個不錯的選擇。如果你的選擇條件之一是null，可以試試Introduce
Null Object（260）。</p>

<h3>Parallel Inheritance Hierarchies（平行繼承體系）</h3>

<p>Parallel Inheritance Hierarchies其實是Shotgun
Surgery的特殊情況。在這種情況下，每當你為某個class
增加一個subclass，必須也為另一個class
相應增加一個subclass。如果你發現某個繼承體系的class
名稱字首和另一個繼承體系的class名稱字首完全相同，便是聞到了這種壞味道。</p>

<p>消除這種重複性的一般策略是：讓一個繼承體系的實體（instances）指涉（參考、引用、refer
to）另一個繼承體系的實體（instances）。如果再接再厲運用Move
Method（142）和Move Field（146），就可以將指涉端（referring
class）的繼承體系消弭於無形。</p>

<h3>Lazy Class（冗員類別）</h3>

<p>你所創建的每一個class，都得有人去理解它、維護它，這些工作都是要花錢的。<strong>如果一個class的所得不值其身價，它就應該消失</strong>。專案中經常會出現這樣的情況：某個class
原本對得起自己的身價，但重構使它身形縮水，不再做那麼多工作；或開發者事前規劃了某些變化，並添加一個class
來應付這些變化，但變化實際上沒有發生。不論上述哪一種原因，請讓這個class
莊嚴赴義吧。如果某些subclass 沒有做滿足夠工作，試試Collapse
Hierarchy（344）。對於幾乎沒用的組件，你應該以Inline
Class（154）對付它們。</p>

<h3>Speculative Generality（夸夸其談未來性）</h3>

<p>這個令我們十分敏感的壞味道，命名者是Brian
Foote。當有人說『噢，我想我們總有一天需要做這事』並因而企圖以各式各樣的掛勾（hooks）和特殊情況來處理一些非必要的事情，這種壞味道就出現了。那麼做的結果往往造成系統更難理解和維護。如果所有裝置都會被用到，那就值得那麼做；<strong>如果用不到，就不值得。</strong>用不上的裝置只會擋你的路，所以，把它搬開吧。</p>

<p>如果你的<strong>某個abstract class 其實沒有太大作用，請運用Collapse
Hierarchy（344）</strong>。<strong>非必要之delegation（委託）可運用Inline
Class（154）除掉。</strong>如果<strong>函式的某些參數未被用上，可對它實施Remove
Parameter（277）</strong>。如果函式名稱帶有多餘的抽象意味，應該對它實施Rename
Method（273）讓它現實一些。</p>

<p>如果函式或class 的惟一使用者是test
cases（測試案例），這就飄出了壞味道Speculative
Generality。如果你發現這樣的函式或class，請把它們連同其test
cases都刪掉。但如果它們的用途是幫助test
cases檢測正當功能，當然必須刀下留人。</p>

<h3>Temporary Field（令人迷惑的暫時欄位）</h3>

<p>有時你會看到這樣的物件：<strong>其內某個instance
變數僅為某種特定情勢而設</strong>。這樣的程式碼讓人不易理解，因為你通常認為物件在所有時候都需要它的所有變數。在變數未被使用的情況下猜測當初其設置目的，會讓你發瘋。</p>

<p>請使用Extract
Class（149）給這個可憐的孤兒創造一個家，然後把所有和這個變數相關的程式碼都放進這個新家。也許你還可以使用Introduce
Null Object（260）在「變數不合法」的情況下創建一個Null
物件，從而避免寫出「條件式程式碼」。</p>

<p><strong>如果class
中有一個複雜演算法，需要好幾個變數，往往就可能導致壞味道Temporary Field
的出現</strong>。由於實作者不希望傳遞一長串參數（想想為什麼），所以他把這些參數都放進欄位（fields）中。但是這些欄位只在使用該演算法時才有效，其他情況下只會讓人迷惑。這時候你可以利用Extract
Class（149）把這些變數和其相關函式提煉到一個獨立class中。提煉後的新物件將是一個method
object[Beck]（譯註：其存在只是為了提供呼叫函式的途徑，class
本身並無抽象意味）。</p>

<h3>Message Chains（過度耦合的訊息鏈）</h3>

<p>如果你看到用戶向一個物件索求（request）另一個物件，然後再向後者索求另一個物件，然後再索求另一個物件…這就是Message
Chain。實際程式碼中你看到的可能是一長串getThis()或一長串暫時變數。採行這種方式，意味客戶將與搜尋過程中的航行結構（structure
of
navigation）緊密耦合。一旦物件間的關係發生任何變化，客戶端就不得不作出相應修改。</p>

<p>這時候你應該使用Hide Delegate（157）。你可以在Message Chain
的不同位置進行這種重構手法。理論上你可以重構Message Chain
上的任何一個物件，但這麼做往往會把所有中介物件（intermediate
object）都變成Middle Man。通常更好的選擇是：先觀察Message Chain
最終得到的物件是用來幹什麼的，看看能否以Extract
Method（110）把使用該物件的程式碼提煉到一個獨立函式中，再運用MoveMethod（142）把這個函式推入Message
Chain。如果這條鏈上的某個物件有多位客戶打算航行此航線的剩餘部分，就加一個函式來做這件事。</p>

<p>有些人把任何函式鏈（method chain。譯註：就是Message
Chain；物件導向領域中所謂「發送訊息」就是「喚起函式」）都視為壞東西，我們不這樣想。呵呵，我們的冷靜鎮定是出了名的，起碼在這件事情上是這樣。</p>

<h3>Middle Man（中間轉手人）</h3>

<p>物件的基本特徵之一就是封裝（encapsulation）—
對外部世界隱藏其內部細節。封裝往往伴隨delegation（委託）。比如說你問主管是否有時間參加一個會議，他就把這個訊息委託給他的記事簿，然後才能回答你。很好，你沒必要知道這位主管到底使用傳統記事簿或電子記事簿抑或秘書來記錄自己的約會。</p>

<p>但是人們<strong>可能過度運用delegation</strong>。你也許會看到<strong>某個class
介面有一半的函式都委託給其他class，這樣就是過度運用</strong>。這時你應該使用Remove
Middle
Man（160），直接和實責物件打交道。如果這樣「不幹實事」的函式只有少數幾個，可以運用InlineMethod（117）把它們
“inlining” 放進呼叫端。如果這些Middle Man
還有其他行為，你可以運用Replace Delegation with
Inheritance（355）把它變成實責物件的subclass，這樣你既可以擴展原物件的行為，又不必負擔那麼多的委託動作。</p>

<h3>Inappropriate Intimacy（狎暱關係）</h3>

<p>有時你會看到<strong>兩個classes 過於親密，花費太多時間去探究彼此的private
成分。</strong>如果這發生在兩個「人」之間，我們不必做衛道之士；但對於classes，我們希望它們嚴守清規。</p>

<p>就像古代戀人一樣，過份狎暱的classes 必須拆散。你可以採用Move
Method（142）和Move
Field（146）幫它們劃清界線，從而減少狎暱行徑。你也可以看看是否運用Change
Bidirectional Association to Unidirectional（200）讓其中一個class
對另一個斬斷情思。如果兩個classes 實在是情投意合，可以運用Extract
Class（149）把兩者共同點提煉到一個安全地點，讓它們坦蕩地使用這個新class。或者也可以嘗試運用Hide
Delegate（157）讓另一個class 來為它們傳遞相思情。</p>

<p>繼承（inheritance）往往造成過度親密，因為subclass 對superclass
的了解總是超過superclass
的主觀願望。如果你覺得該讓這個孩子獨自生活了，請運用ReplaceInheritance
with Delegation（352）讓它離開繼承體系。</p>

<h3>Alternative Classes with Different Interfaces （異曲同工的類別）</h3>

<p>如果<strong>兩個函式做同一件事，卻有著不同的署名式（signature）</strong>，請運用Rename
Method（273）根據它們的用途重新命名。但這往往不夠，請反復運用Move
Method（142）將某些行為移入classes，直到兩者的協定（protocols）一致為止。如果你必須重複而贅餘地移入程式碼才能完成這些，或許可運用Extract
Superclass（336）為自己贖點罪。</p>

<h3>Incomplete Library Class（不完美的程式庫類別）</h3>

<p>復用（reuse）常被視為物件的終極目的。我們認為這實在是過度估計了（我們只是使用而已）。但是無可否認，許多編程技術都建立在library
classes（程式庫類別）的基礎上，沒人敢說是不是我們都把排序演算法忘得一乾二淨了。</p>

<p>library classes
構築者沒有未卜先知的能力，我們不能因此責怪他們。畢竟我們自己也幾乎總是在系統快要構築完成的時候才能弄清楚它的設計，所以library
構築者的任務真的很艱鉅。麻煩的是library
的形式（form）往往不夠好，往往不可能讓我們修改其中的classes
使它完成我們希望完成的工作。這是否意味那些經過實踐檢驗的戰術如Move
Method（142）等等，如今都派不上用場了？</p>

<p>幸好我們有兩個專門應付這種情況的工具。如果你只想修改library classes
內的一兩個函式，可以運用Introduce Foreign
Method（162）；如果想要添加一大堆額外行為，就得運用Introduce Local
Extension（164）。</p>

<h3>Data Class（純稚的資料類別）</h3>

<p>所謂Data
Class是指：<strong>它們擁有一些欄位（fields），以及用於存取（讀寫）這些欄位的函式，除此之外一無長物</strong>。這樣的classes
只是一種「不會說話的資料容器」，它們幾乎一定被其他classes
過份細瑣地操控著。這些classes
早期可能擁有public欄位，果真如此你應該在別人注意到它們之前，立刻運用Encapsulate
Field（206）將它們封裝起來。如果這些classes 內含容器類的欄位（collection
fields），你應該檢查它們是不是得到了恰當的封裝；如果沒有，就運用Encapsulate
Collection（208）把它們封裝起來。對於那些不該被其他classes
修改的欄位，請運用Remove Setting Method（300）。</p>

<p>然後，找出這些「取值/設值」函式（getting and setting
methods）被其他classes 運用的地點。嘗試以Move
Method（142）把那些呼叫行為搬移到Data
Class來。如果無法搬移整個函式，就運用Extract
Method（110）產生一個可被搬移的函式。不久之後你就可以運用Hide
Method（303）把這些「取值/設值」函式隱藏起來了。</p>

<p>Data Class
就像小孩子。作為一個起點很好，但若要讓它們像「成年（成熟）」的物件那樣參與整個系統的工作，它們就必須承擔一定責任。</p>

<h3>Refused Bequest（被拒絕的遺贈）</h3>

<p>subclasses 應該繼承superclass
的函式和資料。但如果它們不想或不需要繼承，又該怎麼辦呢？它們得到所有禮物，卻只從中挑選幾樣來玩！</p>

<p>按傳統說法，這就意味繼承體系設計錯誤。你需要為這個subclass
新建一個兄弟（sibling class），再運用Push Down Method（328）和Push Down
Field（329）把所有用不到的函式下推給那兄弟。這樣一來superclass
就只持有所有subclasses
共享的東西。常常你會聽到這樣的建議：所有superclasses
都應該是抽象的（abstract）。</p>

<p>既然使用「傳統說法」這個略帶貶義的詞，你就可以猜到，我們不建議你這麼做，起碼不建議你每次都這麼做。我們經常利用subclassing
手法來復用一些行為，並發現這可以很好地應用於日常工作。這也是一種壞味道，我們不否認，但氣味通常並不強烈。所以我們說：如果Refused
Bequest
引起困惑和問題，請遵循傳統忠告。但不必認為你每次都得那麼做。十有八九這種壞味道很淡，不值得理睬。</p>

<p>如果subclass 復用了superclass 的行為（實作），卻又不願意支援superclass
的介面，Refused Bequest 的壞味道就會變得濃烈。拒絕繼承superclass
的實作，這一點我們不介意；但如果拒絕繼承superclass
的介面，我們不以為然。不過即使你不願意繼承介面，也不要胡亂修改繼承體系，你應該運用Replace
Inheritance with Delegation（352）來達到目的。</p>

<h3>Comments（過多的註釋）</h3>

<p>別擔心，我們並不是說你不該寫註釋。從嗅覺上說，Comments不是一種壞味道；事實上它們還是一種香味呢。我們之所以要在這裡提到Comments，因為人們常把它當作除臭劑來使用。常常會有這樣的情況：你看到<strong>一段程式碼有著長長的註釋</strong>，然後發現，這些註釋之所以存在乃是因為程式碼很糟糕。這種情況的發生次數之多，實在令人吃驚。</p>

<p>Comments
可以帶我們找到本章先前提到的各種壞味道。找到壞味道後，我們首先應該以各種重構手法把壞味道去除。完成之後我們常常會發現：<strong>註釋已經變得多餘了，因為程式碼已經清楚說明了一切</strong>。</p>

<p>如果你需要註釋來解釋一塊程式碼做了什麼，試試Extract
Method（110）；如果method已經提煉出來，但還是需要註釋來解釋其行為，試試Rename
Method（273）；如果你需要註釋說明某些系統的需求規格，試試Introduce
Assertion（267）。</p>

<p>如果你不知道該做什麼，這才是註釋的良好運用時機。除了用來記述將來的打算之外，註釋還可以用來標記你並無十足把握的區域。你可以在註釋裡寫下自己「為什麼做某某事」。這類資訊可以幫助將來的修改者，尤其是那些健忘的傢伙。</p>

<p>當你感覺需要撰寫註釋，請先嘗試重構，試著讓所有註釋都變得多餘。</p>

<h2>臭味 V.S 除臭劑</h2>

<pre><code>  壞味道（smell）                                 常用的重構手法（Common Refactoring）

  Alternative Classes with Different Interfaces   Rename Method (273), Move Method (142)
  Comments                                        Extract Method (110), Introduce Assertion (267)
  Data Class                                      Move Method (142), Encapsulate Field (206),Encapsulate Collection (208)
  Data Clumps                                     Extract Class (149), Introduce Parameter Object (295),Preserve Whole Object (288)
  Divergent Change                                Extract Class (149)
  Duplicated Code                                 Extract Method (110), Extract Class (149),Pull Up Method (322), Form Template Method (345)
  Feature Envy                                    Move Method (142), Move Field (146), Extract Method (110)
  Inappropriate Intimacy                          Move Method (142), Move Field (146), Change Bidirectional Association to Unidirectional (200), Replace Inheritance with Delegation (352), Hide Delegate (157)
  Incomplete Library Class                        Introduce Foreign Method (162),Introduce Local Extension (164)
  Large Class                                     Extract Class (149), Extract Subclass (330), Extract Interface (341), Replace Data Value with Object (175)
  Lazy Class                                      Inline Class (154), Collapse Hierarchy (344)
  Long Method                                     Extract Method (110), Replace Temp With Query (120),Replace Method with Method Object (135),Decompose Conditional (238)
  Long Parameter List                             Replace Parameter with Method (292), Introduce Parameter Object (295), Preserve Whole Object (288)
  Message Chains                                  Hide Delegate (157)
  Middle Man                                      Remove Middle Man (160), Inline Method (117),Replace Delegation with Inheritance (355)
  Parallel Inheritance Hierarchies                Move Method (142), Move Field (146)
  Primitive Obsession                             Replace Data Value with Object (175), Extract Class (149),Introduce Parameter Object (295), Replace Array with Object (186), Replace Type Code with Class (218),Replace Type Code with Subclasses (223),Replace Type Code with State/Strategy (227)
  Refused Bequest                                 Replace Inheritance with Delegation (352)
  Shotgun Surgery                                 Replace Inheritance with Delegation (352)
  Speculative Generality                          Collapse Hierarchy (344), Inline Class (154),Remove Parameter (277), Rename Method (273)
  Switch Statements                               Replace Conditional with Polymorphism (255), Replace Type Code with Subclasses (223), Replace Type Code with State/Strategy (227), Replace Parameter with Explicit Methods (285), Introduce Null Object (260)
  Temporary Field                                 Extract Class (149), Introduce Null Object (260)
</code></pre>

<h2>Resource</h2>

<ul>
<li><a href="http://industriallogic.com/papers/smellstorefactorings.pdf" title="http://industriallogic.com/papers/smellstorefactorings.pdf">code
smell</a></li>
<li><a href="http://jjhou.csdn.net/jjtbooks-refactoring.htm" title="http://jjhou.csdn.net/jjtbooks-refactoring.htm">Refactoring-Improving the Design of Existing
Code(重構)</a></li>
<li><a href="http://www.refactoring.com/catalog/index.html" title="http://www.refactoring.com/catalog/index.html">Refactoring
Category</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XPath]]></title>
    <link href="http://blog.kent-chiu.com/blog/2011/10/17/xpath/"/>
    <updated>2011-10-17T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2011/10/17/xpath</id>
    <content type="html"><![CDATA[<p>  Expression      Description</p>

<hr />

<p>  nodename        Selects all child nodes of the named node
  /               Selects from the root node
  //              Selects nodes in the document from the current node that match the selection no matter where they are
  .               Selects the current node
  ..              Selects the parent of the current node
  @               Selects attributes
  @*             Selects all attributes
  @c              attributes c
  node()          all nodes
  text()          text node
  a | b           a or b element
  a[expression]   a node when expression is true
  *              all elements
  a/b             selects b child of parent a
  a//b            selects b child when has a node upon it</p>

<hr />

<p>  Expression        Description</p>

<hr />

<p>  bookstore         Selects all the child nodes of the bookstore element</p>

<p>  /bookstore        Selects the root element bookstore\</p>

<pre><code>                 Note: If the path starts with a slash ( / ) it always represents an absolute path to an element!\
                 bookstore/book Selects all book elements that are children of bookstore
</code></pre>

<p>  //book            Selects all book elements no matter where they are in the document</p>

<p>  bookstore//book   Selects all book elements that are descendant of the bookstore element, no matter where they are under the bookstore element</p>

<p>  //@lang           Selects all attributes that are named lang</p>

<hr />

<h2>Operators</h2>

<p>  operator   description</p>

<hr />

<p>  |          Computes two node-sets
  +          Addition
  -          Subtraction
  *         Multiplication
  div        Division
  =          Equal
  !=         Not equal
  &lt;         Less than
  ⇐          Less than or equal to
  >         Greater than
  >=        Greater than or equal to
  or         or
  and        and
  mod        Modulus</p>

<h2>Resources</h2>

<ul>
<li><a href="http://www.w3schools.com/XPath/default.asp" title="http://www.w3schools.com/XPath/default.asp">xpath tutorial in w3c
schools</a></li>
</ul>


<h2>XPath Function</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[由上而下 vs 由下至上 的設計]]></title>
    <link href="http://blog.kent-chiu.com/blog/2011/10/17/top-down_v.s_bottom-up_design/"/>
    <updated>2011-10-17T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2011/10/17/top-down_v.s_bottom-up_design</id>
    <content type="html"><![CDATA[<p>在開始IDCView專案時，因為底層的模型相對複雜，在用Prototype <a href="http://www.balsamiq.com/products/mockups" title="http://www.balsamiq.com/products/mockups">Balsamiq
Mockups</a>^<a href="#fn__1">1)</a>^軟體繪製完成後，就用<a href="http://wiki.kent-chiu.com/doku.php?id=prog:top-down_v.s_bottom-up_design" title="prog:top-down_v.s_bottom-up_design">Domain
Driven
Design</a>的方式對底層的電力設備模型進行分析。模型塑模(modeling)到可開發程度後，就<strong>很真覺</strong>的寫了一些API去操作這些模型。結果就很<strong>順理成章</strong>的採用了Bottom-Up(由下至上)的設計開發方式。</p>

<p>整個架構，為了搭配語言及現有的API^<a href="#fn__2">2)</a>^特性，並沒有使用Rich
Domain而是採POJO的設計方式，採用了4個主要的layers為<code>presentation → application → service → domain object(POJO)</code>。</p>

<p>在一段開發時間後，寫了好一堆個人認為應該相當好用的APIs(service
layer)，就打算套到servlet裡，就在這個時侯才發現，設計出來的API，在他的client
(servlet)裡，並沒有那麼好用，總是需要額外的加工，才有辦法使用這些services或者是要好幾個api
called才能完成一件事。在發現這個問題後，就改用Top-down的方式開發，事情就順利多了，而且每個設計出來的service也都剛好符合servlet的使用，並不需要太多的加工就可以有合適的service可以用，service的methods數量也大幅的減少。</p>

<p>所以，個人認為Top-down的方式比較能達到<a href="http://wiki.kent-chiu.com/doku.php?id=prog:k.i.s.s" title="prog:k.i.s.s">K.I.S.S</a>的效果，尤其是對採用<a href="http://wiki.kent-chiu.com/doku.php?id=prog:tdd" title="prog:tdd">TDD</a>開發方式的人來說，因為TDD有一個準備動作，就是列出所有待測的TODOs，然後挑一個最簡單的來實作。這樣，其實很容易造成太多用不到的API，因為，基本上這樣的設計方式，是在在設計一個完整的元件，而不是<strong>剛好夠用</strong>元件。</p>

<p>整個開發流程是：</p>

<ol>
<li>確定網頁大概會傳入/傳出那些參數</li>
<li>撰寫 servlet test cases</li>
<li>撰寫 servlet</li>
<li>決定需要的service API</li>
<li>Mock service API</li>
<li>servlet完成</li>
<li>撰寫 service test cases</li>
<li>實作 service interface</li>
<li>用DBUnit模擬db</li>
</ol>


<p>在<em>確定網頁大概會傳入/傳出那些參數</em>後，即可決定servlet的大致動作，然後就可以<em>撰寫
servlet test
cases</em>來<strong>mock</strong>參數的傳入及<strong>verify</strong>參數的傳出，然後，即可進行<em>撰寫
servlet</em>來滿足servlet test cases，但是servlet需要service來完成 business
logic，而且，因為是直接servlet裡決定service的api<strong>長相</strong>(此時要假設有一個完美的service
api可以解決掉你的問題，並為這個api取一個直覺的名字)，所以，通常比較能設計出清楚而直接的service
api，接著，用mock的方式來mock service
api的動作，一方面可以比較快速的得到一個可以動的api，另一方面可以為設計做一個較乾淨的切割。接再讓Servlet的test
cases通過測試了。</p>

<p>再來就是service
API的實作，如果實作部份跟資料庫有關，就用DBUnit來確定service會正常動作，而不是用mockup的方式了。</p>

<p>改採Top-down最大的收獲是最終的設計比較符合<a href="http://wiki.kent-chiu.com/doku.php?id=prog:k.i.s.s" title="prog:k.i.s.s">K.I.S.S</a>的原則，但元件的很多<del>不必要</del>很好用功能的功能就不見了，所以，以後，萬一、如果、可能、或許要用到時，就得再加進去了。</p>

<p>&lt;node
warn>本文並是不在說Bottom-Up的設計不可取，而是要看需求，之前在開發Framework或Component
base的程式時，反而是Bottom-Up比較適合，因為，你永遠不知道，別人會怎麼來使用你的API&lt;/note></p>

<h1>Service Design</h1>

<p>在前幾個模組的設計，對於service
layer是採用一個模組(或servlet)只有一個service的設計方式，而且每個service只有一個interface(class
file)，也只有一個相對的實作，一開始的動機為了讓模組間切割的更乾淨，但這樣做，會造成了不少重覆實作的Bad
Smell，所以，最後為了去掉這些重覆，就還是改回多個services的架構.</p>

<p>改成一個模組多個services的架構後，service的interface不但簡化了許多，而且更符合<a href="http://wiki.kent-chiu.com/doku.php?id=prog:ood_5_principles#srp" title="prog:ood_5_principles">SRP</a>，也消除了更多的重覆，更讓整體架構往更佳的方向前進，所以，去除重覆是很多最佳實踐的基石。</p>

<p>^<a href="#fnt__1">1)</a>^ 再次感謝佛心的Balsamiq送我一個lincense</p>

<p>^<a href="#fnt__2">2)</a>^ JPA</p>
]]></content>
  </entry>
  
</feed>
