<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: guice | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/guice/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2014-06-27T00:01:08+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Google Guice 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/29/google_guice_101/"/>
    <updated>2012-03-29T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/29/google_guice_101</id>
    <content type="html"><![CDATA[<p>All content is base on guice 2.x.</p>

<h2>Base Concept</h2>

<ul>
<li>Module - 用來決定物件依賴關係的元件</li>
<li><p>Binders - 用來將物件綁定在一起的元件</p>

<ol>
<li>Linked Binding - 將類別與實作類別綁定在一起的元件</li>
<li>Binding Annotations - 更細緻的描述要binding那個實作</li>
<li>Instance Bindings - Binding instance到特定的類別</li>
<li>@Provides Methods - Factory
Method，用來提供特定型別的instance，只要有需有這個instance時，就會自動被binding</li>
<li>Provider Bindings - 另一種型式的Factory Method</li>
<li>Untargetted Bindings -
提供跟binder但不指定與誰進行binding，通常與
@ImplementedBy或@ProvidedBy搭配使用</li>
<li>Built-in Bindings - 內建的bindings

<ol>
<li>java.util.logging.Logger 如以binding logger</li>
<li>Injector 可以把Injector inject到其它物件</li>
<li>Providers 可以把 Provider inject到其它物件</li>
<li>TypeLiterals 處理泛型用的</li>
<li>The Stage</li>
<li>MembersInjectors
可以對某個物件進行inject，這個很常用(由其是在測試時，用來inject
mock object)</li>
</ol>
</li>
</ol>
</li>
<li><p>TBD</p>

<ol>
<li>AssistedInject</li>
<li>PrivateModules</li>
</ol>
</li>
</ul>


<h2>Hello Guice</h2>

<p>```</p>

<pre><code>package com.kent;
 
public interface Service {
    public String sayHelloTo(String name);
}
</code></pre>

<p>```</p>

<p>```</p>

<pre><code>package com.kent;
 
public class ServiceImpl implements Service {
    public String sayHelloTo(String id) {
        return "Hello! " + id;
    }
}
</code></pre>

<p>```</p>

<p>```</p>

<pre><code>package com.kent;
 
import com.google.inject.Inject;
 
public class Client {
 
    @Inject
    private Service                service;
 
    public String doThing(String id) {
        return service.sayHelloTo(id);
    }
}
</code></pre>

<p>```</p>

<p>```</p>

<pre><code>package com.kent;
 
import static org.junit.Assert.assertEquals;
 
import org.junit.Before;
import org.junit.Test;
 
import com.google.inject.AbstractModule;
import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Module;
 
public class TestClient {
 
    @Inject
    private Service service;
 
    @Before
    public void setUp() throws Exception {
 
        Module module = new AbstractModule() {
            @Override
            protected void configure() {
                bind(Service.class).to(ServiceImpl.class);
            }
        };
        Injector injector = Guice.createInjector(module);
        injector.injectMembers(this);
    }
 
    @Test
    public void testInection() throws Exception {
        assertEquals("Hello! Kent", service.sayHelloTo("Kent"));
    }
 
}
</code></pre>

<p>```</p>

<p>Using <code>injector.injectMembers(this);</code> to inject code back to test
case,so that we can get the <strong>setted</strong> service for work.</p>

<h2>Hello Guice on web</h2>

<p>To enable Guice on web application, we need got the guice-serlet.jar and
add some settings in web.xml</p>

<p>Guice是透過GuiceFilter取得threadlocal裡request，response等相關的content，所以必須要掛上這個filter。</p>

<p>```</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt;
    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;com.google.inject.servlet.GuiceFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>

<p>```</p>

<p>Guice利用GuiceServletContextListener，在server啟動時，把Injector放到ServletContext裡，這樣，其他的servlet就可以從ServletCotext取得Injector。</p>

<p>```</p>

<pre><code>package com.kent;
 
import javax.servlet.ServletContextEvent;
 
import com.google.inject.Binder;
import com.google.inject.Guice;
import com.google.inject.Injector;
import com.google.inject.Module;
import com.google.inject.servlet.GuiceServletContextListener;
 
public class GuiceServletConfig extends GuiceServletContextListener {
 
    public static final String KEY = Injector.class.getName();
 
    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        servletContextEvent.getServletContext().removeAttribute(KEY);
    }
 
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        servletContextEvent.getServletContext().setAttribute(KEY, getInjector());
    }
 
    @Override
    protected Injector getInjector() {
        return Guice.createInjector(new Module() {
            public void configure(Binder binder) {
                binder.bind(Service.class).to(ServiceImpl.class);
            }
        });
    }
}
</code></pre>

<p>```</p>

<p>在上面的動作中，Injector被放入ServletContext，在servlet的init()，可以取得Injector，然後用<code>injector.injectMembers(this)</code>對servlet進行injection</p>

<p>```</p>

<pre><code>package com.kent;
 
import java.io.IOException;
 
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
 
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Singleton;
 
@Singleton
public class HelloServlet extends HttpServlet {
 
    private static final long serialVersionUID = 1L;
    @Inject
    private Service           service;
 
    @Override
    public void init(ServletConfig config) throws ServletException {
 
        ServletContext context = config.getServletContext();
        Injector injector = (Injector) context.getAttribute(Injector.class.getName());
        if (injector == null) {
            throw new ServletException("Guice Injector not found");
        }
        injector.injectMembers(this);
    }
 
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.getOutputStream().print(service.sayHelloTo("web"));
    }
 
}
</code></pre>

<p>```</p>

<p>```</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt;
    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;com.google.inject.servlet.GuiceFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;com.kent.GuiceServletConfig&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.kent.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>

<p>```</p>

<h2>Scopes</h2>

<p>Guice預設的scope是每次產生instnace，如果要變這個預設的行為，是透過scope，預設的scope有</p>

<ol>
<li>@Singleton - 讓物件變成Singleton，可以讓它宣告成Singleton
(必須是threadsafe)</li>
<li>@SessionScoped - 跟http session一樣長的scope
(必須是threadsafe，必須正確安裝ServletModule)</li>
<li>@RequestScoped - 每次的 http request才會新物件的scope
(<strong>不用</strong>是threadsafe，必須正確安裝ServletModule)</li>
</ol>


<p>如果class沒辦法用Annotation宣告(如比說該class來自其他lib)，那可以在binding時，再指定scope，像這樣</p>

<p>```</p>

<pre><code>bind(TransactionLog.class).to(InMemoryTransactionLog.class).in(Singleton.class);
bind(UserPreferences.class).toProvider(UserPreferencesProvider.class).in(ServletScopes.REQUEST);
// singleton可以是eager或lazy，eager或lazy是指contruct的方式
bind(TransactionLog.class).to(InMemoryTransactionLog.class).asEagerSingleton();
</code></pre>

<p>```</p>

<h4>Singleton Scope</h4>

<p>Singleton可以省下很多物件建立及GC的資源，如果物件有以下特性，就可以考慮是否要宣告成Singleton，(，如果物件是stateless，建立新物件的速度，會比從singleton取快得多)</p>

<ul>
<li>stateful objects, such as configuration or counters</li>
<li>objects that are expensive to construct or lookup</li>
<li>objects that tie up resources, such as a database connection pool.</li>
</ul>


<p>雖然Singleton對java來說，一直常被列為<a href="http://en.wikipedia.org/wiki/Singleton_pattern" title="http://en.wikipedia.org/wiki/Singleton_pattern">anti-pattern</a>(主要是因為Singleton的物件沒辦法被overwrite，失去了OO的特性)，
尤其是採DI的開發方式而言，不過guice可以保留Singleton的優點，但卻沒有Singleton的缺點，所以可以放心使用</p>

<p>If the object truly is stateless, it's faster for Guice to create a new
instance than it is to retrieve a singleton. If Guice creates a new
instance every time, it can bypass the scoping layer entirely, not to
mention the logic inside the singleton scope.</p>

<h2>Injection</h2>

<h4>Automatic Injection</h4>

<p>Guice automatically injects all of the following:</p>

<ul>
<li>instances passed to toInstance() in a bind statement</li>
<li>provider instances passed to toProvider() in a bind statement</li>
</ul>


<p>The objects will be injected while the injector itself is being created.
If they're needed to satisfy other startup injections, Guice will inject
them before they're used.</p>

<h2>Extensions</h2>

<h3>Multibindings</h3>

<p>Multibindings是可以用來設計plugin的架構，主要的功能是把一個interface
binding到多個實作上面，而且不需要recompile，可以透過config檔來加入新完成的plugins.</p>

<h2>Resource</h2>

<ul>
<li><a href="http://code.google.com/p/google-guice/" title="http://code.google.com/p/google-guice/">官網</a></li>
<li><a href="http://99soft.github.com/rocoto/configuration.html" title="http://99soft.github.com/rocoto/configuration.html">rocoto</a>

<ul>
<li>guice讀properties，xml的lib</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
