<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: scala | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2014-05-23T10:21:45+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SBT 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/07/24/sbt_101/"/>
    <updated>2012-07-24T14:27:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/07/24/sbt_101</id>
    <content type="html"><![CDATA[<blockquote><p>dependency時，兩個%%表示cross-build，會把sbt的版號給納入dependency的資訊</p></blockquote>

<h5>Local Maven Repository</h5>

<p>如果要使用local或自己架設的maven
repository，可以透過<code>resolvers += “name” at “maven repositor url”</code></p>

<p><code>
resolvers += "Local Maven Repository" at "file:///C:/Users/Kent/.m2/repository"
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/07/02/scala_101/"/>
    <updated>2012-07-02T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/07/02/scala_101</id>
    <content type="html"><![CDATA[<p>Scala IDE</p>

<ol>
<li>eclipse 3.7 (indigo)</li>
<li>scala IDE plugin 2.9</li>
<li>jdk 1.7.03</li>
</ol>


<p>一切換到scala的環境，IDE就凍住了，用<a href="http://wiki.kent-chiu.com/doku.php?id=java:jvm_profile" title="java:jvm_profile">VirtualVM</a>觀查的結果是執行scala的vm(不是ide本身的vm)的Permanent
Generation
Memory爆了，把它開到256M(-XX:MaxPermSize=256m)就不會一切到scala
perspective，IDE就掛掉。</p>

<p>```</p>

<h1>utf8 (do not remove)</h1>

<p>-startup
../../Common/plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar
--launcher.library
../../Common/plugins/org.eclipse.equinox.launcher.i18n.win32.win32.x86_64_4.2.0.v201201111650
-showsplash
C:\Genuitec\Common\plugins\org.eclipse.platform_3.7.2.v201202080800\splash.bmp
--launcher.XXMaxPermSize
256m
--launcher.defaultAction
openFile
-install
C:\Genuitec\Profiles\scala
-configuration
C:\Genuitec\Profiles\scala\configuration
-vmargs
-Xms256m
-Xmx1024m
-XX:MaxPermSize=256m
```</p>

<ul>
<li>scala是可自我成長的語言</li>
<li>scala混合了oo跟function lang</li>
<li>java中的static method可以考慮用function的方式實現，statistic
method可視為一種退化的function lang?</li>
<li>scala是純oo
lang，所有的東西都是物件，所有的操作(含運算子)都是method，所以，可以做運算子的override</li>
<li><p>scala可以與java無縫的整合，事實上，scala很多型號都是來自java。scala
call java lib會很容易，但java call
scala會有比較多的限制，因為scala的物件模型及語意比java豐富，java沒辦法一一對應。</p></li>
<li><p>scala有兩種變數</p></li>
<li><p>expression後面的分號(;)可有可無</p></li>
<li>val : 像java的final變數，一旦宣告後，就不能改變
(如果重新指派，會出reassignment的error)</li>
<li><p>var : 像java的non final變數，可以重新指派值</p></li>
<li><p>scala的array跟java一樣是0-base但是，是透過()存取，而不是[]</p></li>
</ul>


<h5>method</h5>

<p><code>
def mymethod(x: Int, y: Int) : Int = {
  x + y
}
</code></p>

<p><code>
def mymethod(x: Int, y: Int) = x + y
</code></p>

<p>所有的運算子在scala都是method，所以<code>1 + 2</code>是這樣的method call</p>

<p><code>
(1).+(2)
</code></p>

<p><code>1</code>是物件,<code>+</code>是method name，<code>1</code>物件透過<code>.</code>來呼叫<code>+</code>method並傳入參數值<code>2</code></p>

<p>以這樣的角度來看Array，Array就很直覺了，Array在Scala也只是一般的物件，而不是像java一樣，而不是像java一樣，是屬於語法等級的物件</p>

<h5>foreach</h5>

<p>for (arg ← args) println(arg)</p>

<h3>function</h3>

<h4>function literal</h4>

<p>單行</p>

<p><code>
(x: Int, y: Int) =&gt; x + y
</code></p>

<p>多行時可以用大括號將 functio body括起來</p>

<p>```
(x: Int, y: Int) => {</p>

<pre><code>val z = x + 1
z + y
</code></pre>

<p>}
```</p>

<p>這邊用function literal來達到foreach的功能，function literal有三種用法</p>

<p>第一種是最囉嗦,array的item要給型別而且給了型別，外面還要配一對括號</p>

<p><code>
myarray.foreach((item: String) =&gt; println(item))
</code></p>

<p>這個是比較正常的用法</p>

<p><code>
myarray.foreach(item =&gt; println(item))
</code></p>

<p>超精簡的用法，但只適用於只有一個參數的狀況</p>

<p><code>
myarray.foreach(println)
</code></p>

<h5>function return type</h5>

<p>為什麼sum function可以不用指定return type，而factorial必須指定return
type為Int?</p>

<p><code>
  def sum(a:Int,b:Int) = a+b
  def factorial(n:Int):Int = if (n==0) 1 else n * factorial(n-1)
</code></p>

<p>因為在sum function中complier可以推斷(infer)出a +
b的回傳值是Int型別，但在factorial中，回傳值可能是 1
或者是<code>n * factorial(n-1)</code>，
而<code>n * factorial(n-1)</code>是未知型別，所以，我們必須指定return
type，給complier一個提示。</p>

<p>有些語言的compiler可以由factorial function的第一個回傳值為1來推斷return
type為Int，但scala的complier不行</p>

<h5>operator notation</h5>

<ol>
<li>infix 1 + 2</li>
<li>prefix +1,-1, !foo, \~bar (只有+,-,!,\~可以為prefix
operator,定為方式為<code>unary_+</code>,<code>unary_-</code>,<code>unary_!</code>,<code>unary_~</code>,)</li>
<li>postfix 1.toLong</li>
</ol>


<h4>functionN</h4>

<p><code>``
package scala
 
 
trait Function2[@specialized(scala.Int, scala.Long, scala.Double) -T1, @specialized(scala.Int, scala.Long, scala.Double) -T2, @specialized(scala.Unit, scala.Boolean, scala.Int, scala.Float, scala.Long, scala.Double) +R] extends AnyRef { self =&gt;
  /** Apply the body of this function to the arguments.
   *  @return   the result of function application.
   */
  def apply(v1: T1, v2: T2): R
 
  /** Creates a curried version of this function.
   *
   *  @return   a function</code>f<code>such that</code>f(x1)(x2) == apply(x1, x2)`
   */
  def curried: T1 => T2 => R = {</p>

<pre><code>(x1: T1) =&gt; (x2: T2) =&gt; apply(x1, x2)
</code></pre>

<p>  }
  @deprecated("Use 'curried' instead", "2.8.0")
  def curry = curried
 
  /<em>* Creates a tupled version of this function: instead of 2 arguments,
   *  it accepts a single [[scala.Tuple2]] argument.
   *
   *  @return   a function <code>f</code> such that <code>f((x1, x2)) == f(Tuple2(x1, x2)) == apply(x1, x2)</code>
   </em>/
  def tupled: Tuple2[T1, T2] => R = {</p>

<pre><code>case Tuple2(x1, x2) =&gt; apply(x1, x2)
</code></pre>

<p>  }
  override def toString() = "<function2>"
}
 
}
```</p>

<p>scala中的每個function，都是實作像上面的functionN(N從0\~22)的trait，以<code>(x: Int, y: Int) ⇒ x + y</code>來說，就是上例中的Function2[-T1,
-T2, +R]， 因為 (x: Int, y: Int) ⇒ x + y 就
傳入兩個int的參數並傳回一個int的結果，這樣與Function2的<code>def apply(v1: T1, v2: T2): R</code>是相等的。</p>

<h4>closure</h4>

<p>closure跟function literal語法很相似，但closure多了<a href="#free_variables" title="scala:scala_101 ↵">free
variables</a>，所以，free
variables可被當做區分closure跟function literal的依據</p>

<h5>free variables</h5>

<p>TBC</p>

<h4>Constructor</h4>

<h5>primary constructor</h5>

<p><code>
class MyClass(x: Int, y: Int)
</code></p>

<h5>auxiliary constructor</h5>

<p>```
class MyClass(x: Int) {</p>

<pre><code>def this(x:Int) = this(x, 1) 
</code></pre>

<p>}
```</p>

<p>在scala，只有primary constructor可以呼叫super class的Constructor</p>

<p><code>
 
</code></p>

<h4>function parameters</h4>

<h5>repeated parameters</h5>

<p>repeated parameters像java的 myfunc(String…
args)，後面能用0到多個相同型別的參數</p>

<p><code>
def myfunc(args: String*)
</code></p>

<h5>naming parameters</h5>

<p>naming
parameters主要是在使用functions時可以指定參數的名稱，也因為可以指定參數的名稱，
所以傳入的參數順序可以跟原來宣告時的不一樣</p>

<p><code>
def myfunc(foo: Int, bar: String)
 
// call myfunc with naming parameter
val x = myfunc(bar="test", foo=1)
</code></p>

<h5>default value</h5>

<p>參數的預設值，如果沒有特別指定時，參數會以預設值為準</p>

<p><code>
def myfunc(foo: Int = 5)
</code></p>

<h5>loop</h5>

<p>如while 或者是 do-while loop 都是會帶有副作用(side
effect)，請儘量改用其他的方式實作</p>

<h5>for</h5>

<p>for loop有filter的功能</p>

<p>```
val filesHere = (new java.io.File(".")).listFiles
for (file &lt;- filesHere if file.getName.endsWith(".scala"))
  println(file)
 
// 上面那邊，的效果等同於<br/>
for (file &lt;- filesHere)
  if (file.getName.endsWith(".scala"))</p>

<pre><code>println(file)  
</code></pre>

<p>```</p>

<p>filter也可以累加，像這樣</p>

<p><code>
for (
  file &lt;- filesHere
  if file.isFile
  if file.getName.endsWith(".scala")
) println(file)
</code></p>

<h5>apply() and update()</h5>

<p><code>()</code>跟<code>()=</code>是語法糖(complier sugar)，分別等效於<code>apply()</code>跟<code>update()</code> ()
: apply() ()= : update()</p>

<h3>Import and Package</h3>

<h5>pacakge</h5>

<ol>
<li>可以是 java style ，把 package name 放在最上面</li>
<li>可以是 c# like，用 com.kentchiu { <em>package content } 或 com{
kentchiu {</em> package content} }</li>
<li>_root_ package</li>
</ol>


<h5>import</h5>

<p>與 java 的不同</p>

<ol>
<li>可以直接 import class member</li>
<li>可以 rename 或隱藏部份被 import 的 members</li>
</ol>


<p><code>
import com.kentchiu.{Foo, Bar}        // 只 import Foo 跟 Bar
import com.kentchiu.{Foo, Bar =&gt; Baz} // 只 import Foo 跟 Bar， Bar 改名為 Baz
import com.kentchiu.{Bar =&gt; _, _}     // Bar rename 成 _ ，會變成 import com.kentchiu 但把 Bar 排外
</code></p>

<h3>trait</h3>

<p>Trait像是java的interface，不過，更像是ruby的mixin</p>

<h5>Ordered Trait</h5>

<p>Ordered Trait是用來說明trait一個很好的例子，Rubyer應該對這個例子很眼熟</p>

<h3>case class</h3>

<h5>function programming</h5>

<p>Functional programming is a programming paradigm that describes
computation as the evaluation of mathematical functions avoiding state,
mutual data and therefore side effects</p>

<p>Function programming based on applying functions to arguments in order
to receive some desired values</p>

<p>The core idea for computation has shifted from a series of instructions
(which specify precisely how the computation should proceed) to Notation
of expressions, based on functions and values. You no longer have to
follow a plan of instructions in order to understand a computation but
decompose such an expression into its single elements.</p>

<h3>Sequence Comprehensions</h3>

<h3>Tuple</h3>

<p><code>
scala&gt; val t = (1,2)
t: (Int, Int) = (1,2)
 
scala&gt; val t = new Tuple2(1,2)
t: (Int, Int) = (1,2)
</code></p>

<p>tuple是透過特殊index語法存取</p>

<p><code>
scala&gt; t._1
res3: Int = 1
 
scala&gt; t._2
res4: Int = 2
</code></p>

<p>另外一種建立tuple的語法</p>

<p><code>
scala&gt; 1-&gt;2
res0: (Int, Int) = (1,2)
</code></p>

<h3>Extractors</h3>

<p>利用 <code>unApply()</code> method搭配pattern match將資訊從class中萃取出來</p>

<h3>Parser Combinators</h3>

<ul>
<li>Christoph Henkelmann’s Blog - An Introduction To Scala Parser
Combinators

<ol>
<li><a href="http://henkelmann.eu/2011/01/13/an_introduction_to_scala_parser_combinators" title="http://henkelmann.eu/2011/01/13/an_introduction_to_scala_parser_combinators">Part 1: Parser
Basics</a></li>
<li><a href="http://henkelmann.eu/2011/01/28/an_introduction_to_scala_parser_combinators-part_2_literal_expressions" title="http://henkelmann.eu/2011/01/28/an_introduction_to_scala_parser_combinators-part_2_literal_expressions">Part 2: Parsing Literal
Expressions</a></li>
<li><a href="http://henkelmann.eu/2011/01/29/an_introduction_to_scala_parser_combinators-part_3_unit_tests" title="http://henkelmann.eu/2011/01/29/an_introduction_to_scala_parser_combinators-part_3_unit_tests">An Introduction To Scala Parser Combinators - Part 3: Writing
unit tests for
parsers</a></li>
</ol>
</li>
</ul>


<h3>Symbol Literals</h3>

<p>Symbol Literals是在字串前加一個單引號'，像這樣'foo</p>

<p>Symbol
Literal主要作用是用來當作識別用，可以視為一個字串，但它不同於字串的地方有</p>

<ol>
<li>不可以有任何空白</li>
<li>一致性</li>
<li>對重構比較友善</li>
</ol>


<p>像典型的map可以寫成這樣</p>

<p><code>
"key" -&gt; "value"
</code></p>

<p>key的部份可以換成Symbol Literal取代</p>

<p><code>
'key -&gt; "value"
</code></p>

<p>這樣的好處是，'key更能代表唯一性，而且，如果要進行重構，'key對於重構的支援會比”key”來的好，如果任何地方需要用字串當作識別的時侯，或者可以考慮換成用Symbol
Literal取代</p>

<h1>TBD</h1>

<ul>
<li>The Divide and Conquer principle</li>
<li>Implicit Conversions and Parameters</li>
</ul>


<h1>Resource</h1>

<ul>
<li><a href="http://www.scala-lang.org/" title="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
官網</li>
<li><a href="http://docs.scala-lang.org/index.html" title="http://docs.scala-lang.org/index.html">http://docs.scala-lang.org/index.html</a>
官網文件</li>
<li>Functional scala serial
這一系列教學，很適合java背景，而且沒有function programming的人

<ol>
<li><a href="http://gleichmann.wordpress.com/2010/10/28/functional-scala-introduction/" title="http://gleichmann.wordpress.com/2010/10/28/functional-scala-introduction/">episode 1:
Introduction</a></li>
<li><a href="http://gleichmann.wordpress.com/2010/10/31/functional-scala-functions/" title="http://gleichmann.wordpress.com/2010/10/31/functional-scala-functions/">episode 2:
Functions</a></li>
<li><a href="http://gleichmann.wordpress.com/2010/11/08/functional-scala-functions-as-objects-as-functions/" title="http://gleichmann.wordpress.com/2010/11/08/functional-scala-functions-as-objects-as-functions/">episode 3: Functions as Objects as
Functions</a></li>
<li><a href="http://gleichmann.wordpress.com/2010/11/15/functional-scala-closures/" title="http://gleichmann.wordpress.com/2010/11/15/functional-scala-closures/">episode 4:
Closures</a></li>
<li><a href="http://gleichmann.wordpress.com/2010/11/21/functional-scala-comprehending-comprehensions/" title="http://gleichmann.wordpress.com/2010/11/21/functional-scala-comprehending-comprehensions/">episode 5: Comprehending
Comprehensions</a></li>
<li><a href="http://gleichmann.wordpress.com/2010/11/28/high-higher-higher-order-functions/" title="http://gleichmann.wordpress.com/2010/11/28/high-higher-higher-order-functions/">episode 6: High, Higher, Higher Order
Functions</a></li>
<li><a href="http://gleichmann.wordpress.com/2010/12/05/functional-scala-lambdas-and-other-shortcuts/" title="http://gleichmann.wordpress.com/2010/12/05/functional-scala-lambdas-and-other-shortcuts/">episode 7: Lambdas and other
shortcuts</a></li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[play framework 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/07/02/play_framework_101/"/>
    <updated>2012-07-02T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/07/02/play_framework_101</id>
    <content type="html"><![CDATA[<h3>在eclipse直接執行play console</h3>

<h3>Http Request處理流程</h3>

<p>```</p>

<pre><code>browser : http://localhost/foo?bar=baz

# project_home/conf/routes
GET    /foo                        controllers.Application.foo(bar: String)

# project_home/app/controllers/Application.scala
object Application extends Controller {

    def foo(bar: String) = Action {
        Ok("bar param value is: " +  bar) // 網頁顯示 bar param value is: baz
    }
}
</code></pre>

<p>```</p>

<ol>
<li>由網頁發起url: http://localhost/foo?bar=baz</li>
<li>play收到url後，會由routes這個設定檔來決定負責處理的controller是誰</li>
<li>controller中會有一個跟url
path相符的method進行處理，然後回應一個Action</li>
</ol>


<p>主要的流程就這樣，相當的單純</p>

<h3>Controller</h3>

<p>Controller是一個Singlton
Object，用來產生Action</p>

<h3>Action</h3>

<p>在play.api.mvc裡有兩個Action，一個是Singlton Object,另一個是trait，
trait的這個Action是一個 <code>play.api.mvc.Request ⇒ play.api.mvc.Result</code>
function負責處理並回應http request， 而Singtlton
Object這個Action是companion object，提供建立Action的一些helper
methods</p>

<p>Ok()這個method會回http status code 200給browser，http status code
200，就是沒有任何錯誤</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-02/play_framework_101-001.png" alt="play_framework_101-001.png" /></p>

<p>上面有提到Action是<code>play.api.mvc.Request ⇒ play.api.mvc.Result</code>
function，而AsyncResult, ChunkedResult, PlainResult, SimpleResult,
Status都是extends自trait Result，所以可以當作Action的傳回值</p>

<p>```</p>

<pre><code>package controllers
 
import play.api._
import play.api.mvc._
 
object Application extends Controller {
 
  def index = Action {
    Ok(views.html.index("Your new application is ready."))
  }
 
}
</code></pre>

<p>```</p>

<p>Ok(context) 表示回應http 200(正常)給網頁，content是要顯示的內容</p>

<p>ex:</p>

<p><code>Ok("Hello World")</code></p>

<p>網頁就會顯示 Hello World</p>

<p><code>views.html.index("Your new application is ready.")</code></p>

<p>則是套用play的template來顯示內容</p>

<p>```</p>

<pre><code>def index(param: String) = Action { implicit request =&gt;
  Ok("Got request [" + request + "] with param [" + param +"]")
}
</code></pre>

<p>```</p>

<h3>Request and Session</h3>

<p>Play的Session可以透過request.session取得，它是用cookie實作的，而且沒有所謂的session
timeout，如果需要session timeout的功能，要自已實作。</p>

<p>Play的Request不像java那樣，可以直接當作資料的載體，需透過Flash
Scope(也就是java servlet的request scope)</p>

<h2>Scala Template Engine</h2>

<h4>Handling the form submission</h4>

<p>在todolist這個教學中，有一段code是在建立 new
task的，這一些，對非scala的熟手來說不是那麼的易懂</p>

<p>```</p>

<pre><code>// Application
def newTask = Action { implicit request =&gt;
  taskForm.bindFromRequest.fold(
    errors =&gt; BadRequest(views.html.index(Task.all(), errors)),
    label =&gt; {
      Task.create(label)
      Redirect(routes.Application.tasks)
    }
  )
}
</code></pre>

<p>```</p>

<p>newTask這個method的傳回值是Action型別,
taskForm一是個<code>play.api.data.Form</code>型別，而<code>bindFromRequest</code>跟<code>fold</code>的API如下:
taskForm.bindFromRequest的回傳值是Form[String]，而newTask的型別是Action，所以taskForm.bindFromRequest的結果不能直接當newAction的結果。
fold的回傳值是R，我們只要讓R為Action型別即可當newTask的回傳值。</p>

<p>```</p>

<pre><code>/**
 * Binds request data to this form, i.e. handles form submission.
 *
 * @return a copy of this form filled with the new data
 */
def bindFromRequest()(implicit request: play.api.mvc.Request[_]): Form[T] = {
  val data = (request.body match {
    case body: play.api.mvc.AnyContent if body.asFormUrlEncoded.isDefined =&gt; body.asFormUrlEncoded.get
    case body: play.api.mvc.AnyContent if body.asMultipartFormData.isDefined =&gt; body.asMultipartFormData.get.asFormUrlEncoded
    case body: play.api.mvc.AnyContent if body.asJson.isDefined =&gt; FormUtils.fromJson(js = body.asJson.get).mapValues(Seq(_))
    case body: Map[_, _] =&gt; body.asInstanceOf[Map[String, Seq[String]]]
    case body: play.api.mvc.MultipartFormData[_] =&gt; body.asFormUrlEncoded
    case body: play.api.libs.json.JsValue =&gt; FormUtils.fromJson(js = body).mapValues(Seq(_))
    case _ =&gt; Map.empty[String, Seq[String]]
  }) ++ request.queryString
  bind(data.mapValues(_.headOption.getOrElse("")))
}
</code></pre>

<p>   
   </p>

<pre><code>def fold[R](hasErrors: Form[T] =&gt; R, success: T =&gt; R): R = value.map(success(_)).getOrElse(hasErrors(this))
</code></pre>

<p>```</p>

<p>fold的第一個hasErrors的參數是，在這邊是個像這樣的function literal
Form[String] ⇒ R(也就是你需要傳入適合的function value進去)
因為我們希望fold的結果可以直接當newTask
method的回傳值，所以R的型別為Action，也就是</p>

<p>```</p>

<pre><code>def fold[R](hasErrors: Form[T] =&gt; R, success: T =&gt; R): R = value.map(success(_)).getOrElse(hasErrors(this))
</code></pre>

<p>```</p>

<p>在這個例子的實際的型別是</p>

<p>```</p>

<pre><code>def fold[Action](hasErrors: Form[String] =&gt; Action, success: String =&gt; Action): Action = value.map(success(_)).getOrElse(hasErrors(this))
</code></pre>

<p>```</p>

<p>fold的使用範例是這樣</p>

<p>```</p>

<pre><code>    anyForm.bindFromRequest().fold(
       f =&gt; redisplayForm(f),                   // hasErrors: Form[String] =&gt; Action
       t =&gt; handleValidFormSubmission(t)        // success: String =&gt; Action 
    )
</code></pre>

<p>```</p>

<p>裡面的redisplayForm跟handleValidFormSubmission並不是play
API的一部份，他只是一個pseudo
code，用來表示通常hasErrors的處理方式是redisplayForm，而success的處理方式是handleValidFormSubmission</p>

<p>再回來看成來的例子</p>

<p>```</p>

<pre><code>// Application
def newTask = Action { implicit request =&gt;
  taskForm.bindFromRequest.fold(
    errors =&gt; BadRequest(views.html.index(Task.all(), errors)),  // hasErrors: Form[String] =&gt; Action
    label =&gt; {                                                   // success: String =&gt; Action 
      Task.create(label)
      Redirect(routes.Application.tasks)
    }
  )
}
</code></pre>

<p>```</p>

<h5>hasErrors參數的部份</h5>

<p>errors是Form[String]，而BadRequest是Action型別</p>

<p>hasErrors時會redisaply form，也就是用BadRequest(status 400)取代Ok(status
200)呼叫views.html.index，並把form的內容傳入</p>

<h5>success參數的部份</h5>

<p>label是String型別,
而傳回值Redirect(routes.Application.tasks)是Action型別 success時會handle
valid form submission，也就是建立task後，然後再轉到task list的頁面</p>

<h1>MISC</h1>

<h3>mapping method in Form</h3>

<p>```
import play.api.data.<em>
import play.api.data.Forms.</em>
 
case class User(name: String, age: Int)
 
val userForm = Form(
  mapping(</p>

<pre><code>"name" -&gt; text,
"age" -&gt; number
</code></pre>

<p>  )(User.apply)(User.unapply)
)
 
val anyData = Map("name" -> "bob", "age" -> "18")
val user: User = userForm.bind(anyData).get
```</p>

<p>Form裡面的mapping，對於play的新手，很容易誤為是Form.mapping()，但怎麼看，都對不起來，完全不知道為什麼可以用apply()跟unapply()，其實它是Forms.mapping()</p>

<p>Forms.mapping是長這樣</p>

<p>```</p>

<pre><code>/**
 * Creates a Mapping of type `T`.
 *
 * For example:
 *
 * @tparam T the mapped type
 * @param apply A function able to create a value of T from a value of A1 (If T is case class you can use its own apply function)
 * @param unapply A function able to create A1 from a value of T (If T is a case class you can use its own unapply function)
 * @return a mapping for type `T`
 */
def mapping[R, A1](a1: (String, Mapping[A1]))(apply: Function1[A1, R])(unapply: Function1[R, Option[(A1)]]): Mapping[R] = {
  ObjectMapping1(apply, unapply, a1)
}
</code></pre>

<p>```</p>

<p>對於本來就看不太懂API的新手，還找錯API，只會讓新手更覺得太多無法理解的migic</p>

<h4>細節說明</h4>

<p><code>
mapping[R, A1](a1: (String, Mapping[A1]))(apply: Function1[A1, R])(unapply: Function1[R, Option[(A1)]]): Mapping[R]
</code></p>

<p>mapping(…)(…)(…)把參數分成多個”群組”，表示這個function是<em>curried(柯里化)</em></p>

<p>先做大部拆解，這個method可以分為五個部份</p>

<ol>
<li>mapping[R, A1] 名稱，對應到上例中的mapping</li>
<li>(a1: (String, Mapping[A1])) 參數第一組，對應到上例中的 “email” →
of[String]</li>
<li>(apply: Function1[A1, R]) 參數第二組，對應到上例中的 User.apply</li>
<li>(unapply: Function1[R, Option[(A1)]]) 參數第三組，對應到上例中的
User.unapply</li>
<li>Mapping[R] 回傳值</li>
</ol>


<p>apply,unapply是來自case class</p>

<h5>mapping[R, A1]</h5>

<p>這部份可以知道裡面會有兩個泛型，一個是R,一個是A1</p>

<h5>(a1: (String, Mapping[A1]))</h5>

<p><code>(String, Mapping[A1])</code>是一個tuple，本例中為<code>“email” → of[String]</code></p>

<p>Mapping[A1]中的Mapping是trait型別，主要的功能是做格式間的轉換，本例是將request
string透過轉成String,Int,…格式</p>

<h5>(apply: Function1[A1, R])</h5>

<p><code>(apply: Function1[A1, R])</code>是一個function literal,在本例中為<code>User.apply</code>，</p>

<p>作用是將mapping的結果轉成User物件</p>

<p>由API可以知道Mapping是泛型<code>Mapping[R]</code>，所以R在例中，是<code>User</code></p>

<h5>(unapply: Function1[R, Option[(A1)]])</h5>

<p><code>(unapply: Function1[R, Option[(A1)]])</code>是一個function
literal,本例中為<code>User.unapply</code></p>

<p>作用是將User物件解構，把User的值再指派到<code>“email” → of[String]</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Currying]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/06/21/currying/"/>
    <updated>2012-06-21T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/06/21/currying</id>
    <content type="html"><![CDATA[<p>柯里化(currying)是指把多個參數的單一function轉換成只使用單一參數多個functions，轉換的方式，是把參數折分後，將前一個function的執行結果傳入下一個function，
功能上的作用是讓每個function都只有一個參數，而實際上的運用是用來</p>

<p><code>
// this code taken from http://www.codecommit.com/blog/scala/function-currying-in-scala
def add(x:Int, y:Int) = x + y
 
add(1, 2)   // 3
add(7, 3)   // 10
 
// currying版的
 
def add(x:Int) = (y:Int) =&gt; x + y
 
add(1)(2)   // 3
add(7)(3)   // 10
</code></p>

<h5>以 x = 1, y =2為例</h5>

<p>第一個版本的add
function，是add接受兩個參數(x=1,y=2)，然後相加後得到結果3</p>

<p>第二個柯里化後的add function，是第一個function <code>add(x:Int)</code>,
add(1)執行後會傳回一個整數值1，然後執行的結果1當作輸入值傳到第二個function<code>(y:Int) ⇒ x + y</code>，
(這個是一個closure，因為他有一個free variable
<code>x</code>)，x=1(來自前一個function的執行結果),y=2可得執行結果為3</p>

<h3>The Power of Currying</h3>

<p>scala為什麼需要Currying這樣的語法?因為有了Currying可以讓程式更一般化(更抽象，更通用)</p>

<p>```
// this code taken from http://www.codecommit.com/blog/scala/function-currying-in-scala
 
def process<a href="filter:A=>Boolean">A</a>(list:List[A]):List[A] = {
  lazy val recurse = process(filter) _
 
  list match {</p>

<pre><code>case head::tail =&gt; if (filter(head)) {
  head::recurse(tail)
} else {
  recurse(tail)
}
</code></pre>

<p> </p>

<pre><code>case Nil =&gt; Nil
</code></pre>

<p>  }
}
 
val even = (a:Int) => a % 2 == 0
 
val numbersAsc = 1::2::3::4::5::Nil
val numbersDesc = 5::4::3::2::1::Nil
 
process(even)(numbersAsc)   // [2, 4]
process(even)(numbersDesc)  // [4, 2]
```</p>

<p>最後面的</p>

<p><code>
process(even)(numbersAsc)   // [2, 4]
process(even)(numbersDesc)  // [4, 2]
</code></p>

<p><code>process(even)</code>像這樣的使用方式，如果一直在程式出現，在imperative
language(命令式語言 ex:java)中，我們通常會把這個透過extract
method的重構手法，把它抽出成一個獨立的method，
那在scala中，可以把<code>process(even)</code>變成Partially Applied
Functions(在此例中為<code>val processEvens = process(even) _</code>)，然後，直接使用processEvens會將原來<code>process(even)</code>變成Currying後的第一個
function的傳回值</p>

<p><code>
// this code taken from http://www.codecommit.com/blog/scala/function-currying-in-scala
 
val even = (a:Int) =&gt; a % 2 == 0
val processEvens = process(even) _
 
val numbersAsc = 1::2::3::4::5::Nil
val numbersDesc = 5::4::3::2::1::Nil
 
processEvens(numbersAsc)   // [2, 4]
processEvens(numbersDesc)  // [4, 2]
</code></p>

<h1>Resources</h1>

<ul>
<li><a href="http://gleichmann.wordpress.com/2011/12/04/functional-scala-curried-functions-and-spicy-methods/" title="http://gleichmann.wordpress.com/2011/12/04/functional-scala-curried-functions-and-spicy-methods/">http://gleichmann.wordpress.com/2011/12/04/functional-scala-curried-functions-and-spicy-methods/</a></li>
<li><a href="http://www.codecommit.com/blog/scala/function-currying-in-scala" title="http://www.codecommit.com/blog/scala/function-currying-in-scala">http://www.codecommit.com/blog/scala/function-currying-in-scala</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
