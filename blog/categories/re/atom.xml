<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: re | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/re/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2013-09-13T17:11:48+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Regular Expression (RE)]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/09/12/regular_expression/"/>
    <updated>2012-09-12T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/09/12/regular_expression</id>
    <content type="html"><![CDATA[<h3>The Negated Character ^</h3>

<p>Remember, a negated character class means “match a character that's not
listed” and not “don't match what is listed.”</p>

<p>Thus, [^x] doesn't mean <strong>“match unless there is an x”, but rather
match if there is something that is not x .</strong> The difference is subtle,
but important. The first concept matches a blank line, for example,
while ![^x] does not.</p>

<p>A character class, even negated, still requires a character to match.</p>

<h3>The Dot Charactor .</h3>

<p>It can be convenient when you want to have an <strong>any character here</strong>
placeholder in your expression.</p>

<h3>Parenthesis ()</h3>

<ol>
<li>capture</li>
<li>grouping</li>
<li>TBD</li>
</ol>


<h3>Lookaround</h3>

<ul>
<li>lookahead left to right</li>
<li>lookbehind right to left</li>
</ul>


<p>lookaround do <strong>NOT</strong> consume text</p>

<h3>Lookaround</h3>

<p>* (?=Expr) - zero-width positive lookahead 符合後面為exp的文字 *
(?!Expr) - zero-width negative lookahead 符合後面沒接exp的文字 *
(?⇐Expr) - zero-width positive lookbehind 符合前為為exp的文字
*(?&lt;!Expr) - zero-width negative lookbehind 符合前面沒接exp字首的文字</p>

<h4>Positive Lookaround</h4>

<p>lookahead及
lookbehind所搜尋的是目前符合之前或之後的文字，並不包含目前符合本身。這些就如同”^”及”\b”特殊字元，本身並不會對應任何文字
(用來界定位置)，也因此稱做是zero-width assertions。</p>

<p>可以想像成SQL語法的<strong>LIKE</strong>或<strong>NOT
LIKE</strong>不過行為並儘相似，反正想到可用SQL
like來處理的問題，用Lookaround來處理一定可行。</p>

<p>```</p>

<pre><code>\b\w+(?=ing\b) (字尾為ing的字，比如說filling所符合的就是fill)
</code></pre>

<p>```</p>

<p>(?⇐exp)是一個”zero-width positive lookbehind
assertion”。它指的就是符合字首為exp的文字，但不包含exp本身。</p>

<p>```</p>

<pre><code>(?&lt;=\bre)\w+\b (字首為re的字，比如說repeated所符合的就是peated)
(?&lt;=\d)\d{3}\b (在字尾的三位數字，且之前接一位數字)
(?&lt;=\s)\w+(?=\s) (由空白字元分隔開的字母數字字串)
</code></pre>

<p>```</p>

<h4>Negative Lookaround</h4>

<p>但如果只是要驗証某字元不存在而不要對應這些字元進來呢?舉個例子來說，假設要搜尋一個字，它的字母裏有q但接下來的字母不是u，可以用下列的RE來做。</p>

<p><code>
\b\w*q[^u]\w*\b (一個字，其字母裏有q但接下來的字母不是u)
</code></p>

<p>這樣的RE會有一個問題，因為[^u]要對應一個字元，所以若q是字的最後一個字母，[^u]這樣的下法就會將空白字元對應下去，結果就有可能會符合二個字，比如說”Iraq
haha”這樣的文字。使用Negative Lookaround就能解決這樣的問題。</p>

<p><code>
\b\w*q(?!u)\w*\b (一個字，其字母裏有q但接下來的字母不是u)
</code></p>

<p>這是”zero-width negative lookahead assertion”。</p>

<p><code>
\d{3}(?!\d) (三個位元的數字，其後不接一個位元數字)
</code></p>

<p>同樣的，可以使用(?&lt;!exp)，”zero-width negative lookbehind
assertion”，來符合前面沒接exp字首的文字串。</p>

<p><code>
(?&lt;![a-z ])\w{7} (七個字母數字的字串，其前面沒接字母或空格)
(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;) (HTML標籤間的文字)
</code></p>

<p>這使用lookahead及lookbehind
assertion來取出HTML間的文字，不包括HTML標籤。</p>

<h3>MISC</h3>

<p>“03[-./]19[-./]76” 與 “03[.-/]19[.-/]76”不同，因為”-“會變rang的意思</p>

<p>找gary (gery) 可用”gr[ea]y”，”grey|gray”, and even
“gr(a|e)y”，但不能用”g[a|e]ry” 因為[a|e]會被當作 a or | or e</p>

<p>“gr(a|e)y”跟”gra|ey”是後者找的是gra或者是ey</p>

<p>.-^ 等在character裡面跟外面有不同的意義</p>

<p>可有可以的字用”?” 如 ”(July|Jul)” 可用 “July?”. “4th|4” 可用 4(th)?</p>

<p>”&lt;H[1-6]
*>”.如果*前面多一個空格，表示要空n格，如果沒有空格表示n個”]”</p>

<h3>\p{class}, \P{class}</h3>

<p>\p{class} - POSIX or unicode character class \P{class} - exculde POSIX
or unicode character class</p>

<p>if pattern only contains \p(or \P) without {class}, it means all(or
excluded all) class</p>

<p>Supported class codes</p>

<p>C</p>

<p>Other</p>

<p>Cc</p>

<p>Control</p>

<p>Cf</p>

<p>Format</p>

<p>Cn</p>

<p>Unassigned</p>

<p>Co</p>

<p>Private use</p>

<p>Cs</p>

<p>Surrogate</p>

<p>L</p>

<p>Letter</p>

<p>Ll</p>

<p>Lower case letter</p>

<p>Lm</p>

<p>Modifier letter</p>

<p>Lo</p>

<p>Other letter</p>

<p>Lt</p>

<p>Title case letter</p>

<p>Lu</p>

<p>Upper case letter</p>

<p>M</p>

<p>Mark</p>

<p>Mc</p>

<p>Spacing mark</p>

<p>Me</p>

<p>Enclosing mark</p>

<p>Mn</p>

<p>Non-spacing mark</p>

<p>N</p>

<p>Number</p>

<p>Nd</p>

<p>Decimal number</p>

<p>Nl</p>

<p>Letter number</p>

<p>No</p>

<p>Other number</p>

<p>P</p>

<p>Punctuation</p>

<p>Pc</p>

<p>Connector punctuation</p>

<p>Pd</p>

<p>Dash punctuation</p>

<p>Pe</p>

<p>Close punctuation</p>

<p>Pf</p>

<p>Final punctuation</p>

<p>Pi</p>

<p>Initial punctuation</p>

<p>Po</p>

<p>Other punctuation</p>

<p>Ps</p>

<p>Open punctuation</p>

<p>S</p>

<p>Symbol</p>

<p>Sc</p>

<p>Currency symbol</p>

<p>Sk</p>

<p>Modifier symbol</p>

<p>Sm</p>

<p>Mathematical symbol</p>

<p>So</p>

<p>Other symbol</p>

<p>Z</p>

<p>Separator</p>

<p>Zl</p>

<p>Line separator</p>

<p>Zp</p>

<p>Paragraph separator</p>

<p>Zs</p>

<p>Space separator</p>

<p>中日韓文可以用 \p{InCJKUnifiedIdeographs}</p>

<h3>TBD</h3>

<p>\i - Match of capture group i</p>

<p>\cC - control character</p>

<p>\G - previous match's end</p>

<p>\A - The beginning of the input</p>

<p>&amp;&amp;</p>

<p>(Expr) - mark Expr as capture group</p>

<p>(ismd-ismd) - turn flags on or off</p>

<p>(ismd-ismd:Expr) - turn flags on or off in Expr</p>

<p>(?:Expr) - non capture group (有performance問題時才會使用)</p>

<p>(?>Expr) - non capture atomic group</p>

<h2>Lazy quantifiers</h2>

<ol>
<li>??</li>
<li>+?</li>
<li>*?</li>
<li>{n}?</li>
<li>{n,}?</li>
<li>{n,m}?</li>
</ol>


<p>minimal matching, non-greedy, and un-greedy quantifiers.</p>

<h2>Possessive quantifiers</h2>

<ol>
<li>?+</li>
<li>++</li>
<li>*+</li>
<li>{n}+</li>
<li>{n,}+</li>
<li>{n,m}+</li>
</ol>


<p>Only Java supports those quantifiers now</p>

<h2>Regex Modes and Match Modes</h2>

<ol>
<li>/i - case-insensitive mode</li>
<li>/x - free-spacing and comments mode</li>
<li>/s - dot matches-all match mode (a.k.a., single-line mode)</li>
<li>/m - enhanced line-anchor match mode (a.k.a., multiline mode)</li>
<li>\Q…\E - literal-text regex mode</li>
</ol>


<h4>free-spacing and comments mode</h4>

<p>all spaces and anything after comment mark(#) will not interpreted.</p>

<p>if you need a space in pattern, using \s instead normal space
character.</p>

<h4>dot matches-all match mode (a.k.a., single-line mode)</h4>

<p>Usually, dot does not match a newline, but in this mode, dot does.</p>

<h4>\Q...\E - literal-text regex mode</h4>

<p>\Q, \E means start/end quoting.</p>

<p>the contents of which have all meta-characters ignored (expect the \E
itself).</p>

<h3>mode modifier (?modifier)</h3>

<p>(?modifier) could be (?i) or (?-i) to enabled/disabled case-sensitive
matching.</p>

<p>the modifier can be i, x ,m ,s mode of <a href="#regex_modes_and_match_modes" title="prog:regular_expression ↵">Regex Modes and Match
Modes</a></p>

<h2>Capture (\1) ,(?&lt;Name>...) or(?P&lt;Name>...)</h2>

<p>Here's a <strong>PHP</strong> regular expression for matching *nested* parentheses
(e.g. blocks of code):</p>

<p>```</p>

<pre><code>((?:[^()]++|\((?1)\))*)
</code></pre>

<p>```</p>

<p>The ?1 is a recursive reference to the regex marked by the outermost
parentheses. It is a feature of the PHP regex engine.</p>

<p>See Jeffrey Friedl's Mastering Regular Expressions, 3rd ed., p. 476,
“Recursive reference to a set of capturing parentheses”.</p>

<p>Another potentially useful regex technique is “named capture”:</p>

<p>```</p>

<pre><code>^(?P&lt;protocol&gt;https?)://(?P&lt;host&gt;[^/:]+)(?::(?P&lt;port&gt;\d+))?
</code></pre>

<p>```</p>

<p>Here you can use either \$matches[0], \$matches[1], \$matches[2] or
\$matches['protocol'], \$matches['host'], \$matches['port'].</p>

<p>This favour has difference implementation in difference language
(library), you should check manual of yours.</p>

<h2>Greediness (貪婪)</h2>

<p>regexp 的搜尋引擎有一個特性, 叫做 greediness – 能吃多少,
就盡量吃多少。克服貪婪可用以下方式</p>

<p><code>
[^...] "除了 ... 之外的任何一個字元"    
</code></p>

<p>也可利用<a href="#lazy_quantifiers" title="prog:regular_expression ↵">lazy greedy</a></p>

<p><code>
.??  或 .*?
</code></p>

<p>Lazy quantifiers是要用在<code>.*</code>後面，end of match的前面</p>

<p>```</p>

<pre><code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- #BeginLibraryItem "/library/page_header.lbi" --&gt;
content of /page_header.lbi
&lt;!-- #EndLibraryItem --&gt;
&lt;!-- #BeginLibraryItem "/library/page_center.lbi" --&gt;
content of /page_center.lbi
&lt;!-- #EndLibraryItem --&gt;
&lt;!-- #BeginLibraryItem "/library/page_footer.lbi" --&gt;
content of /page_footer.lbi
&lt;!-- #EndLibraryItem --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>```</p>

<p>在使用Single-Line (Dot All) mode下，
如果是以上面這個RE做條件，會從第8行選到第16行，所以這樣會有三個matchs</p>

<p>```</p>

<!--\s*#BeginLibraryItem.*#EndLibraryItem\s*-->


<p>```</p>

<p>```</p>

<!-- #BeginLibraryItem "/library/page_header.lbi" -->


<p>content of /page_header.lbi</p>

<!-- #EndLibraryItem -->


<!-- #BeginLibraryItem "/library/page_center.lbi" -->


<p>content of /page_center.lbi</p>

<!-- #EndLibraryItem -->


<!-- #BeginLibraryItem "/library/page_footer.lbi" -->


<p>content of /page_footer.lbi</p>

<!-- #EndLibraryItem -->


<p>```</p>

<p>但是如果利用lazy quantifiers <code>*?</code>
，就只會選到第一個#EndLibraryItem(第8行到第10行)，所以這樣會有三個matchs</p>

<p>```</p>

<!--\s*#BeginLibraryItem.*?#EndLibraryItem\s*-->


<p>```</p>

<p>```</p>

<!-- #BeginLibraryItem "/library/page_header.lbi" -->


<p>content of /page_header.lbi</p>

<!-- #EndLibraryItem -->


<p>```</p>

<p>```</p>

<!-- #BeginLibraryItem "/library/page_center.lbi" -->


<p>content of /page_center.lbi</p>

<!-- #EndLibraryItem -->


<p>```</p>

<p>```</p>

<!-- #BeginLibraryItem "/library/page_footer.lbi" -->


<p>content of /page_footer.lbi</p>

<!-- #EndLibraryItem -->


<p>```</p>

<h2>The Backtracking</h2>

<p><strong>TBD</strong></p>

<h2>參考資源</h2>

<ul>
<li>洪朝貴教授的<a href="http://fsoss.fcu.org.tw/2004/hong-chaogui/08-regexp.html" title="http://fsoss.fcu.org.tw/2004/hong-chaogui/08-regexp.html">一輩子受用的 Regular
Expressions</a></li>
<li><a href="http://tw2.php.net/manual/en/reference.pcre.pattern.modifiers.php" title="http://tw2.php.net/manual/en/reference.pcre.pattern.modifiers.php">PHP patter
modifierss</a></li>
<li><a href="http://tw2.php.net/manual/en/regexp.reference.php" title="http://tw2.php.net/manual/en/regexp.reference.php">PHP RE
details</a></li>
<li><a href="http://www.regular-expressions.info/completelines.html" title="http://www.regular-expressions.info/completelines.html">http://www.regular-expressions.info/completelines.html</a>

<ul>
<li>a lot of RE examples</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
