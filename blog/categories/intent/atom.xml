<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: intent | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/intent/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2013-09-24T13:16:34+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Intents and Intent Filters]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/03/20/intents/"/>
    <updated>2012-03-20T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/03/20/intents</id>
    <content type="html"><![CDATA[<p>Intents是Android應用程式內部或應用程式與應用程式間溝通的一個機制。你可以簡單把Intents的視為是一種事件處理系統。</p>

<p>Intents的使用可分顯式啟動或隱式啟動，當一個隱式的Intent啟動時，Intent可以不知道會由誰來處理這個Intent，一般都是由系統決定什麼樣的Intent會由那一個Component處理。這樣可以達到應用上的解耦。
讓不同程式的Activity可以交互使用。例如，如果客製的程式需要一個發mail的功能，你可以直接使用系統現有的mail功能(含mail的UI)，不用自已再重寫一個mail
activity.</p>

<p>Intent可以包含以下內容：</p>

<ol>
<li>Component name :
要處理Intent的元件名稱，選擇性的屬性，如果有設定，就會由該元件處理這個intent，元件名稱是像這樣的格式:
com.example.project.app.FreneticActivity</li>
<li>Action : 執行什麼樣的動作</li>
<li>Data : content uri</li>
<li>Type : MIME type,用來識別資料型別</li>
<li>Category : action category</li>
<li>Extras : intent間溝通用的容器(Key-Value pair)</li>
<li>Flags</li>
</ol>


<p>典型的Intent的使用方式如下：</p>

<p><code>
Intent intent = new Intent(MyActivity.this, MyOtherActivity.class);
startActivity(intent);
</code></p>

<p>當<code>startActivity(intent);</code>被呼叫時，新的Activity(MyOtherActivity.class)會被帶到目前(MyActivity)的上面。</p>

<p>component設定可透過以下幾種方式</p>

<ol>
<li>setComponent(String name)</li>
<li>setClass(Class cls)</li>
<li>setClassName(String name)</li>
</ol>


<p>setClass因為對重構比基於字串為主的另外幾個method友善，所以，通常都用這個。</p>

<p>典型的隱式呼叫(適合用在跟其他app溝通)：</p>

<p><code>
private static final int PICK_CONTACT_SUBACTIVITY = 2;
Uri uri = Uri.parse("content://contacts/people");
Intent intent = new Intent(Intent.ACTION_PICK, uri);
startActivityForResult(intent, PICK_CONTACT_SUBACTIVITY);
</code></p>

<p>跟顯式呼叫的差別在，intent認的是事件的代碼，而不是activity本身。</p>

<p>Action Name的名稱為
<code>&lt;your-package-name &gt;.intent.action.YOUR_ACTION_NAME</code></p>

<h3>Intent filters</h3>

<p>Intent filters是activities, services, and broadcast
receivers用來過濾隱式intent的機制，只有intent有指定component
name就會直接送到該compnent處理(顯式)，不受intent filter的管理。
而如果沒有指定component
name(隱式)，就得看是否有通過附加在元件(activities, services, and
broadcast receivers)上的intent filter的測試。
Intent裡的只有以下三個屬性會被intent
filter拿來做測試用的條件，其他的不會影響intent filter的結果</p>

<ol>
<li>action</li>
<li>data (both URI and data type)</li>
<li>category</li>
</ol>


<p>這三個測試條件要完全通過，元件才會處理該intent，只有一個不符合，就算測試失敗，一般應用上，如果會擔心無法接收到想處理的intent，可以設定多個intent
filters來處理。</p>

<p><code>&lt;intent-filter&gt;</code>tag至少要包含action，如果<code>&lt;intent-filter&gt;</code>是空的tag，那會收到所有的intent</p>

<p>如果三個都是action，只要符合其中一個就算測試通過</p>

<p>```
&lt;intent-filter . . . ></p>

<pre><code>&lt;action android:name="com.example.project.SHOW_CURRENT" /&gt;
&lt;action android:name="com.example.project.SHOW_RECENT" /&gt;
&lt;action android:name="com.example.project.SHOW_PENDING" /&gt;
. . .
</code></pre>

<p>&lt;/intent-filter>
```</p>

<p>如果兩者都是category，只有符合其中一個就通過，或者，如果intent本身沒設定任何category，也會通過測試</p>

<p>```
&lt;intent-filter . . . ></p>

<pre><code>&lt;category android:name="android.intent.category.DEFAULT" /&gt;
&lt;category android:name="android.intent.category.BROWSABLE" /&gt;
. . .
</code></pre>

<p>&lt;/intent-filter>
```</p>

<p>Context.startActivity() 及
Activity.startActivityForResult()需要有<strong>DEFAULT
category</strong>(android.intent.category.DEFAULT)的intent
filter才能接收得到，所以除了<strong>MAIN action</strong>跟<strong>LAUNCHER
category</strong>外的activity 都應該要設定<strong>DEFAULT category</strong></p>
]]></content>
  </entry>
  
</feed>
