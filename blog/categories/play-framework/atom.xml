<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: play_framework | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/play-framework/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2014-05-29T12:26:05+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[play framework 101]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/07/02/play_framework_101/"/>
    <updated>2012-07-02T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/07/02/play_framework_101</id>
    <content type="html"><![CDATA[<h3>在eclipse直接執行play console</h3>

<h3>Http Request處理流程</h3>

<p>```</p>

<pre><code>browser : http://localhost/foo?bar=baz

# project_home/conf/routes
GET    /foo                        controllers.Application.foo(bar: String)

# project_home/app/controllers/Application.scala
object Application extends Controller {

    def foo(bar: String) = Action {
        Ok("bar param value is: " +  bar) // 網頁顯示 bar param value is: baz
    }
}
</code></pre>

<p>```</p>

<ol>
<li>由網頁發起url: http://localhost/foo?bar=baz</li>
<li>play收到url後，會由routes這個設定檔來決定負責處理的controller是誰</li>
<li>controller中會有一個跟url
path相符的method進行處理，然後回應一個Action</li>
</ol>


<p>主要的流程就這樣，相當的單純</p>

<h3>Controller</h3>

<p>Controller是一個Singlton
Object，用來產生Action</p>

<h3>Action</h3>

<p>在play.api.mvc裡有兩個Action，一個是Singlton Object,另一個是trait，
trait的這個Action是一個 <code>play.api.mvc.Request ⇒ play.api.mvc.Result</code>
function負責處理並回應http request， 而Singtlton
Object這個Action是companion object，提供建立Action的一些helper
methods</p>

<p>Ok()這個method會回http status code 200給browser，http status code
200，就是沒有任何錯誤</p>

<p><img src="http://blog.kent-chiu.com/images/2012-07-02/play_framework_101-001.png" alt="play_framework_101-001.png" /></p>

<p>上面有提到Action是<code>play.api.mvc.Request ⇒ play.api.mvc.Result</code>
function，而AsyncResult, ChunkedResult, PlainResult, SimpleResult,
Status都是extends自trait Result，所以可以當作Action的傳回值</p>

<p>```</p>

<pre><code>package controllers
 
import play.api._
import play.api.mvc._
 
object Application extends Controller {
 
  def index = Action {
    Ok(views.html.index("Your new application is ready."))
  }
 
}
</code></pre>

<p>```</p>

<p>Ok(context) 表示回應http 200(正常)給網頁，content是要顯示的內容</p>

<p>ex:</p>

<p><code>Ok("Hello World")</code></p>

<p>網頁就會顯示 Hello World</p>

<p><code>views.html.index("Your new application is ready.")</code></p>

<p>則是套用play的template來顯示內容</p>

<p>```</p>

<pre><code>def index(param: String) = Action { implicit request =&gt;
  Ok("Got request [" + request + "] with param [" + param +"]")
}
</code></pre>

<p>```</p>

<h3>Request and Session</h3>

<p>Play的Session可以透過request.session取得，它是用cookie實作的，而且沒有所謂的session
timeout，如果需要session timeout的功能，要自已實作。</p>

<p>Play的Request不像java那樣，可以直接當作資料的載體，需透過Flash
Scope(也就是java servlet的request scope)</p>

<h2>Scala Template Engine</h2>

<h4>Handling the form submission</h4>

<p>在todolist這個教學中，有一段code是在建立 new
task的，這一些，對非scala的熟手來說不是那麼的易懂</p>

<p>```</p>

<pre><code>// Application
def newTask = Action { implicit request =&gt;
  taskForm.bindFromRequest.fold(
    errors =&gt; BadRequest(views.html.index(Task.all(), errors)),
    label =&gt; {
      Task.create(label)
      Redirect(routes.Application.tasks)
    }
  )
}
</code></pre>

<p>```</p>

<p>newTask這個method的傳回值是Action型別,
taskForm一是個<code>play.api.data.Form</code>型別，而<code>bindFromRequest</code>跟<code>fold</code>的API如下:
taskForm.bindFromRequest的回傳值是Form[String]，而newTask的型別是Action，所以taskForm.bindFromRequest的結果不能直接當newAction的結果。
fold的回傳值是R，我們只要讓R為Action型別即可當newTask的回傳值。</p>

<p>```</p>

<pre><code>/**
 * Binds request data to this form, i.e. handles form submission.
 *
 * @return a copy of this form filled with the new data
 */
def bindFromRequest()(implicit request: play.api.mvc.Request[_]): Form[T] = {
  val data = (request.body match {
    case body: play.api.mvc.AnyContent if body.asFormUrlEncoded.isDefined =&gt; body.asFormUrlEncoded.get
    case body: play.api.mvc.AnyContent if body.asMultipartFormData.isDefined =&gt; body.asMultipartFormData.get.asFormUrlEncoded
    case body: play.api.mvc.AnyContent if body.asJson.isDefined =&gt; FormUtils.fromJson(js = body.asJson.get).mapValues(Seq(_))
    case body: Map[_, _] =&gt; body.asInstanceOf[Map[String, Seq[String]]]
    case body: play.api.mvc.MultipartFormData[_] =&gt; body.asFormUrlEncoded
    case body: play.api.libs.json.JsValue =&gt; FormUtils.fromJson(js = body).mapValues(Seq(_))
    case _ =&gt; Map.empty[String, Seq[String]]
  }) ++ request.queryString
  bind(data.mapValues(_.headOption.getOrElse("")))
}
</code></pre>

<p>   
   </p>

<pre><code>def fold[R](hasErrors: Form[T] =&gt; R, success: T =&gt; R): R = value.map(success(_)).getOrElse(hasErrors(this))
</code></pre>

<p>```</p>

<p>fold的第一個hasErrors的參數是，在這邊是個像這樣的function literal
Form[String] ⇒ R(也就是你需要傳入適合的function value進去)
因為我們希望fold的結果可以直接當newTask
method的回傳值，所以R的型別為Action，也就是</p>

<p>```</p>

<pre><code>def fold[R](hasErrors: Form[T] =&gt; R, success: T =&gt; R): R = value.map(success(_)).getOrElse(hasErrors(this))
</code></pre>

<p>```</p>

<p>在這個例子的實際的型別是</p>

<p>```</p>

<pre><code>def fold[Action](hasErrors: Form[String] =&gt; Action, success: String =&gt; Action): Action = value.map(success(_)).getOrElse(hasErrors(this))
</code></pre>

<p>```</p>

<p>fold的使用範例是這樣</p>

<p>```</p>

<pre><code>    anyForm.bindFromRequest().fold(
       f =&gt; redisplayForm(f),                   // hasErrors: Form[String] =&gt; Action
       t =&gt; handleValidFormSubmission(t)        // success: String =&gt; Action 
    )
</code></pre>

<p>```</p>

<p>裡面的redisplayForm跟handleValidFormSubmission並不是play
API的一部份，他只是一個pseudo
code，用來表示通常hasErrors的處理方式是redisplayForm，而success的處理方式是handleValidFormSubmission</p>

<p>再回來看成來的例子</p>

<p>```</p>

<pre><code>// Application
def newTask = Action { implicit request =&gt;
  taskForm.bindFromRequest.fold(
    errors =&gt; BadRequest(views.html.index(Task.all(), errors)),  // hasErrors: Form[String] =&gt; Action
    label =&gt; {                                                   // success: String =&gt; Action 
      Task.create(label)
      Redirect(routes.Application.tasks)
    }
  )
}
</code></pre>

<p>```</p>

<h5>hasErrors參數的部份</h5>

<p>errors是Form[String]，而BadRequest是Action型別</p>

<p>hasErrors時會redisaply form，也就是用BadRequest(status 400)取代Ok(status
200)呼叫views.html.index，並把form的內容傳入</p>

<h5>success參數的部份</h5>

<p>label是String型別,
而傳回值Redirect(routes.Application.tasks)是Action型別 success時會handle
valid form submission，也就是建立task後，然後再轉到task list的頁面</p>

<h1>MISC</h1>

<h3>mapping method in Form</h3>

<p>```
import play.api.data.<em>
import play.api.data.Forms.</em>
 
case class User(name: String, age: Int)
 
val userForm = Form(
  mapping(</p>

<pre><code>"name" -&gt; text,
"age" -&gt; number
</code></pre>

<p>  )(User.apply)(User.unapply)
)
 
val anyData = Map("name" -> "bob", "age" -> "18")
val user: User = userForm.bind(anyData).get
```</p>

<p>Form裡面的mapping，對於play的新手，很容易誤為是Form.mapping()，但怎麼看，都對不起來，完全不知道為什麼可以用apply()跟unapply()，其實它是Forms.mapping()</p>

<p>Forms.mapping是長這樣</p>

<p>```</p>

<pre><code>/**
 * Creates a Mapping of type `T`.
 *
 * For example:
 *
 * @tparam T the mapped type
 * @param apply A function able to create a value of T from a value of A1 (If T is case class you can use its own apply function)
 * @param unapply A function able to create A1 from a value of T (If T is a case class you can use its own unapply function)
 * @return a mapping for type `T`
 */
def mapping[R, A1](a1: (String, Mapping[A1]))(apply: Function1[A1, R])(unapply: Function1[R, Option[(A1)]]): Mapping[R] = {
  ObjectMapping1(apply, unapply, a1)
}
</code></pre>

<p>```</p>

<p>對於本來就看不太懂API的新手，還找錯API，只會讓新手更覺得太多無法理解的migic</p>

<h4>細節說明</h4>

<p><code>
mapping[R, A1](a1: (String, Mapping[A1]))(apply: Function1[A1, R])(unapply: Function1[R, Option[(A1)]]): Mapping[R]
</code></p>

<p>mapping(…)(…)(…)把參數分成多個”群組”，表示這個function是<em>curried(柯里化)</em></p>

<p>先做大部拆解，這個method可以分為五個部份</p>

<ol>
<li>mapping[R, A1] 名稱，對應到上例中的mapping</li>
<li>(a1: (String, Mapping[A1])) 參數第一組，對應到上例中的 “email” →
of[String]</li>
<li>(apply: Function1[A1, R]) 參數第二組，對應到上例中的 User.apply</li>
<li>(unapply: Function1[R, Option[(A1)]]) 參數第三組，對應到上例中的
User.unapply</li>
<li>Mapping[R] 回傳值</li>
</ol>


<p>apply,unapply是來自case class</p>

<h5>mapping[R, A1]</h5>

<p>這部份可以知道裡面會有兩個泛型，一個是R,一個是A1</p>

<h5>(a1: (String, Mapping[A1]))</h5>

<p><code>(String, Mapping[A1])</code>是一個tuple，本例中為<code>“email” → of[String]</code></p>

<p>Mapping[A1]中的Mapping是trait型別，主要的功能是做格式間的轉換，本例是將request
string透過轉成String,Int,…格式</p>

<h5>(apply: Function1[A1, R])</h5>

<p><code>(apply: Function1[A1, R])</code>是一個function literal,在本例中為<code>User.apply</code>，</p>

<p>作用是將mapping的結果轉成User物件</p>

<p>由API可以知道Mapping是泛型<code>Mapping[R]</code>，所以R在例中，是<code>User</code></p>

<h5>(unapply: Function1[R, Option[(A1)]])</h5>

<p><code>(unapply: Function1[R, Option[(A1)]])</code>是一個function
literal,本例中為<code>User.unapply</code></p>

<p>作用是將User物件解構，把User的值再指派到<code>“email” → of[String]</code></p>
]]></content>
  </entry>
  
</feed>
