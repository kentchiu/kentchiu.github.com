<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: joda | Kent's Blog]]></title>
  <link href="http://blog.kent-chiu.com/blog/categories/joda/atom.xml" rel="self"/>
  <link href="http://blog.kent-chiu.com/"/>
  <updated>2014-04-30T10:55:33+08:00</updated>
  <id>http://blog.kent-chiu.com/</id>
  <author>
    <name><![CDATA[Kent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[時間日期處理]]></title>
    <link href="http://blog.kent-chiu.com/blog/2012/09/30/date_and_time/"/>
    <updated>2012-09-30T00:00:00+08:00</updated>
    <id>http://blog.kent-chiu.com/blog/2012/09/30/date_and_time</id>
    <content type="html"><![CDATA[<p>日期的處理，在java中，一直是一個麻煩的問題，很多時間或日期操作若只是想透過JDK的<a href="http://download.oracle.com/javase/6/docs/api/java/util/Date.html" title="http://download.oracle.com/javase/6/docs/api/java/util/Date.html">Date</a>
或<a href="http://download.oracle.com/javase/6/docs/api/java/util/Calendar.html" title="http://download.oracle.com/javase/6/docs/api/java/util/Calendar.html">Calendar</a>來處理，會相當的不方便，況且
JDK內日期時間就有好幾種，很容易讓許多人無從下手，以下列出JDK
1.6內的日期時間相關物件(不含時間日期格式物件)</p>

<ol>
<li><a href="http://download.oracle.com/javase/6/docs/api/java/util/Date.html" title="http://download.oracle.com/javase/6/docs/api/java/util/Date.html">java.util.Date</a>
java日期物件</li>
<li><a href="http://download.oracle.com/javase/6/docs/api/java/sql/Date.html" title="http://download.oracle.com/javase/6/docs/api/java/sql/Date.html">java.sql.Date</a>
資料庫用的日期物件</li>
<li><a href="http://download.oracle.com/javase/6/docs/api/java/sql/Time.html" title="http://download.oracle.com/javase/6/docs/api/java/sql/Time.html">java.sql.Time</a>
資料庫用的日期物件</li>
<li><a href="http://download.oracle.com/javase/6/docs/api/java/sql/Timestamp.html" title="http://download.oracle.com/javase/6/docs/api/java/sql/Timestamp.html">java.sql.Timestamp</a>
資料庫用的時間戳記物件</li>
<li><a href="http://download.oracle.com/javase/6/docs/api/java/util/Calendar.html" title="http://download.oracle.com/javase/6/docs/api/java/util/Calendar.html">java.util.Calendar</a>
java日期物件</li>
</ol>


<p>目前處理日期相關的工具，除了上述的之外，JDK內還有<a href="http://wiki.kent-chiu.com/doku.php?id=java:date_and_time" title="java:date_and_time">日期格式化的相關功能</a>，另外，還有
Apache
<a href="http://commons.apache.org/lang/" title="http://commons.apache.org/lang/">connons-lang</a>裡的<a href="http://commons.apache.org/lang/api-2.6/org/apache/commons/lang/time/DateUtils.html" title="http://commons.apache.org/lang/api-2.6/org/apache/commons/lang/time/DateUtils.html">DateUtils</a>有許多好用的method可以做日期的判斷，
如果還是不足夠的話，還有時間日期處理的終極武器<a href="http://joda-time.sourceforge.net/" title="http://joda-time.sourceforge.net/">Joda
time</a>，可以很有效的對付時間日期區間的問題(Start
Time, End Time報表常會用到)， 那也可以看看<a href="http://sourceforge.net/apps/mediawiki/threeten/index.php?title=ThreeTen" title="http://sourceforge.net/apps/mediawiki/threeten/index.php?title=ThreeTen">JSR
310時間日期處理功能</a>，這個原本有可能是<a href="http://download.oracle.com/javase/7/docs/" title="http://download.oracle.com/javase/7/docs/">JDK
7</a>的一部份，現在就不了了之了</p>

<h3>日期時間常見的議題有</h3>

<ol>
<li>例假日</li>
<li>農民曆</li>
<li>中華民國歷</li>
<li>日光節約時間</li>
<li>地區化</li>
<li>格式化</li>
<li>日期區間運算</li>
</ol>


<h1>Apache Commons Lang</h1>

<h4>時間的shift</h4>

<ul>
<li>addDays</li>
<li>addHours</li>
<li>addMinutes</li>
<li>…</li>
</ul>


<h4>四捨五入，完全捨去，完全進位</h4>

<ul>
<li>ceiling</li>
<li>round</li>
<li>truncate</li>
</ul>


<h4>其他</h4>

<ul>
<li>toCalendar(Date) Date轉Calendar</li>
<li>isSameDay 是否為同一天</li>
<li>parseDate(String, String[]) 將字串轉成日期</li>
<li>getFragmentInXXX() 經過了多少的時間單位</li>
<li>iterator</li>
</ul>


<p>getFragmentInXXX()一系列的方法，可以計算出從何時到何時，總共經過了多時間，比如說，今年到今天，總共已經了多少天，或多少小時或多少秒，…</p>

<p>而iterator可以用以下的參數對某一個時間做iterator</p>

<ol>
<li>RANGE_MONTH_SUNDAY</li>
<li>RANGE_MONTH_MONDAY</li>
<li>RANGE_WEEK_SUNDAY</li>
<li>RANGE_WEEK_MONDAY</li>
<li>RANGE_WEEK_RELATIVE</li>
<li>RANGE_WEEK_CENTER</li>
</ol>


<h1>Joda Time</h1>

<ul>
<li>很容易從jdk的Date,Calendar轉換，只要傳入DateTime的Constructor即可</li>
<li>所有的datetime
classes都是immutable，但有提供一些method可以方便的傳回運算後新的datetime</li>
</ul>


<h3>主要的觀念</h3>

<ul>
<li>Instant - 最基本的觀念，基本上就是一個時間點或DateTime</li>
<li>Partial -</li>
<li>Interval - 時間間隔，也就是start time 跟 end time</li>
<li>Period - 期間，像是3天，6個月，5個小時，可以從interval轉換過來</li>
<li>Duration -
期間，跟Interval的不同是Duration是無timezone的，可以從interval轉換過來，但無法轉回interval</li>
<li>Chronology - 設計日曆的api用，大部份的情況下，可以不管它</li>
<li>DateTimeZone - Time Zone</li>
</ul>


<p>Duration V.S Period</p>

<p>Duration是很簡純的觀念，它就是一個固定的時間(多少毫秒)，而Period則是會隨CONTEXT變化的時間單位，比如說Period如果為一個月，對
一月份一的個月，跟二月份的一個月，長度就不一樣。</p>

<p>ex: 1/15要加一個月的時間，用Period來處理，就是1 Month Period,
(記為P1M)，就是是2/15日，如果用Duration來處理，它只能固定為一個時間長度(換算成milliseconds)，1月到2月是(29天的換算成的milliseconds)，所以就無法用相同的一個Duration來計算下個月的15號時何時(2-3月是30天)。</p>

<p>base, chrono, convert, field and tz這幾個packages是private
package,一般的application大多字會用到<code>org.joda.time</code> package的內容</p>

<h3>重要的Interface</h3>

<h5>ReadableInstant</h5>

<ol>
<li>compareTo(Object)</li>
<li>equals(Object)</li>
<li>get(DateTimeFieldType)</li>
<li>getChronology()</li>
<li>getMillis()</li>
<li>getZone()</li>
<li>hashCode()</li>
<li>isAfter(ReadableInstant)</li>
<li>isBefore(ReadableInstant)</li>
<li>isEqual(ReadableInstant)</li>
<li>isSupported(DateTimeFieldType)</li>
<li>toInstant()</li>
<li>toString()</li>
</ol>


<h5>ReadableInterval</h5>

<ol>
<li>contains(ReadableInstant)</li>
<li>contains(ReadableInterval)</li>
<li>equals(Object)</li>
<li>getChronology()</li>
<li>getEnd()</li>
<li>getEndMillis()</li>
<li>getStart()</li>
<li>getStartMillis()</li>
<li>hashCode()</li>
<li>isAfter(ReadableInstant)</li>
<li>isAfter(ReadableInterval)</li>
<li>isBefore(ReadableInstant)</li>
<li>isBefore(ReadableInterval)</li>
<li>overlaps(ReadableInterval)</li>
<li>toDuration()</li>
<li>toDurationMillis()</li>
<li>toInterval()</li>
<li>toMutableInterval()</li>
<li>toPeriod()</li>
<li>toPeriod(PeriodType)</li>
<li>toString()</li>
</ol>


<h5>ReadablePeriod</h5>

<ol>
<li>equals(Object)</li>
<li>get(DurationFieldType)</li>
<li>getFieldType(int)</li>
<li>getPeriodType()</li>
<li>getValue(int)</li>
<li>hashCode()</li>
<li>isSupported(DurationFieldType)</li>
<li>size()</li>
<li>toMutablePeriod()</li>
<li>toPeriod()</li>
<li>toString()</li>
</ol>


<p>joda-time中的interface跟一般framework中的interface不大一樣，一般的framework中，會建議儘量宣告物件成interface，但是在joda-time中，大多數的情況下，
必須用Concreate Class方能取得物件完整的能力</p>

<h3>ISO Date Format</h3>

<p><a href="http://en.wikipedia.org/wiki/ISO_8601" title="http://en.wikipedia.org/wiki/ISO_8601">ISO_8601</a>是關於日期時間格式相關的ISO規定，裡面的日期，是用”-“做分隔符號(而不是”/”)，建議所有的日期格式與ISO
8601相容 這樣，很多lib(不管是前端或後端)都可以比較容易處理。</p>

<h3>code snippet</h3>

<p>```</p>

<pre><code>Days days = Days.daysBetween(new DateTime(start), new DateTime(end));
</code></pre>

<p>```</p>

<p>parse含有AM/PM，要加上Locale.US，不然會出exception</p>

<p>```</p>

<pre><code>SimpleDateFormat df = new SimpleDateFormat("hh:mm aa", Locale.US);
</code></pre>

<p>```</p>

<p>如果有時確定格式是對的，但是就是一直出ParseException，這時記得加上Locale.US的參數試試</p>

<p>```</p>

<pre><code>import org.joda.time.DateTime;
import org.joda.time.Interval;
 
public enum Scheduling {
    DAILY, WEEKLY, MONTHLY,;
 
    public Interval interval(DateTime dt) {
        DateTime start;
        DateTime end;
        switch (this.name()) {
        case "DAILY":
            start = dt.withMillisOfDay(0);
            end = dt.withMillisOfDay(24 * 60 * 60 * 1000 -1);
            break;
        case "WEEKLY":
            start = dt.withDayOfWeek(1);
            end = dt.withDayOfWeek(7).withMillisOfDay(24 * 60 * 60 * 1000 -1);
            break;
        case "MONTHLY":
            start = dt.withDayOfMonth(1);
            int max = dt.dayOfMonth().getMaximumValue();
            end = dt.withDayOfMonth(max).withMillisOfDay(24 * 60 * 60 * 1000 -1);
            break;
        default:
            throw new UnsupportedOperationException("Unknow name :" + this.name());
        }
        return new Interval(start, end);
    }
 
}
 
//
// test case 
//
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;
 
import java.util.Date;
import java.util.Locale;
 
import org.apache.commons.lang3.time.DateUtils;
import org.joda.time.DateTime;
import org.joda.time.Interval;
import org.junit.Test;
 
public class SchedulingTest {
 
    @Test
    public void interval_daily() throws Exception {
        Date date = DateUtils.parseDate("2012/02/14", "yyyy/MM/dd");
        Interval interval = Scheduling.DAILY.interval(new DateTime(date));
        assertThat("2012/02/14 00:00:00", is(interval.getStart().toString("yyyy/MM/dd HH:mm:ss")));
        assertThat("2012/02/14 23:59:59", is(interval.getEnd().toString("yyyy/MM/dd HH:mm:ss")));
    }
 
    @Test
    public void interval_weekly() throws Exception {
        Date date = DateUtils.parseDate("2012/02/14", "yyyy/MM/dd"); // 2012/2/14 was a Tuesday
        Interval interval = Scheduling.WEEKLY.interval(new DateTime(date));
        assertThat("2012/02/13 00:00:00", is(interval.getStart().toString("yyyy/MM/dd HH:mm:ss")));
        assertThat("2012/02/19 23:59:59", is(interval.getEnd().toString("yyyy/MM/dd HH:mm:ss")));
        assertThat(interval.getStart().dayOfWeek().getAsText(Locale.ENGLISH), is("Monday")); // which day is first day of week that depend on OS settings
        assertThat(interval.getEnd().dayOfWeek().getAsText(Locale.ENGLISH), is("Sunday"));  // which day is end day of week that depend on OS settings
    }
 
    @Test
    public void interval_monthly() throws Exception {
        Date date = DateUtils.parseDate("2012/02/14", "yyyy/MM/dd"); 
        Interval interval = Scheduling.MONTHLY.interval(new DateTime(date));
        assertThat("2012/02/01 00:00:00", is(interval.getStart().toString("yyyy/MM/dd HH:mm:ss")));
        assertThat("2012/02/29 23:59:59", is(interval.getEnd().toString("yyyy/MM/dd HH:mm:ss")));
    }
 
}
</code></pre>

<p>```</p>

<h1>Resources</h1>

<ul>
<li><a href="http://commons.apache.org/lang/" title="http://commons.apache.org/lang/">http://commons.apache.org/lang/</a>

<ul>
<li>Apache Commons Lang</li>
</ul>
</li>
<li><a href="http://joda-time.sourceforge.net/" title="http://joda-time.sourceforge.net/">joda
time</a>

<ul>
<li>joda-time</li>
</ul>
</li>
<li><a href="http://sourceforge.net/apps/mediawiki/threeten/index.php?title=ThreeTen" title="http://sourceforge.net/apps/mediawiki/threeten/index.php?title=ThreeTen">JSR
310</a>

<ul>
<li>採用了很多<a href="http://joda-time.sourceforge.net/" title="http://joda-time.sourceforge.net/">joda
time</a>的API設計，但還沒穩定，建用還是用joda</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
