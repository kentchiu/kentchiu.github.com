<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kent&#39;s Blog</title>
    <description>Kent的學習筆記</description>
    <link>http://blog.kent-chiu.com//</link>
    <atom:link href="http://blog.kent-chiu.com//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 09 Dec 2014 13:08:58 +0800</pubDate>
    <lastBuildDate>Tue, 09 Dec 2014 13:08:58 +0800</lastBuildDate>
    <generator>Jekyll v2.5.2</generator>
    
      <item>
        <title>API Blueprint筆記</title>
        <description>&lt;h1 class=&quot;no_toc&quot; id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#notes&quot;&gt;Notes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#resource&quot;&gt;resource&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;一直以來，都在為了怎麼幫restful api寫文件而煩惱，對於一般的api，很多都會在語言的層面提供，像是python的docstrings，ruby的 doc comment, 或java的javadoc等，可以從method的註解產生api說明，但是restful的api，有其特殊性，一般不會在語法的層級支援 restful api的文件的寫作。&lt;/p&gt;

&lt;p&gt;目前評估過幾個solutions有:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;從source code的comment產生文件&lt;br /&gt;
&lt;a href=&quot;https://helloreverb.com/developers/swagger&quot;&gt;swagger&lt;/a&gt;為其中典型的代表，其他還有許多也是利用特定的annatation來結合source code本身的meta data產生文件。這種方案的好處是，可以透過reflection 程式，得到很多資訊，進而減少需要人工寫作的部份，在跟程式的同步性，一致性也比較好。但缺點就是彈性比較不足。&lt;/li&gt;
  &lt;li&gt;範本檔&lt;br /&gt;
有些熱心的人會提供word，google doc，純文字等的template來當作api文件寫法的基本結構，至於裡面該寫那些東西，大多大同小異。&lt;/li&gt;
  &lt;li&gt;特定格式&lt;br /&gt;
像&lt;a href=&quot;http://apiblueprint.org/&quot;&gt;API Buleprint&lt;/a&gt;，有定義出特定的規則系結構，依照它規格的結構與語法進行寫作後，通常會提供工作把api轉成可讀性比較高的結果(通常最後的結果是html格式)&lt;/li&gt;
  &lt;li&gt;自製&lt;br /&gt;
這是我採用API Buleprint前的方式，我偏好用純文字進行 api的文件撰寫，通常是採用markdown的格式，然後自已參考一些流行的rest api的文件結構，自已弄出一個喜歡的結構，用markdown寫的好處，是可以一般的 text editor就可以直接查看內容，如果需要比較好的呈現效果，也可以轉換成其他的呈現方式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;會採用API Buleprint主要考量有: &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;採markdown格式撰寫&lt;/li&gt;
  &lt;li&gt;API Buleprint只定義規則跟結構，不負責render，render有plugin負責&lt;/li&gt;
  &lt;li&gt;有plugin機制，其中有plugin提供單一的靜態html就可以查看api&lt;/li&gt;
  &lt;li&gt;原來自製的markdown，對toc跟hyper link效果不是很好，文件一大時，維護跟查找不便&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;撰寫時，最好開&lt;code&gt;live preview server&lt;/code&gt;，可以馬上做preview及語法檢查&lt;/li&gt;
  &lt;li&gt;文件比較大時，可以分成好幾個檔，然後再用cat指令多個指令接成一個檔再產生html&lt;/li&gt;
  &lt;li&gt;把非collection的resource secion放collection resource section前面，讓post(post是放collection resource section，因為沒有{id})可以reuse resource mode，ex，user GET,PUT, DELETE 放 users get, post前面&lt;/li&gt;
  &lt;li&gt;resource的定義有三種格式&lt;br /&gt;
&lt;code&gt;# &amp;lt;URI template&amp;gt;&lt;/code&gt; or &lt;code&gt;# &amp;lt;identifier&amp;gt; [&amp;lt;URI template&amp;gt;]&lt;/code&gt; or &lt;code&gt;# &amp;lt;HTTP request method&amp;gt; &amp;lt;URI template&amp;gt;&lt;/code&gt; , 第三種方式的nested section會變成 Action scetion&lt;br /&gt;
如果action比較少的情況，可以用第二種格式，就不用再定義Action sesion&lt;/li&gt;
  &lt;li&gt;sumlime text有&lt;a href=&quot;https://sublime.wbond.net/packages/API%20Blueprint&quot;&gt;plugin&lt;/a&gt;可以把文件parse成API Blueprint的語法樹(AST)&lt;/li&gt;
  &lt;li&gt;目前的版本(Format 1A revision 7) request跟response的屬性沒辦法像parameter那樣說明每個json的屬性，但之後的版本會有，可以先用 markdown的table語法來寫，或用schema section&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;resource&quot;&gt;resource&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/apiaryio/api-blueprint/blob/master/API%20Blueprint%20Specification.md&quot;&gt;API Blueprint 規格書&lt;/a&gt; - 建議仔細讀過，只看tutorail上是不夠的&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/danielgtaylor/aglio&quot;&gt;https://github.com/danielgtaylor/aglio&lt;/a&gt; - 把API Blueprint轉成html的工具，轉出來的html需放在server上才有辦法正常render&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sublime.wbond.net/packages/API%20Blueprint&quot;&gt;https://sublime.wbond.net/packages/API%20Blueprint&lt;/a&gt; - sublime text 3 的plugin&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc6570&quot;&gt;http://tools.ietf.org/html/rfc6570&lt;/a&gt; - url template語法的RFC&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 06 Oct 2014 01:20:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//rest/markdown/2014/10/06/api-blueprint.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//rest/markdown/2014/10/06/api-blueprint.html</guid>
        
        
        <category>rest</category>
        
        <category>markdown</category>
        
      </item>
    
      <item>
        <title>swift 101</title>
        <description>&lt;h1 class=&quot;no_toc&quot; id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#swift&quot;&gt;無廢話swift&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#resource&quot;&gt;resource&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;swift&quot;&gt;無廢話swift&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;let&lt;/code&gt; : 宣告常數&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;var&lt;/code&gt; : 宣告變數&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;\()&lt;/code&gt; : string substitution，也就是在字數裡可以直接使用變數&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;dict = [:]&lt;/code&gt; : 宣告 dictionary 資料結構&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;?&lt;/code&gt; : optional value (?加在型別後面，ex &lt;code&gt;var foo: String?&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;!&lt;/code&gt; :  implicitly unwrapped optionals，用來確定 optional 一定是有值的(非nil)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;if let&lt;/code&gt; : 處理 null變數用的，還不太清楚怎麼運用&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;..&lt;/code&gt; : 範圍，不含最後一個&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;...&lt;/code&gt; : 範圍，含最後一個&lt;/li&gt;
  &lt;li&gt;tuple : 可以取過屬性取得內容，也可以透過index取得內容 &lt;code&gt;myTuple.foo&lt;/code&gt;, &lt;code&gt;myTuple.bar&lt;/code&gt;, &lt;code&gt;myTuple.1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Int...&lt;/code&gt; : variable arugment&lt;/li&gt;
  &lt;li&gt;setter 的參數名稱為&lt;code&gt;newValue&lt;/code&gt;, 另外還有willSet跟didGet兩個method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;switch用法比較特別&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;let vegetable = &quot;red pepper&quot;
switch vegetable {
case &quot;celery&quot;:
    let vegetableComment = &quot;Add some raisins and make ants on a log.&quot;
case &quot;cucumber&quot;, &quot;watercress&quot;:
    let vegetableComment = &quot;That would make a good tea sandwich.&quot;
case let x where x.hasSuffix(&quot;pepper&quot;):
    let vegetableComment = &quot;Is it a spicy \(x)?&quot;
default:
    let vegetableComment = &quot;Everything tastes good in soup.&quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;funciton 是 first-class type, 所以像變數一樣被當作參數轉入，也可以當作傳回值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swfit&quot;&gt;func makeIncrementer() -&amp;gt; (Int -&amp;gt; Int) {
    func addOne(number: Int) -&amp;gt; Int {
        return 1 + number
    }
    return addOne
}

var increment = makeIncrementer() // call makeIncrementer() 不需要參數，但傳回值是 function型態的 increment
increment(7) // increment是function 型號，使用方式是傳入Int，然後返回Int (Int -&amp;gt; Int)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TBC: &lt;code&gt;case let x where x.hasSuffix(&quot;pepper&quot;):&lt;/code&gt;的寫法&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Interactive Learning Document Format&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html&quot;&gt;The Swift Programming Language&lt;/a&gt;&lt;br /&gt;
下載的&lt;a href=&quot;https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip&quot;&gt;GuidedTour.playground&lt;/a&gt;，&lt;br /&gt;
在Xcode打開後，看起來像是一般的文件，但裡面的程式範例是可以修改的，修改後可以立即看到執行結果。&lt;br /&gt;
其實這是apple的&lt;strong&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Reference/Playground_Ref/Chapters/InteractiveLearning.html&quot;&gt;Interactive Learning Document Format&lt;/a&gt;&lt;/strong&gt;的文件格式，抓下來的&lt;em&gt;GuidedTour.playground&lt;/em&gt;實際上是一個目錄，&lt;br /&gt;
裡面可包含html檔跟swift檔，然後用一個xml格式(contents.xcplayground)組織起來，就可以看到一份互動式文件了。Xcode處理這類型的文件時，html的部份就正常render成一般文件&lt;br /&gt;
，swift的code，就視同一般的playgroud的程式處理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;resource&quot;&gt;resource&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/swift/&quot;&gt;https://developer.apple.com/swift/&lt;/a&gt; - 官網&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-XID_0&quot;&gt;The Swift Programming Language&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gitbook.io/book/numbbbbb/-the-swift-programming-language-&quot;&gt;The Swift Programming Language 簡體中文版&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gitbook.io/book/mikimoto/the-swift-programming-language-zh-tw&quot;&gt;The Swift Programming Language 正體中文版&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.raywenderlich.com/74138/swift-language-faq&quot;&gt;http://www.raywenderlich.com/74138/swift-language-faq&lt;/a&gt; - swift faq&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 20 Sep 2014 12:44:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//apple/swift/101/2014/09/20/swift-101.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//apple/swift/101/2014/09/20/swift-101.html</guid>
        
        
        <category>apple</category>
        
        <category>swift</category>
        
        <category>101</category>
        
      </item>
    
      <item>
        <title>Liquibase 筆記</title>
        <description>&lt;h1 class=&quot;no_toc&quot; id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;簡介&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#liquibase&quot;&gt;執行Liquibase指令的方式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#maven-goals&quot;&gt;maven goals:&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#xmldb&quot;&gt;同步到xml到db&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#user-table&quot;&gt;建立user table&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;加入額外的欄位&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#insert-data&quot;&gt;insert data&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;版控說明&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#dbchangelog-masterxml&quot;&gt;完整的 db.changelog-master.xml&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#changelogxml&quot;&gt;從資料庫產生changelog.xml&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#data&quot;&gt;只產生data&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#schema--data&quot;&gt;同時產生schema + data&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pomxml&quot;&gt;完整的pom.xml&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;個人心得&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#resource&quot;&gt;resource&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section&quot;&gt;簡介&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.liquibase.org/&quot;&gt;Liquibase&lt;/a&gt;是資料庫版本管理工具，設定的概念是把資料庫schema的異動(table的建立，column的異動，index的異動…)及資料內容的異動(insert，update，delete)用Liquibase定義的語法寫成xml格式change log，然後在資料庫裡多建立一個名為databasechangelog的table(如下)，用來記錄db更新了那些change log，當xml新增了更多的change log後，跟db裡的版號一比對，就可得知未同步的change log有那些，下次同步時，就會同步這些未同步過的change log。概念上跟 git 滿像的。&lt;/p&gt;

&lt;p&gt;liquibase會在管理的database中加入databasechangelog table，用來記錄與xml同步的狀態&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;mydb=# select * from databasechangelog;
-[ RECORD 1 ]-+--------------------------------------------------------------------------------------------------
id            | 1
author        | bob
filename      | /Users/kent/dev/liquibase-exercise/src/main/resources/db.changelog-master.xml
dateexecuted  | 2014-08-30 10:28:35.235724
orderexecuted | 1
exectype      | EXECUTED
md5sum        | 7:17a94fcdd73aa8852c1f53e4d06ee651
description   | createTable
comments      | 
tag           | 
liquibase     | 3.2.2

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;需特別注意，change log設定檔，一旦同步過後，如果設定檔中的id，檔案路徑等tag有改到，就會被當成新的change log，再次被同步到db中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;liquibase&quot;&gt;執行Liquibase指令的方式&lt;/h4&gt;

&lt;p&gt;要執行Liquibase指令，可透過command line，ant，maven，或API呼叫，本文採用maven的方式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.liquibase&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;liquibase-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.2.2&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;changeLogFile&amp;gt;${basedir}/src/main/resources/db.changelog-master.xml&amp;lt;/changeLogFile&amp;gt;
                    &amp;lt;outputChangeLogFile&amp;gt;${basedir}/src/main/resources/output.xml&amp;lt;/outputChangeLogFile&amp;gt;
                    &amp;lt;driver&amp;gt;org.postgresql.Driver&amp;lt;/driver&amp;gt;
                    &amp;lt;url&amp;gt;jdbc:postgresql://localhost:5432/mydb&amp;lt;/url&amp;gt;
                    &amp;lt;username&amp;gt;postgres&amp;lt;/username&amp;gt;
                    &amp;lt;password&amp;gt;postgres&amp;lt;/password&amp;gt;
                    &amp;lt;promptOnNonLocalDatabase&amp;gt;false&amp;lt;/promptOnNonLocalDatabase&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;changeLogFile : 記錄要套用到db的xml檔(xml -&amp;gt; db)，執行update指令時，會依changeLogFile的內容異動資料庫schema&lt;/li&gt;
  &lt;li&gt;outputChangeLogFile: 從資料庫匯出xml時，會匯出到outputChangeLogFile (db -&amp;gt; xml)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;maven-goals&quot;&gt;maven goals:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;changelogSync : 將changelog中未套用至db的change logs標示成已同步&lt;/li&gt;
  &lt;li&gt;changelogSyncSQL : 同&lt;code&gt;changelogSync&lt;/code&gt;，但只產生sql，而不執行同步到db&lt;/li&gt;
  &lt;li&gt;generateChangeLog : 將目前資料庫的shcema(預設不含資料內容)匯出成 xml&lt;/li&gt;
  &lt;li&gt;dbDoc : 產生像java doc的文件&lt;/li&gt;
  &lt;li&gt;diff : 比對兩個資料庫間的差異&lt;/li&gt;
  &lt;li&gt;status : 顯示目前change set有那些change log會被套用到db&lt;/li&gt;
  &lt;li&gt;tag : 在liquibase產生在db的管理用table打上tag，之後可以當作rollback用&lt;/li&gt;
  &lt;li&gt;update : 更新未套用過的change set至db(xml -&amp;gt; db)&lt;/li&gt;
  &lt;li&gt;updateSQL : 同update，但產生更新的sql語法，不會真正同步db&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下的指令沒用過，不太清楚實際的動作情形:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;clearCheckSums :Clears all checksums in the current changelog, so they will be recalculatednext update.&lt;/li&gt;
  &lt;li&gt;dropAll :&lt;br /&gt;
Drops all database objects owned by the user. Note that functions, procedures&lt;br /&gt;
and packages are not dropped.&lt;/li&gt;
  &lt;li&gt;futureRollbackSQL :&lt;br /&gt;
Generates the SQL that is required to rollback the database to current state&lt;br /&gt;
after the next update.&lt;/li&gt;
  &lt;li&gt;listLocks :&lt;br /&gt;
Lists all Liquibase updater locks on the current database.&lt;/li&gt;
  &lt;li&gt;releaseLocks :&lt;br /&gt;
Removes any Liquibase updater locks from the current database.&lt;/li&gt;
  &lt;li&gt;rollback :&lt;br /&gt;
Invokes Liquibase rollbacks on a database.&lt;/li&gt;
  &lt;li&gt;rollbackSQL :&lt;br /&gt;
Generates the SQL that is required to rollback the database to the specified&lt;br /&gt;
pointing attributes ‘rollbackCount’, ‘rollbackTag’&lt;/li&gt;
  &lt;li&gt;updateTestingRollback :&lt;br /&gt;
Applies the DatabaseChangeLogs to the database, testing rollback. This is done&lt;br /&gt;
by updating the database, rolling it back then updating it again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;像 changelogSync，changelogSyncSQL，或 update，updateSQL，做的事情是差不多的，而有&lt;em&gt;SQL&lt;/em&gt;後綴的版本，是會把要執行的SQL語法輸出到stdout，而不進行db的更新。&lt;/p&gt;

&lt;p&gt;在使用上，新的database，一開始就用changelog的xml管理，所有的異動都透過xml管理，然後使用&lt;code&gt;mvn liquibase:update&lt;/code&gt;，就會將plugin中的&lt;code&gt;changeLogFile&lt;/code&gt;指定的&lt;br /&gt;
change log檔更新到db，如果是legcy的專案原本就有db的，可以用&lt;code&gt;mvn liquibase:generateChangeLog&lt;/code&gt;把db匯成change log檔案至&lt;code&gt;outputChangeLogFile&lt;/code&gt;指定的檔案中，之後再以產生出來的change log為基礎，做資料庫版本的管理。&lt;/p&gt;

&lt;h2 id=&quot;xmldb&quot;&gt;同步到xml到db&lt;/h2&gt;

&lt;h4 id=&quot;user-table&quot;&gt;建立user table&lt;/h4&gt;
&lt;p&gt;src/main/resources/db.changelog-master.xml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;databaseChangeLog
  xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd&quot;&amp;gt;

  &amp;lt;!-- 建立 uesr table --&amp;gt;
    &amp;lt;changeSet id=&quot;create-user-table&quot; author=&quot;kent&quot;&amp;gt;
        &amp;lt;createTable tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; type=&quot;varchar(50)&quot;&amp;gt;
                &amp;lt;constraints nullable=&quot;false&quot;/&amp;gt;
            &amp;lt;/column&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; type=&quot;varchar(50)&quot;&amp;gt;
            &amp;lt;/column&amp;gt;
        &amp;lt;/createTable&amp;gt;
    &amp;lt;/changeSet&amp;gt;

&amp;lt;/databaseChangeLog&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次執行&lt;code&gt;mvn liquibase:update&lt;/code&gt;執行後，原本完全沒有table的db多了三個table，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;databasechangelog是記錄同步用的，&lt;/li&gt;
  &lt;li&gt;databasechangeloglock是做locking的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面兩個都是直接由liquibase管理，不用去管它。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;user 則是上面的change log中的&lt;code&gt;&amp;lt;createTable&amp;gt;&lt;/code&gt;建立的&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;                 List of relations
 Schema |         Name          | Type  |  Owner   
--------+-----------------------+-------+----------
 public | databasechangelog     | table | postgres
 public | databasechangeloglock | table | postgres
 public | user                  | table | postgres

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;user跟change log中定義的結構是一致的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;              Table &quot;public.user&quot;
   Column   |         Type          | Modifiers 
------------+-----------------------+-----------
 first_name | character varying(50) | not null
 last_name  | character varying(50) | 

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;加入額外的欄位&lt;/h4&gt;
&lt;p&gt;src/main/resources/db.changelog-master.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;databaseChangeLog
  xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd&quot;&amp;gt;

   ...(略)

    &amp;lt;!-- 在user table加入 address column --&amp;gt;
    &amp;lt;changeSet id=&quot;addColumn-example&quot; author=&quot;kent&quot;&amp;gt;
        &amp;lt;addColumn catalogName=&quot;mydb&quot; schemaName=&quot;public&quot; tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;address&quot; type=&quot;varchar(255)&quot;/&amp;gt;
        &amp;lt;/addColumn&amp;gt;
    &amp;lt;/changeSet&amp;gt;  

&amp;lt;/databaseChangeLog&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改完changelog的xml檔，再次執行&lt;code&gt;mvn liquibase:update&lt;/code&gt;後，user table就會多出address column，這次執行，因為databasechangelog中已有記錄&lt;code&gt;&amp;lt;changeSet id=&quot;create-user-table&quot; author=&quot;kent&quot;&amp;gt;&lt;/code&gt;已經被執行過了，所以不會再次被執行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               Table &quot;public.user&quot;
   Column   |          Type          | Modifiers 
------------+------------------------+-----------
 first_name | character varying(50)  | not null
 last_name  | character varying(50)  | 
 address    | character varying(255) | 

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;insert-data&quot;&gt;insert data&lt;/h4&gt;
&lt;p&gt;src/main/resources/db.changelog-master.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;databaseChangeLog
  xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd&quot;&amp;gt;

   ...(略)

    &amp;lt;!-- insert兩筆測試資料 --&amp;gt;
    &amp;lt;changeSet id=&quot;insert-example&quot; author=&quot;kent&quot; &amp;gt;
        &amp;lt;insert catalogName=&quot;mydb&quot; schemaName=&quot;public&quot; tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;kent&quot;/&amp;gt; 
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt; 
        &amp;lt;/insert&amp;gt;
        &amp;lt;insert catalogName=&quot;mydb&quot; schemaName=&quot;public&quot; tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;cindy&quot;/&amp;gt; 
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt; 
        &amp;lt;/insert&amp;gt;
    &amp;lt;/changeSet&amp;gt;
&amp;lt;/databaseChangeLog&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改完changelog的xml檔，執行&lt;code&gt;mvn liquibase:update&lt;/code&gt;執行後，user table就會多出兩筆資料&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; first_name | last_name | address 
------------+-----------+---------
 kent       | chiu      | 
 cindy      | chiu      | 

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;版控說明&lt;/h4&gt;
&lt;p&gt;在實務上，只要是db的schema有要做異動，就一律從change log的設定檔改，如果是資料內容的異動，則視需求看要不要從change log異動。必要的預設資料可以在change log裡，透過insert tag來建立，可以省去每次重建table都還要另外建立預設資料的步驟。&lt;/p&gt;

&lt;p&gt;搭配其他指令，還可以讓資料庫回到特一個特定的版本(change set)，這樣在開發時，就不用怕弄亂資料庫了。&lt;/p&gt;

&lt;h4 id=&quot;dbchangelog-masterxml&quot;&gt;完整的 db.changelog-master.xml&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;databaseChangeLog
  xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd&quot;&amp;gt;

    &amp;lt;!-- 建立 uesr table --&amp;gt;
    &amp;lt;changeSet id=&quot;create-user-table&quot; author=&quot;kent&quot;&amp;gt;
        &amp;lt;createTable tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; type=&quot;varchar(50)&quot;&amp;gt;
                &amp;lt;constraints nullable=&quot;false&quot;/&amp;gt;
            &amp;lt;/column&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; type=&quot;varchar(50)&quot;&amp;gt;
            &amp;lt;/column&amp;gt;
        &amp;lt;/createTable&amp;gt;
    &amp;lt;/changeSet&amp;gt;

    &amp;lt;!-- 在user table加入 address column --&amp;gt;
    &amp;lt;changeSet id=&quot;addColumn-example&quot; author=&quot;kent&quot;&amp;gt;
        &amp;lt;addColumn catalogName=&quot;mydb&quot; schemaName=&quot;public&quot; tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;address&quot; type=&quot;varchar(255)&quot;/&amp;gt;
        &amp;lt;/addColumn&amp;gt;
    &amp;lt;/changeSet&amp;gt;

    &amp;lt;!-- insert兩筆測試資料 --&amp;gt;
    &amp;lt;changeSet id=&quot;insert-example&quot; author=&quot;kent&quot; &amp;gt;
        &amp;lt;insert catalogName=&quot;mydb&quot; schemaName=&quot;public&quot; tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;kent&quot;/&amp;gt; 
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt; 
        &amp;lt;/insert&amp;gt;
        &amp;lt;insert catalogName=&quot;mydb&quot; schemaName=&quot;public&quot; tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;cindy&quot;/&amp;gt; 
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt; 
        &amp;lt;/insert&amp;gt;
    &amp;lt;/changeSet&amp;gt;
&amp;lt;/databaseChangeLog&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;changelogxml&quot;&gt;從資料庫產生changelog.xml&lt;/h2&gt;
&lt;p&gt;對於即有的database，可以透過&lt;code&gt;generateChangeLog&lt;/code&gt;從資料庫產生change log，再以這個change log檔為基礎，之後的異動，再透過liquibase管理(xml -&amp;gt; db)&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;generateChangeLog&lt;/code&gt;進行匯出時，預設是只有schema(tables, views, columns, indexs,foreignkeys, primarykeys, uniqueconstraints)，如果要產&lt;br /&gt;
生資料，要在&lt;code&gt;diffTypes&lt;/code&gt;中加入&lt;strong&gt;data&lt;/strong&gt;這個type。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kent@Kents-MacBook-Pro:~/dev/liquibase-exercise$ mvn liquibase:generateChangeLog
[INFO] Scanning for projects...
[INFO] 
[INFO] Using the builder org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder with a thread count of 1
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building liquibase-exercise 1.1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- liquibase-maven-plugin:3.2.2:generateChangeLog (default-cli) @ liquibase-exercise ---
[INFO] ------------------------------------------------------------------------
[INFO] Executing on Database: jdbc:postgresql://localhost:5432/mydb
[INFO] Generating Change Log from database postgres @ jdbc:postgresql://localhost:5432/mydb (Default Schema: public)
INFO 8/30/14 12:30 PM: liquibase: /Users/kent/dev/liquibase-exercise/src/main/resources/output.xml does not exist, creating
[INFO] Output written to Change Log file, /Users/kent/dev/liquibase-exercise/src/main/resources/output.xml
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2.087 s
[INFO] Finished at: 2014-08-30T12:31:00+08:00
[INFO] Final Memory: 8M/61M
[INFO] ------------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;執行完&lt;code&gt;generateChangeLog&lt;/code&gt;可以看到change log產生到我們plugin的設定中指定的位置&lt;code&gt;src/main/resources/output.xml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果沒有特別指定&lt;code&gt;diffTypes&lt;/code&gt;參數，那只會產生’tables, views, columns, indexs,foreignkeys, primarykeys, uniqueconstraints’&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&amp;gt;
&amp;lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot; xmlns:ext=&quot;http://www.liquibase.org/xml/ns/dbchangelog-ext&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.2.xsd&quot;&amp;gt;
    &amp;lt;changeSet author=&quot;kent (generated)&quot; id=&quot;1409373059484-1&quot;&amp;gt;
        &amp;lt;insert tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;kent&quot;/&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot;/&amp;gt;
        &amp;lt;/insert&amp;gt;
        &amp;lt;insert tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;cindy&quot;/&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot;/&amp;gt;
        &amp;lt;/insert&amp;gt;
    &amp;lt;/changeSet&amp;gt;
    &amp;lt;changeSet author=&quot;kent (generated)&quot; id=&quot;1409373299327-1&quot;&amp;gt;
        &amp;lt;createTable tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; type=&quot;VARCHAR(50)&quot;&amp;gt;
                &amp;lt;constraints nullable=&quot;false&quot;/&amp;gt;
            &amp;lt;/column&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; type=&quot;VARCHAR(50)&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot; type=&quot;VARCHAR(255)&quot;/&amp;gt;
        &amp;lt;/createTable&amp;gt;
    &amp;lt;/changeSet&amp;gt;
&amp;lt;/databaseChangeLog&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;data&quot;&gt;只產生data&lt;/h4&gt;
&lt;p&gt;指定&lt;code&gt;diffTypes=data&lt;/code&gt;，就會只產生資料，不會有schema的資訊，如果有需要，也可以直接將資料匯出成csv檔&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mvn liquibase:generateChangeLog -Dliquibase.diffTypes=data

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;產生的xml如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&amp;gt;
&amp;lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot; xmlns:ext=&quot;http://www.liquibase.org/xml/ns/dbchangelog-ext&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.2.xsd&quot;&amp;gt;
    &amp;lt;changeSet author=&quot;kent (generated)&quot; id=&quot;1409373576402-1&quot;&amp;gt;
        &amp;lt;insert tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;kent&quot;/&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot;/&amp;gt;
        &amp;lt;/insert&amp;gt;
        &amp;lt;insert tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;cindy&quot;/&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot;/&amp;gt;
        &amp;lt;/insert&amp;gt;
    &amp;lt;/changeSet&amp;gt;
&amp;lt;/databaseChangeLog&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;schema--data&quot;&gt;同時產生schema + data&lt;/h4&gt;
&lt;p&gt;如果要產生的xml如下，那&lt;code&gt;diffTypes&lt;/code&gt;就要設定為&lt;code&gt;tables,views,columns,indexs,foreignkeys,primarykeys,uniqueconstraints,data&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mvn liquibase:generateChangeLog -Dliquibase.diffTypes=tables,views,columns,indexs,foreignkeys,primarykeys,uniqueconstraints,data

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;產生的xml如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&amp;gt;
&amp;lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot; xmlns:ext=&quot;http://www.liquibase.org/xml/ns/dbchangelog-ext&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.2.xsd&quot;&amp;gt;
    &amp;lt;changeSet author=&quot;kent (generated)&quot; id=&quot;1409373576402-1&quot;&amp;gt;
        &amp;lt;insert tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;kent&quot;/&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot;/&amp;gt;
        &amp;lt;/insert&amp;gt;
        &amp;lt;insert tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;cindy&quot;/&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot;/&amp;gt;
        &amp;lt;/insert&amp;gt;
    &amp;lt;/changeSet&amp;gt;
    &amp;lt;changeSet author=&quot;kent (generated)&quot; id=&quot;1409373769747-1&quot;&amp;gt;
        &amp;lt;createTable tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; type=&quot;VARCHAR(50)&quot;&amp;gt;
                &amp;lt;constraints nullable=&quot;false&quot;/&amp;gt;
            &amp;lt;/column&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; type=&quot;VARCHAR(50)&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot; type=&quot;VARCHAR(255)&quot;/&amp;gt;
        &amp;lt;/createTable&amp;gt;
    &amp;lt;/changeSet&amp;gt;
    &amp;lt;changeSet author=&quot;kent (generated)&quot; id=&quot;1409373769747-2&quot;&amp;gt;
        &amp;lt;insert tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;kent&quot;/&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot;/&amp;gt;
        &amp;lt;/insert&amp;gt;
        &amp;lt;insert tableName=&quot;user&quot;&amp;gt;
            &amp;lt;column name=&quot;first_name&quot; value=&quot;cindy&quot;/&amp;gt;
            &amp;lt;column name=&quot;last_name&quot; value=&quot;chiu&quot;/&amp;gt;
            &amp;lt;column name=&quot;address&quot;/&amp;gt;
        &amp;lt;/insert&amp;gt;
    &amp;lt;/changeSet&amp;gt;
&amp;lt;/databaseChangeLog&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;pomxml&quot;&gt;完整的pom.xml&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.kent&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;liquibase-exercise&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.postgresql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;postgresql&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;9.3-1101-jdbc41&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.liquibase&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;liquibase-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.2.2&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;changeLogFile&amp;gt;${basedir}/src/main/resources/db.changelog-master.xml&amp;lt;/changeLogFile&amp;gt;
                    &amp;lt;outputChangeLogFile&amp;gt;${basedir}/src/main/resources/output.xml&amp;lt;/outputChangeLogFile&amp;gt;
                    &amp;lt;driver&amp;gt;org.postgresql.Driver&amp;lt;/driver&amp;gt;
                    &amp;lt;url&amp;gt;jdbc:postgresql://localhost:5432/mydb&amp;lt;/url&amp;gt;
                    &amp;lt;username&amp;gt;postgres&amp;lt;/username&amp;gt;
                    &amp;lt;password&amp;gt;postgres&amp;lt;/password&amp;gt;
                    &amp;lt;promptOnNonLocalDatabase&amp;gt;false&amp;lt;/promptOnNonLocalDatabase&amp;gt;
                    &amp;lt;!-- 同時產生資料跟schema --&amp;gt;
                    &amp;lt;!--
                    &amp;lt;diffTypes&amp;gt;tables, views, columns, indexs,foreignkeys, primarykeys, uniqueconstraints, data&amp;lt;/diffTypes&amp;gt;
                    --&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;        
&amp;lt;/project&amp;gt;                     

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;個人心得&lt;/h2&gt;
&lt;p&gt;會接觸liquibase，主要是因為維護的專案，是屬於產品類型的，一但delivery給客戶後，要昇級程式，常不可避免的會動到db的結構或資料。&lt;br /&gt;
新增table跟column通常都不太會有問題，但是如果是要做delete或rename，甚至是對即有資料內容做一些格式的調整或轉換，一些簡單的sql指令(ddl或dml)就有點使不上力了，可能就要寫一些sql的funciton來處理，如果邏輯更複雜時就需要用程式處理，&lt;/p&gt;

&lt;p&gt;在當時並沒有比較適合的solution，於是採用了類似Ruby On Rails管資料庫版本的方式做了一套，大部份的異動，都還是希望透過&lt;br /&gt;
sql script就能處理，但有些最基本的判斷，像column存不存在，不存在就建立，或column的rename，這些透過sql也不是很好處理，通常都要透過自製的sql function來處理，如果比較複雜的，就寫一個小程式來取代原來的sql script，使用上並不方便，而且&lt;br /&gt;
維護成本也不小，光每次測試sql patch，所以這次斷然決定換成用liquibase來管理，看看會不會有顯著的改善，目前看來使用經&lt;br /&gt;
驗算是不錯。&lt;/p&gt;

&lt;h2 id=&quot;resource&quot;&gt;resource&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.liquibase.org/documentation/maven/index.html&quot;&gt;http://www.liquibase.org/documentation/maven/index.html&lt;/a&gt; - liquibase maven plugin&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 30 Aug 2014 12:44:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//liquibase/database/refactory/2014/08/30/liquibase-101.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//liquibase/database/refactory/2014/08/30/liquibase-101.html</guid>
        
        
        <category>liquibase</category>
        
        <category>database</category>
        
        <category>refactory</category>
        
      </item>
    
      <item>
        <title>Spring Boot筆記</title>
        <description>&lt;h1 class=&quot;no_toc&quot; id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#properties&quot;&gt;Properties&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jpa&quot;&gt;JPA&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#testing&quot;&gt;Testing&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#unit-test&quot;&gt;Unit Test&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#database-test&quot;&gt;Database Test&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#web-test&quot;&gt;Web Test&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#spring-boot-application-test&quot;&gt;Spring Boot Application Test&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#unsorted&quot;&gt;unsorted&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;pom.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;    &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
    &amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
        &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

        &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;myproject&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;

        &amp;lt;parent&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1.0.M2&amp;lt;/version&amp;gt;
        &amp;lt;/parent&amp;gt;

        &amp;lt;!-- Additional lines to be added here... --&amp;gt;

    &amp;lt;/project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;maven設定檔是透過&lt;code&gt;&amp;lt;parent&amp;gt;&lt;/code&gt; tag繼承 spring-boot預先定義好的 parent pom，在parent的pom檔中，有許多預設的dependencies，所以，引用到 parent pom裡已預先定義好的 dependency 時，就不需再定義該 &lt;code&gt;&amp;lt;dependency&amp;gt;&lt;/code&gt; tag下的 &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; tag。在本文章中的 &lt;code&gt;&amp;lt;dependency&amp;gt;&lt;/code&gt;  只要是沒加 &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; tag的，都是因為 parent pom 已有預先定義好的 dependencies.&lt;/p&gt;

&lt;p&gt;建議可以調 parent 的 pom.xml 出來看看，會比較清楚 spring boot 的 building 機制，eclipse 跟 intelliJ 都支援 link 到 parent pom 的功能。 &lt;/p&gt;

&lt;p&gt;Spring Boot Hello World:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Controller
@EnableAutoConfiguration
public class Application {

    @RequestMapping(&quot;/&quot;)
    @ResponseBody
    String home() {
        return &quot;Hello World!&quot;;
    }


    public static void main(String[] args) {
        ApplicationContext ctx = SpringApplication.run(Application.class, args);

        System.out.println(&quot;Let&#39;s inspect the beans provided by Spring Boot:&quot;);

        String[] beanNames = ctx.getBeanDefinitionNames();
        Arrays.sort(beanNames);
        // 表列出引用到的 beans
        for (String beanName : beanNames) {
            System.out.println(beanName);
        }
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比起傳統的 Spring RESTful 程式，spring boot簡單許多。 &lt;/p&gt;

&lt;p&gt;spring-boot-maven-plugin主要的功能是 build 出 war 檔或可執行的 jar 檔&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;執行 &lt;code&gt;mvn spring-boot:run&lt;/code&gt; ， 加入 &lt;code&gt;--debug&lt;/code&gt; 參數可以dump auto config 的細節， 方便除錯 &lt;code&gt;mvn spring-boot:run --debug&lt;/code&gt;，如果是在IDE執行成 Application，那把&lt;code&gt;--debug&lt;/code&gt;加到program argument即可，或者是直接寫到&lt;code&gt;SpringApplicationBuilder&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;new SpringApplicationBuilder(MyConfig.class).run(new String[]{&quot;--debug&quot;});&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;=========================
AUTO-CONFIGURATION REPORT
=========================


Positive matches:
-----------------

   AuditAutoConfiguration.AuditEventRepositoryConfiguration
      - @ConditionalOnMissingBean (types: org.springframework.boot.actuate.audit.AuditEventRepository; SearchStrategy: all) found no beans (OnBeanCondition)

   EndpointAutoConfiguration#autoConfigurationAuditEndpoint
      - @ConditionalOnBean (types: org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport; SearchStrategy: all) found the following [autoConfigurationReport] @ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.AutoConfigurationReportEndpoint; SearchStrategy: current) found no beans (OnBeanCondition)

   EndpointAutoConfiguration#beansEndpoint
      - @ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.BeansEndpoint; SearchStrategy: all) found no beans (OnBeanCondition)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要抓到Application傳進來的參數，可以implement &lt;code&gt;CommandLineRunner&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import org.springframework.boot.*
import org.springframework.stereotype.*

@Component
public class MyBean implements CommandLineRunner {

    public void run(String... args) {
        // Do something...
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;properties&quot;&gt;Properties&lt;/h2&gt;

&lt;p&gt;屬性檔預設預案是在 classpath下的 application.properties或 application-{profile}.properties&lt;/p&gt;

&lt;p&gt;屬性中可以用亂數產生器,因為使用了&lt;code&gt;RandomValuePropertySource&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-properties&quot;&gt;my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在屬性檔的屬性可以透過&lt;code&gt;@Value&lt;/code&gt;及&lt;code&gt;@ConfigurationProperties&lt;/code&gt; binding 到程式， 也可以jsr-303的 bean validation 進行驗證。 &lt;/p&gt;

&lt;h2 id=&quot;jpa&quot;&gt;JPA&lt;/h2&gt;

&lt;p&gt;要在 spring boot 中啟用 JPA也相當簡單， 只要加入 &lt;code&gt;spring-boot-starter-data-jpa&lt;/code&gt; 跟 database driver即可，其他的設定像 hibernate.dialect 等 spring boot 會依照使用的資料庫選擇適合的設定。&lt;/p&gt;

&lt;p&gt;使用 hsqldb 當 database&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.hsqldb&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;hsqldb&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 mysql 當 database&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果用 in-memory database，像hsqldb，h2，derby … 當db，jpa會自動建立 entity 對應的table，如果是其他 database，則需自行建立，或者也可以透過 application.properties 設定檔來改寫預設的行為。 &lt;/p&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;

&lt;h4 id=&quot;unit-test&quot;&gt;Unit Test&lt;/h4&gt;

&lt;p&gt;spring一向強調測試的重要性，在spring寫測試比起在其它 framework 下會愉快許多。spring boot 在測試上，在基於 spring 本身的基礎上，又加了一些方便的配置。&lt;/p&gt;

&lt;p&gt;在繼承 parent pom之後，unit test常用的三板斧，就會被配置在 test scope了(不會被 deploy 成product)，這三板斧是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Junit - 單元測試lib&lt;/li&gt;
  &lt;li&gt;Hamcrest - 斷言工具 (assertion)，搭配 &lt;code&gt;assertThat&lt;/code&gt; 用的(不要再 &lt;code&gt;assertEquals&lt;/code&gt;，請一律&lt;code&gt;assertThat&lt;/code&gt;吧)&lt;/li&gt;
  &lt;li&gt;Mockito - 目前java最流行的 mock framework&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;database-test&quot;&gt;Database Test&lt;/h4&gt;

&lt;p&gt;如果要做的測試跟db有關，建議採用in-memory database，不要mock，但如果沒有採用像 jpa 這種會自動依 dialect 轉換 sql 語法的 framework時，可能就要對測試方式做調整。在資料庫的測試，我通常是採用 hsqldb + dbunit，而production的database，即依專案需求而決定，使用jpa時，單元測試時在 hsqldb，真正執行時在其他db ex: mysql， postgresql，…，都沒遇過太大的問題。&lt;/p&gt;

&lt;p&gt;但是如果沒辦法使用jpa時(通常會換成 JdbcTemplate)，而且又使用到許多特定資料庫特有的功能時，就會採用 dbunit + rollback base的測試，這一類的測試，在測試程式的撰寫上，通常需要花比較多的心力。&lt;/p&gt;

&lt;h4 id=&quot;web-test&quot;&gt;Web Test&lt;/h4&gt;

&lt;p&gt;web test，spring 本來就有提供 MockMvc 的 mock object，4.x 版後以的 spring mvc test 都改用 fluent api 來寫測試了。&lt;/p&gt;

&lt;h4 id=&quot;spring-boot-application-test&quot;&gt;Spring Boot Application Test&lt;/h4&gt;

&lt;h4 id=&quot;unsorted&quot;&gt;unsorted&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;~~在專案中所有的 classes 都會被 &lt;code&gt;@ComponentScan&lt;/code&gt; 掃描~~ ﹣》 只有base package&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 30 May 2014 12:44:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//spring/spring-boot/2014/05/30/spring-boot-101.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//spring/spring-boot/2014/05/30/spring-boot-101.html</guid>
        
        
        <category>spring</category>
        
        <category>spring-boot</category>
        
      </item>
    
      <item>
        <title>Java 8 lambda</title>
        <description>&lt;h1 class=&quot;no_toc&quot; id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#functional-interface&quot;&gt;functional interface&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#lambda-expression&quot;&gt;lambda expression&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#lambda-expression-1&quot;&gt;lambda expression常見的參數為&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#resource&quot;&gt;RESOURCE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;基本語法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        (parameters) -&amp;gt; expression
    or
        (parameters) -&amp;gt; { statements; }
 
    (parameters) -&amp;gt; expression
    (x, y) -&amp;gt; x + y;    // 計算 x + y 的結果
    (String name) -&amp;gt; System.out.println(&quot;Hi! &quot; + name); 

    (parameters) -&amp;gt; { statements; }
    x -&amp;gt; { x + 1; x + 2; x + 3; return x; } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;參數的型別如果沒有指定的，會進行類型推斷(type infer)&lt;/p&gt;

&lt;h4 id=&quot;functional-interface&quot;&gt;functional interface&lt;/h4&gt;
&lt;p&gt;只有定義一個抽象方法的interface叫”functional interface”，functional interface主要的用途是做 lambda expression.&lt;/p&gt;

&lt;p&gt;在對lambda的使用還不熟悉時，可以先用anonymous class來一步一步轉換成lambda&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    // Stream裡filter method的宣告，filter method需要傳入一個Predicate的interface
    public interface Stream&amp;lt;T&amp;gt; extends BaseStream&amp;lt;T, Stream&amp;lt;T&amp;gt;&amp;gt; {
        Stream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate);
    }    
     
    // Predicate主要是透過test這個method來解決結果是true，或false 
    @FunctionalInterface
    public interface Predicate&amp;lt;T&amp;gt; {
        /**
         * Evaluates this predicate on the given argument.
         *
         * @param t the input argument
         * @return {@code true} if the input argument matches the predicate,
         * otherwise {@code false}
         */
        boolean test(T t);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sample:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
    
        // 先用anonymous實作，這邊就可以看出來，如果Predicate有超過一個的abstract method，
        Predicate&amp;lt;Integer&amp;gt; predicate = new Predicate&amp;lt;Integer&amp;gt;() {
            @Override
            public boolean test(Integer i) {
                return i &amp;gt; 3;
            }
        };
    
        // 執行後，results會只包含list中大於3的數，所以為4,5這兩個數字    
        List&amp;lt;Integer&amp;gt; results = list.stream().filter(predicate).collect(Collectors.toList());
    
        // 傳成lambda時，因為Predicate是function interface，只有一個abstract method，
        // 所以，我們可以很清楚的知道，我們要實作的method是`public boolean test(Integer i)`
        // 傳入的參數為Integer, 而實作的logic為判斷參數是否大於3
        Predicate&amp;lt;Integer&amp;gt; predicate = (Integer i) -&amp;gt; {return i &amp;gt; 3;};
        
        // java8的compier類型推斷(type infer)能力變強了，可以compiler可以由程式的上下文(context)猜出正確的型別，
        // lambda expression可以再簡化如下
        Predicate&amp;lt;Integer&amp;gt; predicate = (i) -&amp;gt; {return i &amp;gt; 3;};
        
        // 再把冗餘的括號點去掉，lambda expression預設會return最後一行的值，所以，return也可以去掉    
        Predicate&amp;lt;Integer&amp;gt; predicate = i -&amp;gt; i &amp;gt; 3;
    
        // 在filter中套上predicate
        List&amp;lt;Integer&amp;gt; results = list.stream().filter(predicate).collect(Collectors.toList());

        // 對predicate執行 inline variable的refactory
        List&amp;lt;Integer&amp;gt; results = list.stream().filter(i -&amp;gt; i &amp;gt; 3).collect(Collectors.toList());

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Predicate中，還有幾個default method，主要是用來輔助Predicate的使用，例如我們想取出上面相反的結果(不是大於3的值)，&lt;br /&gt;
直覺的方式，就是判斷的邏輯 &lt;code&gt;i&amp;gt;3&lt;/code&gt; 改寫成 &lt;code&gt;!(i &amp;gt; 3)&lt;/code&gt;，而Predicate.negate()這個default method就是在做這件事&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        Predicate&amp;lt;Integer&amp;gt; predicate = i -&amp;gt; i &amp;gt; 3;  // 先把lambda express從filter method中extract出來
        Predicate&amp;lt;Integer&amp;gt; negate = predicate.negate(); // 取反向的值 
        List&amp;lt;Integer&amp;gt; results = list.stream().filter(negate).collect(Collectors.toList()); // 得到的results為 1, 2, 3

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，我們用&lt;code&gt;predicate.negate()&lt;/code&gt;就不用直接改寫原來的邏輯，只要直接對predicate做negate的運算即可。&lt;/p&gt;

&lt;p&gt;Predicate還有幾個default methods都是在做Predicate運算時常會用到的，功用跟&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Predicates.html&quot;&gt;guava lib中的Predicats&lt;/a&gt;類型，&lt;br /&gt;
Predicate function interface 的完整程式如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        @FunctionalInterface
        public interface Predicate&amp;lt;T&amp;gt; {
            boolean test(T t);
    
            default Predicate&amp;lt;T&amp;gt; and(Predicate&amp;lt;? super T&amp;gt; other) {
                Objects.requireNonNull(other);
                return (t) -&amp;gt; test(t) &amp;amp;&amp;amp; other.test(t);
            }
    
            default Predicate&amp;lt;T&amp;gt; negate() {
                return (t) -&amp;gt; !test(t);
            }
    
            default Predicate&amp;lt;T&amp;gt; or(Predicate&amp;lt;? super T&amp;gt; other) {
                Objects.requireNonNull(other);
                return (t) -&amp;gt; test(t) || other.test(t);
            }
            static &amp;lt;T&amp;gt; Predicate&amp;lt;T&amp;gt; isEqual(Object targetRef) {
                return (null == targetRef)
                        ? Objects::isNull
                        : object -&amp;gt; targetRef.equals(object);
            }
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;lambda-expression&quot;&gt;lambda expression&lt;/h4&gt;
&lt;p&gt;A lambda expression is an instance of a functional interface&lt;/p&gt;

&lt;h4 id=&quot;lambda-expression-1&quot;&gt;lambda expression常見的參數為&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Predicate：接受一個參數，對參數做評估後返回一個boolean的值 &lt;br /&gt;
ex: 過濾條件時，傳入過濾條件的參數，如果成立(true) 就進行過濾&lt;/li&gt;
  &lt;li&gt;Function：接受一個參數並產出結果&lt;br /&gt;
ex: 輸入字串，返回數字&lt;/li&gt;
  &lt;li&gt;Supplier：不接受参數，並返回結果&lt;br /&gt;
ex: 對stream中的元素計算後產生資料&lt;/li&gt;
  &lt;li&gt;Consumer：接受一個參數，但不返回結果(返回void)&lt;br /&gt;
ex: 經function運算後，影響輸入的結果(副作用)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的class都是零元或一元運算子，還有二元運算子，功能類似，差異之處是在都是接受兩個參數&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BiConsumer&lt;/li&gt;
  &lt;li&gt;BiFunction&lt;/li&gt;
  &lt;li&gt;BiPredicate&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;resource&quot;&gt;RESOURCE&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.techempower.com/blog/2013/03/26/everything-about-java-8/&quot;&gt;http://www.techempower.com/blog/2013/03/26/everything-about-java-8/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://winterbe.com/posts/2014/03/16/java-8-tutorial/&quot;&gt;http://winterbe.com/posts/2014/03/16/java-8-tutorial/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html&quot;&gt;http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html&lt;/a&gt; - reduce  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html&quot;&gt;http://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html&lt;/a&gt; - Java 8 中的 Streams API 详解&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 14 Mar 2014 12:47:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//java8/lambda/clojure/functional%20programming/2014/03/14/java-8-lambda.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//java8/lambda/clojure/functional%20programming/2014/03/14/java-8-lambda.html</guid>
        
        
        <category>java8</category>
        
        <category>lambda</category>
        
        <category>clojure</category>
        
        <category>functional programming</category>
        
      </item>
    
      <item>
        <title>Java 8 好用工具箱</title>
        <description>&lt;p&gt;java 8 多了不少好用的工具類class，例如: 字串處理，null處理…之前透常是透過&lt;a href=&quot;https://code.google.com/p/guava-libraries/&quot;&gt;google guava&lt;/a&gt;，或&lt;a href=&quot;http://commons.apache.org/proper/commons-lang/&quot;&gt;apache common lang&lt;/a&gt;來處理，現在java 8 就有內建了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://download.java.net/jdk8/docs/api/java/util/Optional.html&quot;&gt;Optional&lt;/a&gt; 更安全、方便處理NULL的物件&lt;/li&gt;
  &lt;li&gt;Objects&lt;/li&gt;
  &lt;li&gt;StringJoin&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;objects&quot;&gt;Objects&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;requireNonNull(T obj) 如果傳入的obj為空，會丟出&lt;code&gt; NullPointerException&lt;/code&gt;異常&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 14 Mar 2014 12:43:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//java8/2014/03/14/java-8-utility-object.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//java8/2014/03/14/java-8-utility-object.html</guid>
        
        
        <category>java8</category>
        
      </item>
    
      <item>
        <title>Java 8 時間、日期 API</title>
        <description>&lt;h1 class=&quot;no_toc&quot; id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#resource&quot;&gt;Resource&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;在做java 8 time轉換傳統的 java.util.Date時，要記住一個大原則，就是java 8的 LocalXXX是沒時區的，所以，要想辦法補上時區之後，之後再轉成Instant，就很容易轉換到Date(雖然整個過程實在說不上&lt;strong&gt;容易&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Date -&amp;gt; LocalDate&lt;/li&gt;
  &lt;li&gt;Date -&amp;gt; LocalTime&lt;/li&gt;
  &lt;li&gt;Date -&amp;gt; LocalDateTime &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    // 先轉成 Instant
    Instant instant = new Date().toInstant();
    // LocalDateTime 有提供 ofInstant 的factory method
    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());  //2014-06-06T00:41:19.550 
    // LocalDate,LocalTime 沒有提供 ofInstant，需先轉成 LocalDateTime 後再 toLocalDate() 或 toLocalTime()
    LocalDate localDate  = localDateTime.toLocalDate(); //00:41:19.550
    LocalTime localTime = localDateTime.toLocalTime(); //2014-06-06

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;LocalDate -&amp;gt; Date&lt;/li&gt;
  &lt;li&gt;LocalTime -&amp;gt; Date&lt;/li&gt;
  &lt;li&gt;LocalDateTime -&amp;gt; Date&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    LocalDateTime localDateTime = LocalDateTime.now();
    Instant instant = localDateTime.toInstant(ZoneOffset.UTC);
    Date date = Date.from(instant);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;日期格式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;)); //2014-06-06 00:52

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LocalDateTime 是沒有時區資訊的，所以，如果要轉成 epoch (unix time)，就必需要加入時區資訊，沒有加入時區，就無法直接轉換。&lt;/p&gt;

&lt;p&gt;LocalDateTime 對人來說，是使用上比較直覺的，不管在世界上任何一個地方 ‘2014-1-1 12:00:00’ 都是指2014年第一天的中午12點，不用去管時區，但，如果把這個時間轉成格林威治時間(GMT)，或世界協調時間(UTC)，就必需加上時區的資料，才會正確，美國紐約的 ‘2014-1-1 12:00:00’跟台灣的’2014-1-1 12:00:00’, 一定是不一樣的，美國紐約是GMT - 4:00，台灣是GMT + 8:00&lt;/p&gt;

&lt;p&gt;java的 getMillis() 的是採 unix timesamp(epoch)的設計，所以，如果要轉成 MILL&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.computerhope.com/jargon/e/epoch.htm&quot;&gt;epoch&lt;/a&gt;通常是指從1970/1/1 開始增加至今的秒數，最多可到2038-1-19 03:14:07 (32位元有號數最大值: 2,147,483,647)&lt;br /&gt;
&lt;img src=&quot;http://en.wikipedia.org/wiki/Year_2038_problem#mediaviewer/File:Year_2038_problem.gif&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;resource&quot;&gt;Resource&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/datetime/iso/legacy.html&quot;&gt;http://docs.oracle.com/javase/tutorial/datetime/iso/legacy.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 14 Mar 2014 12:35:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//2014/03/14/java-8-date-and-time-api.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//2014/03/14/java-8-date-and-time-api.html</guid>
        
        
      </item>
    
      <item>
        <title>UMLet Sequence Diagram</title>
        <description>&lt;h1 class=&quot;no_toc&quot; id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#life-cycle&quot;&gt;Life Cycle&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#message&quot;&gt;Message&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#interaction-fragment&quot;&gt;Interaction Fragment&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#resource&quot;&gt;Resource&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.kent-chiu.com/images/2014-05-14/umlet-sequence-diagram_001.jpg&quot; alt=&quot;img_001&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;title: sample
_alpha:A~id1_|_beta:B~id2_|_gamma:G~id3_
id1-&amp;gt;&amp;gt;id2:id1,id2
id2-/&amp;gt;id1:async Msg.
id3-&amp;gt;&amp;gt;&amp;gt;id1:id1,id3
id1.&amp;gt;id3:id1,id3:async return Msg
id1-&amp;gt;id1:id1:self
// this comment will not be render
iframe{:interaction frame
id2-&amp;gt;id3:id1,id3:async Msg.
iframe}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;title&lt;/code&gt; : 圖左上方的標題&lt;/p&gt;

&lt;h2 id=&quot;life-cycle&quot;&gt;Life Cycle&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;_alpha:A~id1_&lt;/code&gt; : alpha 是instance name, A: 是class name, id1 是識別用的id，用來當作其他圖示的reference，加上 &lt;code&gt;_&lt;/code&gt; 則會出現下畫線&lt;/p&gt;

&lt;h2 id=&quot;message&quot;&gt;Message&lt;/h2&gt;

&lt;p&gt;訊息流向的基本格式為: &lt;code&gt;line:active:name&lt;/code&gt; ，可以分成三段&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;第一段是訊息的線條&lt;br /&gt;
訊息的線條又可分為&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; 同步，空心箭頭&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;-/&amp;gt;&lt;/code&gt; 非同步，單邊箭頭&lt;/li&gt;
      &lt;li&gt;’-»&amp;gt;’ 同步，實心箭頭&lt;/li&gt;
      &lt;li&gt;’.&amp;gt;’ 非同步，虛線&lt;/li&gt;
      &lt;li&gt;’-&amp;gt;’ 同步&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二段是訊息是否活動中&lt;br /&gt;
如果是活動中的訊息，會出現 execution specification (或者是 activation) &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第三段是訊息的名稱，可省略&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ex:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;id1-&amp;gt;&amp;gt;id2:id1,id2&lt;/code&gt; :  &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; 表示同步訊息，從id1到id2&lt;br /&gt;
&lt;code&gt;id2-/&amp;gt;id1:async Msg&lt;/code&gt; : &lt;code&gt;-/&amp;gt;&lt;/code&gt; 表示非同步訊息，&lt;code&gt;async Msg&lt;/code&gt;是訊息名稱&lt;br /&gt;
&lt;code&gt;3-&amp;gt;&amp;gt;&amp;gt;1:1,3 &lt;/code&gt; : &lt;code&gt;-&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 表示&lt;/p&gt;

&lt;h2 id=&quot;interaction-fragment&quot;&gt;Interaction Fragment&lt;/h2&gt;
&lt;p&gt;在 iframe 包來的範圍是 interaction fragment &lt;/p&gt;

&lt;h2 id=&quot;resource&quot;&gt;Resource&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.uml-diagrams.org/sequence-diagrams.html&quot;&gt;http://www.uml-diagrams.org/sequence-diagrams.html&lt;/a&gt; uml圖示說明&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 14 Mar 2014 12:05:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//uml/umlet/sequence_diagram/2014/03/14/umlet-sequence-diagram.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//uml/umlet/sequence_diagram/2014/03/14/umlet-sequence-diagram.html</guid>
        
        
        <category>uml</category>
        
        <category>umlet</category>
        
        <category>sequence_diagram</category>
        
      </item>
    
      <item>
        <title>Python type hint in IDEA</title>
        <description>&lt;h1 class=&quot;no_toc&quot; id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#idea-type-hinting-&quot;&gt;IDEA 建議的type hinting 語法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#resource&quot;&gt;Resource&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;在現代的IDE中，程式碼自動完成(code assist or code complete)幾乎是必備的基本功能，這個功能在靜態功能型別的語言中，IDE通常可以很完全的運作；但是在動態型別的語言中，就常常沒辦法推斷出正確的型別了。&lt;br /&gt;
因為有的IDE從另外從程式碼外的其它地方(通常是註解)加入協助IDE做類型推斷(type infer)的動作。&lt;/p&gt;

&lt;p&gt;IDEA的python plugin(或 pycharm)也是使用註解的做type hint來協助IDEA做類型推斷。如果是使用python3開發，那麼還可以用&lt;a href=&quot;http://www.python.org/dev/peps/pep-3107/&quot;&gt;PEP-3107&lt;/a&gt;。&lt;br /&gt;
&lt;em&gt;PEP-3107&lt;/em&gt;在語言的級別上加入了參數跟傳回值的型別，這樣IDE就有辦法做類型的推斷。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 未採用PEP-3107的method宣告方式
def a_method(foo, bar) :
	return foobar;

# 採用PEP-3107的method宣告方式
def a_method(foo : TypeFoo, bar: TypeBar) -&amp;gt; TypeFooBar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeFoo是參數foo的型別，TypeBar是參數bar的型別，而TypeFooBar則是 return value foobar的型別&lt;/p&gt;

&lt;p&gt;但是以下幾種狀況是&lt;em&gt;PEP-3107&lt;/em&gt;無法處理的:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;locale variable，如果 locale variable不是某個method的傳回值，那就沒有型別&lt;/li&gt;
  &lt;li&gt;field ，field也沒有型別&lt;/li&gt;
  &lt;li&gt;third party的lib，third party的lib寫法可能不是採用&lt;em&gt;PEP-3107&lt;/em&gt;方式，所以ide也無法提供code complete&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;計對這些狀況，可以用一開始提到的方式，套用特定的註解來協助IDE做類型推斷。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r = praw.Reddit(user_agent=&#39;User-Agent: rbot/1.0 by draculacwg&#39;)
&#39;&#39;&#39;:type: six.Subreddit &#39;&#39;&#39; 
subreddit = r.get_subreddit(subreddits)
submissions = subreddit.get_new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原來的&lt;code&gt;subreddit.get_new()&lt;/code&gt;，原本沒有code complete，加入&lt;code&gt;&#39;&#39;&#39;:type: six.Subreddit &#39;&#39;&#39;&lt;/code&gt; 後，就會有code complete了&lt;/p&gt;

&lt;h4 id=&quot;idea-type-hinting-&quot;&gt;IDEA 建議的type hinting 語法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Foo # Class Foo visible in the current scope&lt;/li&gt;
  &lt;li&gt;x.y.Bar # Class Bar from x.y module&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Foo&lt;/td&gt;
          &lt;td&gt;Bar # Foo or Bar&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;(Foo, Bar) # Tuple of Foo and Bar&lt;/li&gt;
  &lt;li&gt;list[Foo] # List of Foo elements&lt;/li&gt;
  &lt;li&gt;dict[Foo, Bar] # Dict from Foo to Bar&lt;/li&gt;
  &lt;li&gt;T # Generic type (T-Z are reserved for generics)&lt;/li&gt;
  &lt;li&gt;T &amp;lt;= Foo # Generic type with upper bound Foo&lt;/li&gt;
  &lt;li&gt;Foo[T] # Foo parameterized with T&lt;/li&gt;
  &lt;li&gt;(Foo, Bar) -&amp;gt; Baz # Function of Foo and Bar that returns Baz&lt;/li&gt;
  &lt;li&gt;list[dict[str, datetime]] # List of dicts from str to datetime (nested arguments)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;resource&quot;&gt;Resource&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jetbrains.com/pycharm/webhelp/type-hinting-in-pycharm.html&quot;&gt;http://www.jetbrains.com/pycharm/webhelp/type-hinting-in-pycharm.html&lt;/a&gt; - pycharm 或 IDEA python plugin中 type hint的方式&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0257/&quot;&gt;http://www.python.org/dev/peps/pep-0257/&lt;/a&gt; - PEP 257  : Docstring Conventions&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-3107/&quot;&gt;http://www.python.org/dev/peps/pep-3107/&lt;/a&gt; - PEP 3107 : python 3 中可用的類型註解&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 28 Dec 2013 12:09:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//idea/python/2013/12/28/python-type-hint-in-idea.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//idea/python/2013/12/28/python-type-hint-in-idea.html</guid>
        
        
        <category>idea</category>
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>“Mac開發環境設定”</title>
        <description>&lt;h1 class=&quot;no_toc&quot; id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;環境變數&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#eclipsejdk-jdk-7-only&quot;&gt;Eclipse找不到jdk (JDK 7 only)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;mac os重裝，重裝後開發需要用到的工具及相關設定方式如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JDK 1.8&lt;/li&gt;
  &lt;li&gt;Apache Maven 3.2.1&lt;/li&gt;
  &lt;li&gt;ruby&lt;/li&gt;
  &lt;li&gt;python&lt;/li&gt;
  &lt;li&gt;homebrew&lt;/li&gt;
  &lt;li&gt;octopress&lt;/li&gt;
  &lt;li&gt;postgresql&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;環境變數&lt;/h2&gt;
&lt;p&gt;設定環境變數可以在&lt;code&gt;.bashrc&lt;/code&gt;跟&lt;code&gt;.bashfile&lt;/code&gt;, &lt;br /&gt;
為了保證不管透過遠端登入或在登入後另外開shell都會執行設定環境的動作，可以在&lt;code&gt;.bashfile&lt;/code&gt;加入環境變數的設定，&lt;br /&gt;
但linux下的習慣以’.bashrc’為主，因為在linux環境下，反而是’.bashrc’會保證被執行到&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vi ~/.bash_profile&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function setjdk() {
  if [ $# -ne 0 ]; then
   removeFromPath &#39;/System/Library/Frameworks/JavaVM.framework/Home/bin&#39;
   if [ -n &quot;${JAVA_HOME+x}&quot; ]; then
    removeFromPath $JAVA_HOME
   fi
   export JAVA_HOME=`/usr/libexec/java_home -v $@`
   export PATH=$JAVA_HOME/bin:$PATH
  fi
 }
 function removeFromPath() {
  export PATH=$(echo $PATH | sed -E -e &quot;s;:$1;;&quot; -e &quot;s;$1:?;;&quot;)
 }
setjdk 1.8

export MAVEN_HOME=/Users/kent/dev/apache-maven-3.2.1
export M2_HOME=$MAVEN_HOME
export CATALINA_HOME=/Users/kent/dev/apache-tomcat-8.0.5
export GRADLE_HOME=/Users/kent/dev/gradle-1.10

export PATH=$MAVEN_HOME/bin:$GRADLE_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成後，記得執行一下 &lt;code&gt;source ~/.bash_profile&lt;/code&gt;看看有沒有錯誤，然後便可以&lt;code&gt;echo $JAVA_HOME&lt;/code&gt;看看java的部徑有沒有設定進去，&lt;br /&gt;
如果都ok，可以執行一下&lt;code&gt;java -version&lt;/code&gt; 跟 ‘mvn -v’看一下java跟maven的版號&lt;/p&gt;

&lt;h4 id=&quot;eclipsejdk-jdk-7-only&quot;&gt;Eclipse找不到jdk (JDK 7 only)&lt;/h4&gt;
&lt;p&gt;Oracle沒有定義jvm 1.7的相容性，所以在gui環境eclipse會找不到jdk&lt;br /&gt;
解決的方式如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# COPYjdk7的Info.plist出來修改
cp /Library/Java/JavaVirtualMachines/jdk.1.7.&amp;lt;…&amp;gt;/Contents/Info.plist ~/Downloads/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Info.plist&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;key&amp;gt;JVMCapabilities&amp;lt;/key&amp;gt;
 &amp;lt;array&amp;gt;
  &amp;lt;string&amp;gt;CommandLine&amp;lt;/string&amp;gt;
 &amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;key&amp;gt;JVMCapabilities&amp;lt;/key&amp;gt;
 &amp;lt;array&amp;gt;
  &amp;lt;string&amp;gt;JNI&amp;lt;/string&amp;gt;
  &amp;lt;string&amp;gt;BundledApp&amp;lt;/string&amp;gt;
  &amp;lt;string&amp;gt;WebStart&amp;lt;/string&amp;gt;
  &amp;lt;string&amp;gt;Applets&amp;lt;/string&amp;gt;
  &amp;lt;string&amp;gt;CommandLine&amp;lt;/string&amp;gt;
 &amp;lt;/array&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之後再copy回去原來的地上，改完需重新登入或重開機，之後eclipse便可以執行了	 &lt;/p&gt;

</description>
        <pubDate>Sat, 28 Dec 2013 12:09:00 +0800</pubDate>
        <link>http://blog.kent-chiu.com//mac/2013/12/28/mac-dev-setup.html</link>
        <guid isPermaLink="true">http://blog.kent-chiu.com//mac/2013/12/28/mac-dev-setup.html</guid>
        
        
        <category>mac</category>
        
      </item>
    
  </channel>
</rss>
