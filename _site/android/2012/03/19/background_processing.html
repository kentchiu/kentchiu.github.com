<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Android 背景作業處理</title>
  <meta name="description" content="Table of contents">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://blog.kent-chiu.com//android/2012/03/19/background_processing.html">
  <link rel="alternate" type="application/atom+xml" title="Kent's Blog" href="http://blog.kent-chiu.com//feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Kent's Blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Android 背景作業處理</h1>
    <p class="post-meta">Mar 19, 2012 • Kent Chiu</p>
  </header>

  <article class="post-content">
    <h1 class="no_toc" id="table-of-contents">Table of contents</h1>

<ul id="markdown-toc">
  <li><a href="#thread">Thread</a>    <ul>
      <li><a href="#handler">Handler</a></li>
      <li><a href="#ui-thread-vs-worker-threads">UI Thread V.S Worker Threads</a>        <ul>
          <li><a href="#ui-threadmain-thread">UI Thread(Main Thread)</a></li>
          <li><a href="#worker-threadsbackgroud-threads">Worker Threads(Backgroud Threads)</a></li>
        </ul>
      </li>
      <li><a href="#ui-threadworker-threads">UI Thread與Worker Threads間的通訊</a></li>
      <li><a href="#handlerthread">HandlerThread</a></li>
    </ul>
  </li>
  <li><a href="#asynctask">AsyncTask</a>    <ul>
      <li><a href="#status">Status</a></li>
      <li><a href="#section">大型檔案下載</a></li>
    </ul>
  </li>
  <li><a href="#process-lifecycle">Process lifecycle</a></li>
  <li><a href="#section-1">陷阱</a></li>
  <li><a href="#http-service">Http Service</a></li>
  <li><a href="#resource">Resource</a></li>
</ul>

<hr />

<p>Android的背景作業主要有三種</p>

<ol>
  <li>Thread
    <ul>
      <li>HandlerThread</li>
    </ul>
  </li>
  <li>AsyncTask</li>
  <li>Handler</li>
</ol>

<p>後兩者可以做的事情差不多，Handler使用上比較簡單，但code的可讀性比較差，AsyncTask需另外subclass一個新的類別，但可讀性比較好。</p>

<p>Android的操作，只要超過5秒沒回應(或OnCreate()超過10秒)，程式就會被當作無回應，而系統會丟出ANR(Application<br />
No Response<br />
Exception)。所以，比較耗時費工的動作，都應該考慮用背景作業的方式來完成。常見耗時的工作有。</p>

<ol>
  <li>網路相關的動作</li>
  <li>資料庫的動作</li>
  <li>檔案操作</li>
  <li>複雜的計算</li>
</ol>

<p>在設計時，應該考慮較糟的情況，而不是開發者當時的環境</p>

<h2 id="thread">Thread</h2>

<p>Thread跟典型的java<br />
thread一樣，最簡單的背景服務執行方式，只要跟UI無關，用這個最方便。</p>

<pre><code>new Thread(new Runnable(){
    @Override
    public void run() {
        // long run job
    }
 
}).start();

</code></pre>

<h3 id="handler">Handler</h3>

<p>Handler是一種跨thread的溝通機制，可以在一個thread內把訊息丟到Message<br />
Queue，另外一個thread接收訊息，它會跟特定的thread關聯，可以在thread裡可以透過handler向meassage<br />
queue送訊息，也可以從message queue收訊息。 收訊息是由message<br />
queue主動呼叫handle的callback message<br />
<a href="http://developer.android.com/reference/android/os/Handler.html#hasMessages(int)" title="http://developer.android.com/reference/android/os/Handler.html#hasMessages(int)">Handler.handleMessage()</a></p>

<p><img src="http://blog.kent-chiu.com/images/2012-03-19/background_processing_002.png" alt="background_processing_002.png" /></p>

<p>Thread類別中，並沒有thread執行完成的通知機制，如果想讓thread做完事情後進行通知的動作，那就必須透過handler的訊息發送機制，在thread做完事後，送訊息至訊息佇列。<br />
這樣，想知道這個thread完成的事件的，就可以去訊息佇列接收完成的通知訊息。</p>

<p>thread在start()後，會在建立一個thread來執行run() method，可以在run<br />
method裡的主要工作做完後，用<br />
handler的sendEmptyMessage()，傳送一個任務完成的訊息到訊息佇列。</p>

<pre><code>new Thread() {
    public void run() {
        // Download image then continue
        // For Example: downloadImg("file");
        handler.sendEmptyMessage(MSG_DOWNLOADED); // public static final int MSG_DOWNLOADED = 0
    }
}.start();

</code></pre>

<pre><code>private Handler handler = new Handler() {
 
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case MSG_DOWNLOADED:
                pd.dismiss();
                // What to do when ready, example:
                openFile();
                break;
            }
        }
    };

</code></pre>

<p>如果想知道thread是否完成，只需要透過handler的handleMessage這個call back<br />
method來接收任務完成的訊息即可。</p>

<p>Handler是透過<a href="http://developer.android.com/reference/android/os/Handler.html#sendMessage(android.os.Message)" title="http://developer.android.com/reference/android/os/Handler.html#sendMessage(android.os.Message)">sendMessage()</a>傳送訊息給message<br />
queue，<br />
傳送的訊息可以是<a href="http://developer.android.com/reference/android/os/Message.html" title="http://developer.android.com/reference/android/os/Message.html">Message</a>的物件，但Handler跟Message關係是雙向的，也就是Handler可以傳送Message,<br />
Message中也包含傳送者<br />
Handler，所以，要產生Message時，應該透過<a href="http://developer.android.com/reference/android/os/Handler.html#obtainMessage()" title="http://developer.android.com/reference/android/os/Handler.html#obtainMessage()">Handler.obtainMessage()</a>，這樣可以確保<br />
Handler系Message間的關聯的正確性。</p>

<h3 id="ui-thread-vs-worker-threads">UI Thread V.S Worker Threads</h3>

<h5 id="ui-threadmain-thread">UI Thread(Main Thread)</h5>

<p>和UI有關的任何更新及操作，都需要在UI thread完成，一般就是 Main<br />
thread。如果UI<br />
thread太久沒回應，就會出現ANR，所以要避免ANR就需要在其他的Thread處理比較耗時的動作。</p>

<p>系統啟動一個應該程式時，預設的情況下，所有元件的所有的動作都是在main<br />
thread(UI<br />
Thread)完成的，而當元件引發系統的callback(像是onKeyDown())時，也都會在UI<br />
Thread中。</p>

<p>關於UI Thread有兩個主要的規則要遵守</p>

<ol>
  <li>不要把UI thread給block住</li>
  <li>不要在UI toolkit之外存取UI Thread</li>
</ol>

<h5 id="worker-threadsbackgroud-threads">Worker Threads(Backgroud Threads)</h5>

<pre><code>public void onClick(View v) {
    new Thread(new Runnable() {
        public void run() {
            Bitmap b = loadImageFromNetwork("http://example.com/image.png");
            mImageView.setImageBitmap(b);
        }
    }).start();
}

</code></pre>

<p>上面是一個Worker<br />
Thread的簡單例子，<code>loadImageFromNetwork()</code>的部份沒有問題，但是<code>mImageView.setImageBitmap(b)</code>違反了UI<br />
Thread的第二個規則 : <strong>不要在UI toolkit之外存取UI Thread</strong></p>

<p>但是，有時，我們又希望在新開出來的Thread也可以把更新ui上的資訊，比如說，我們播放歌曲是在一個新的thread，但又希望歌曲播放的同時，能夠將播放的進度同步在進度條(Progress<br />
Bar).根據最基本的大原則:<strong>和UI有關的任何更新及操作，都需要在UI<br />
thread完成</strong>，在播放歌曲的thread是不能操作ui的動作的。</p>

<h3 id="ui-threadworker-threads">UI Thread與Worker Threads間的通訊</h3>

<p>Android處理上面的問題的機制是Handler來處理，故有三種方式可以使用</p>

<ol>
  <li>Activity.runOnUiThread(Runnable)</li>
  <li>View.post(Runnable)</li>
  <li>View.postDelayed(Runnable, long)</li>
</ol>

<p>上面三種方式，<strong>底層都還是透過Handle的post()實作</strong></p>

<pre><code>        private final Handler mHandler = new Handler();
     
        public final void runOnUiThread(Runnable action) {
            if (Thread.currentThread() != mUiThread) {
                mHandler.post(action);
            } else {
                action.run();
            }
        }

</code></pre>

<pre><code>        public boolean post(Runnable action) {
            Handler handler;
            if (mAttachInfo != null) {
                handler = mAttachInfo.mHandler;
            } else {
                // Assume that post will succeed later
                ViewRoot.getRunQueue().post(action);
                return true;
            }
     
            return handler.post(action);
        }

</code></pre>

<pre><code>        public boolean postDelayed(Runnable action, long delayMillis) {
            Handler handler;
            if (mAttachInfo != null) {
                handler = mAttachInfo.mHandler;
            } else {
                // Assume that post will succeed later
                ViewRoot.getRunQueue().postDelayed(action, delayMillis);
                return true;
            }
     
            return handler.postDelayed(action, delayMillis);
        }

</code></pre>

<p>我們將原來有問題的code改用View.post(Runnable)的方式來實作</p>

<pre><code>public void onClick(View v) {
    new Thread(new Runnable() {  // download是耗時的動作，在另外建立一個thread來執行，所以，下一行的run()，這在個thread.start()後，會在另一個thread(worker thread)執行
        public void run() {
            final Bitmap bitmap = loadImageFromNetwork("http://example.com/image.png");
            mImageView.post(new Runnable() {  // -&gt; 利用ui元件進行post，下面那行的run會執行在ui元件所使用的thread上(Main Thread)
                public void run() {
                    mImageView.setImageBitmap(bitmap);
                }
            });
        }
    }).start();
}

</code></pre>

<p>這樣做後，上面的操作就是thread-safe的。</p>

<p>注意，上面的code為什麼會有兩個run()，因為，handler的post()<strong>並不會</strong>建立新的thread，而是在呼叫post的thread上thread上執行，所以，我們可以透過view元件的handler來進行post，以確保post裡面的run()<br />
code是在view元件的thread(Main Thread)上做ui操作,<br />
但是耗時的功能，還是要另外開一個thread (worker<br />
thread)來進行，不然，會影效到main thread的效能</p>

<p>上面三個簡便的methods，最好只用在單純的情況下，如果情況比較複雜時，建議還是用獨立的<a href="#handler" title="android:background_processing ↵">Handler</a>來處理，更複雜的情況下，採用<a href="#asynctask" title="android:background_processing ↵">AsyncTask</a>或許是更適合的solution.</p>

<h3 id="handlerthread">HandlerThread</h3>

<p>Android有另外提供一個繼承自Thread類別的<a href="http://developer.android.com/reference/android/os/HandlerThread.html" title="http://developer.android.com/reference/android/os/HandlerThread.html">android.os.HandlerThread</a>類別，這個類別本身就具有Handler功能，可以透過這個類別的提供Handler與該thread進行交互(ex:送訊息，及thread執行完畢的callback)</p>

<pre><code>HandlerThread thread = new HandlerThread("myThread");  
thread.start(); // thread 要start後，才能取得looper
Handler handler = new Handler(thread.getLooper()) {
    @Override
    public void handleMessage(Message msg) {
        // 耗時的工作可以在這裡做
    }
};
handler.sendEmptyMessage(0); // handler發送的訊息，會觸發handler.handleMessage()。

</code></pre>

<h2 id="asynctask">AsyncTask</h2>

<p>AsyncTask用來在UI上執行非同步的工作，它會在worker<br />
thread執行耗時的工作後，自動將結果丟回給UI Thread。</p>

<p>採用AsyncTask的方式是繼承AsyncTask類別，將耗時的動作放在<code>doInBackground()</code>，<br />
如果要update ui，將要update ui的動作放在<code>onPostExecute()</code>,<br />
<code>onPostExecute()</code>是在UI<br />
Thread中執行的，所以<strong>可以安全的在<code>onPostExecute()</code>執行UI的操作</strong>。</p>

<pre><code>protected abstract Result doInBackground(Params... params);
 
protected void onPostExecute(Result result);

</code></pre>

<p><code>onPostExecute(Result result)</code>裡的reslut，是<code>Result doInBackground(Params… params)</code>執行後的return值，也就是說，在<code>doInBackground()</code>做完的結果，可以在<code>onPostExecute()</code>中被使用</p>

<p>實作好換AsyncTask，可以透過<code>execute(Param… params)</code>執行，下面是一個簡單的範例(取自官網)</p>

<pre><code>public void onClick(View v) {
    new DownloadImageTask().execute("http://example.com/image.png");
}
 
private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; {
    /** The system calls this to perform work in a worker thread and
      * delivers it the parameters given to AsyncTask.execute() */
    protected Bitmap doInBackground(String... urls) {
        return loadImageFromNetwork(urls[0]);
    }
 
    /** The system calls this to perform work in the UI thread and delivers
      * the result from doInBackground() */
    protected void onPostExecute(Bitmap result) {
        mImageView.setImageBitmap(result);
    }
}

</code></pre>

<p><img src="http://blog.kent-chiu.com/images/2012-03-19/background_processing_001.png" alt="background_processing_001.png" /></p>

<p>執行一個AsyncTask的方式如下，每一個instance只能被執行一次，如果被執行超過一次，會出exception</p>

<pre><code>new MyAsyncTask().execute("inputString1", "inputString2");

</code></pre>

<h5 id="status">Status</h5>

<p>另外，可透過<code>getStatus()</code>取得狀態，如果想等待AsyncTask直到結束，可透過AsyncTask.get()，呼叫後會一直等到執行結束或timeout</p>

<pre><code>public enum Status {
    /**
     * Indicates that the task has not been executed yet.
     */
    PENDING,
    /**
     * Indicates that the task is running.
     */
    RUNNING,
    /**
     * Indicates that {@link AsyncTask#onPostExecute} has finished.
     */
    FINISHED,
}

</code></pre>

<h3 id="section">大型檔案下載</h3>

<p>上面的HttpClinet可用來處理比較小的檔案，但如果要下載大檔案(MB等級),Android<br />
2.3有提供<a href="http://developer.android.com/reference/android/app/DownloadManager.html" title="http://developer.android.com/reference/android/app/DownloadManager.html">DownloadManager</a></p>

<pre><code>     DownloadManager.Request dmReq = new DownloadManager.Request( 
        Uri.parse("http://dl-ssl.google.com/android/repository/platform-tools_r01-linux.zip")); 
        dmReq.setTitle("Platform Tools"); 
        dmReq.setDescription("Download for Linux"); 
        dmReq.setAllowedNetworkTypes(DownloadManager.Request.NETWORK_WIFI); //  
     
        // 
        IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE); 
        registerReceiver(mReceiver, filter); 
     
        downloadId = dMgr.enqueue(dmReq); 

</code></pre>

<pre><code>      public BroadcastReceiver mReceiver = new BroadcastReceiver() { 
            public void onReceive(Context context, Intent intent) { 
                Bundle extras = intent.getExtras(); 
                long doneDownloadId = 
                    extras.getLong(DownloadManager.EXTRA_DOWNLOAD_ID); 
                tv.setText(tv.getText() + "\nDownload finished (" + 
                    doneDownloadId + ")"); 
                if(downloadId == doneDownloadId) 
                    Log.v(TAG, "Our download has completed."); 
            } 
        };

</code></pre>

<h2 id="process-lifecycle">Process lifecycle</h2>

<ol>
  <li>Foreground process : 有可視化元件，正與使用者互動的process</li>
  <li>Visible process : 不在Foreground<br />
process，但是會影響使用者在畫面上所見的內容(像popup一個dialog時，後面的activity就是屬於visible<br />
process)</li>
  <li>Service process : 秀過startService()啟動的process</li>
  <li>Background process : process的activity目前在stop狀態</li>
  <li>Empty process : 用在caching，主要是讓activity啟動加快</li>
</ol>

<p>GC時會由下(Empty process)往上(Foreground process)做GC。</p>

<p>比較耗時的工作，有時不是簡個的開一個thread放進去running就好了，有時啟動另一個service是更佳的解法，尤其是當該操作會拖垮activity時</p>

<h2 id="section-1">陷阱</h2>

<p><a href="#asynctask" title="android:background_processing ↵">AsyncTask</a>被android<br />
frameword限制住最大可同時執行數量了，如果需要比較多個背景作業同時執行時，可以直接使用<a href="#thread" title="android:background_processing ↵">Thread</a>，但是過多的thread反而可能會使效能更差，而且多個thread時，可能就得必需進行<br />
任務管理，關於multithreading的併行處理，可以參閱<a href="http://wiki.kent-chiu.com/doku.php?id=java:concurrency_101" title="java:concurrency_101">Concurrency<br />
101</a></p>

<p>如果是把thread相關的內容宣告成activity的內部類別，那<strong>一定要宣告成static<br />
inner class</strong>, 因為inner class如果不是static的，inner<br />
class會參考到建立它的outter class(activity),而該activity因為thread<br />
refenence著它，而不能順利的被釋放，進而造成memory leaking。</p>

<h2 id="http-service">Http Service</h2>

<p>通常，在程式裡面，需要用到背景服務的情況，都是為了非同步的從網路取資料(射後不理)，如果要透過http存取資源，請使用HttpClient<br />
這樣會減少很多不必要的麻煩。請下列出幾點HttpClient使用時的注意事項。</p>

<ol>
  <li>避免在Activity裡直接使用HttpClient因為Activity關閉後，HttpClient會隨著關閉</li>
  <li>整個應用程式，應該只需建立一份HttpClient而重覆使用(Singleton Patten)</li>
  <li>HttpClient用透過MultiThreading的方式執行，不需要特別另外建立thread給它<br />
(TBD 測一下)</li>
  <li>使用HttpClient需注意兩種timeout exceptions，其他的HttpClient會處理掉
    <ol>
      <li>Connection Timeout Exception</li>
      <li>Scoket Timeout Exception</li>
    </ol>
  </li>
  <li>HttpClient使用教學可以參閱<a href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/" title="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/">這裡</a></li>
</ol>

<p>另外Android也可以使用<a href="http://wiki.kent-chiu.com/doku.php?id=android:background_processing" title="android:background_processing">HttpURLConnection</a>跟<a href="http://wiki.kent-chiu.com/doku.php?id=android:background_processing" title="android:background_processing">AndroidHttpClient</a>，但就必須自已處理thread的部份了</p>

<pre><code>    import org.apache.http.HttpVersion; 
    import org.apache.http.client.HttpClient; 
    import org.apache.http.conn.ClientConnectionManager; 
    import org.apache.http.conn.params.ConnManagerParams; 
    import org.apache.http.conn.scheme.PlainSocketFactory; 
    import org.apache.http.conn.scheme.Scheme; 
    import org.apache.http.conn.scheme.SchemeRegistry; 
    import org.apache.http.conn.ssl.SSLSocketFactory; 
    import org.apache.http.impl.client.DefaultHttpClient; 
    import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager; 
    import org.apache.http.params.BasicHttpParams; 
    import org.apache.http.params.HttpConnectionParams; 
    import org.apache.http.params.HttpParams; 
    import org.apache.http.params.HttpProtocolParams; 
    import org.apache.http.protocol.HTTP; 
     
    public class CustomHttpClient { 
        private static HttpClient customHttpClient; 
     
        /** A private Constructor prevents instantiation */ 
        private CustomHttpClient() { 
        } 
     
        public static synchronized HttpClient getHttpClient() { 
            if (customHttpClient == null) { 
                HttpParams params = new BasicHttpParams(); 
                HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1); 
                HttpProtocolParams.setContentCharset(params, HTTP.DEFAULT_CONTENT_CHARSET); 
                HttpProtocolParams.setUseExpectContinue(params, true); 
                HttpProtocolParams.setUserAgent(params,  "Mozilla/5.0 (Linux; U; Android 2.2.1; en-us; Nexus One Build/FRG83) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1" ); 
                params.setParameter("charset", "UTF-8"); // 要設成utf-8，否則中文的utf-8網頁會出錯 
                ConnManagerParams.setTimeout(params, 1000); 
     
                HttpConnectionParams.setConnectionTimeout(params, 5000); 
                HttpConnectionParams.setSoTimeout(params, 10000); 
     
                SchemeRegistry schReg = new SchemeRegistry(); 
                schReg.register(new Scheme("http",  PlainSocketFactory.getSocketFactory(), 80)); 
                schReg.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443)); 
                ClientConnectionManager conMgr = new ThreadSafeClientConnManager(params,schReg); 
                customHttpClient = new DefaultHttpClient(conMgr, params); 
            } 
            return customHttpClient; 
        } 
    } 

</code></pre>

<p>使用方式</p>

<pre><code>    httpClient = CustomHttpClient.getHttpClient()
    try { 
        HttpGet request = new HttpGet("http://www.google.com/"); 
        String page = httpClient.execute(request, new BasicResponseHandler()); 
        System.out.println(page); 
    } catch (IOException e) { 
        // covers: 
        //      ClientProtocolException 
        //      ConnectTimeoutException 
        //      ConnectionPoolTimeoutException 
        //      SocketTimeoutException 
        e.printStackTrace(); 
        // 如果發生SocketTimeout時，可以這樣進行retry
        if (count &lt; retry) {
            // do again
        } else {
            // 
        }
    } 

</code></pre>

<h2 id="resource">Resource</h2>

<ul>
  <li>官網上跟thread相關的教學文件
    <ol>
      <li><a href="http://developer.android.com/resources/articles/painless-threading.html" title="http://developer.android.com/resources/articles/painless-threading.html">Painless<br />
Threading</a></li>
      <li><a href="http://developer.android.com/resources/articles/timed-ui-updates.html" title="http://developer.android.com/resources/articles/timed-ui-updates.html">Updating the UI from a<br />
Timer</a></li>
    </ol>
  </li>
  <li><a href="http://developer.android.com/reference/android/os/AsyncTask.html" title="http://developer.android.com/reference/android/os/AsyncTask.html">AsyncTask<br />
API</a></li>
  <li><a href="http://developer.android.com/reference/android/os/Handler.html" title="http://developer.android.com/reference/android/os/Handler.html">Handler<br />
API</a></li>
  <li><a href="http://www.vogella.de/articles/AndroidPerformance/article.html" title="http://www.vogella.de/articles/AndroidPerformance/article.html">http://www.vogella.de/articles/AndroidPerformance/article.html</a></li>
  <li><a href="http://milochen.wordpress.com/2011/03/25/understanding-android-os-src-looperhandler-message-messagequeue/" title="http://milochen.wordpress.com/2011/03/25/understanding-android-os-src-looperhandler-message-messagequeue/">http://milochen.wordpress.com/2011/03/25/understanding-android-os-src-looperhandler-message-messagequeue/</a></li>
</ul>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Kent's Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Kent's Blog</li>
          <li><a href="mailto:kent.cwg@gmail.com">kent.cwg@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/kentchiu">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">kentchiu</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/kentchiu">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">kentchiu</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Kent的學習筆記</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
