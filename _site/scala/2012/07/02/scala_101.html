<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Scala 101</title>
  <meta name="description" content="Table of contents">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://blog.kent-chiu.com//scala/2012/07/02/scala_101.html">
  <link rel="alternate" type="application/atom+xml" title="Kent's Blog" href="http://blog.kent-chiu.com//feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Kent's Blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Scala 101</h1>
    <p class="post-meta">Jul 2, 2012 • Kent Chiu</p>
  </header>

  <article class="post-content">
    <h1 class="no_toc" id="table-of-contents">Table of contents</h1>

<ul id="markdown-toc">
  <li><a href="#method">method</a></li>
  <li><a href="#foreach">foreach</a></li>
  <li><a href="#function">function</a>    <ul>
      <li><a href="#function-literal">function literal</a>        <ul>
          <li><a href="#function-return-type">function return type</a></li>
          <li><a href="#operator-notation">operator notation</a></li>
        </ul>
      </li>
      <li><a href="#functionn">functionN</a></li>
      <li><a href="#closure">closure</a>        <ul>
          <li><a href="#free-variables">free variables</a></li>
        </ul>
      </li>
      <li><a href="#constructor">Constructor</a>        <ul>
          <li><a href="#primary-constructor">primary constructor</a></li>
          <li><a href="#auxiliary-constructor">auxiliary constructor</a></li>
        </ul>
      </li>
      <li><a href="#function-parameters">function parameters</a>        <ul>
          <li><a href="#repeated-parameters">repeated parameters</a></li>
          <li><a href="#naming-parameters">naming parameters</a></li>
          <li><a href="#default-value">default value</a></li>
          <li><a href="#loop">loop</a></li>
          <li><a href="#for">for</a></li>
          <li><a href="#apply-and-update">apply() and update()</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#import-and-package">Import and Package</a>    <ul>
      <li><a href="#pacakge">pacakge</a></li>
      <li><a href="#import">import</a></li>
    </ul>
  </li>
  <li><a href="#trait">trait</a>    <ul>
      <li><a href="#ordered-trait">Ordered Trait</a></li>
    </ul>
  </li>
  <li><a href="#case-class">case class</a>    <ul>
      <li><a href="#function-programming">function programming</a></li>
    </ul>
  </li>
  <li><a href="#sequence-comprehensions">Sequence Comprehensions</a></li>
  <li><a href="#tuple">Tuple</a></li>
  <li><a href="#extractors">Extractors</a></li>
  <li><a href="#parser-combinators">Parser Combinators</a></li>
  <li><a href="#symbol-literals">Symbol Literals</a></li>
  <li><a href="#tbd">TBD</a></li>
  <li><a href="#resource">Resource</a></li>
</ul>

<hr />

<p>Scala IDE</p>

<ol>
  <li>eclipse 3.7 (indigo)</li>
  <li>scala IDE plugin 2.9</li>
  <li>jdk 1.7.03</li>
</ol>

<p>一切換到scala的環境，IDE就凍住了，用<a href="http://wiki.kent-chiu.com/doku.php?id=java:jvm_profile" title="java:jvm_profile">VirtualVM</a>觀查的結果是執行scala的vm(不是ide本身的vm)的Permanent<br />
Generation<br />
Memory爆了，把它開到256M(-XX:MaxPermSize=256m)就不會一切到scala<br />
perspective，IDE就掛掉。</p>

<pre><code>#utf8 (do not remove)
-startup
../../Common/plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar
--launcher.library
../../Common/plugins/org.eclipse.equinox.launcher.i18n.win32.win32.x86_64_4.2.0.v201201111650
-showsplash
C:\Genuitec\Common\plugins\org.eclipse.platform_3.7.2.v201202080800\splash.bmp
--launcher.XXMaxPermSize
256m
--launcher.defaultAction
openFile
-install
C:\Genuitec\Profiles\scala
-configuration
C:\Genuitec\Profiles\scala\configuration
-vmargs
-Xms256m
-Xmx1024m
-XX:MaxPermSize=256m

</code></pre>

<ul>
  <li>scala是可自我成長的語言</li>
  <li>scala混合了oo跟function lang</li>
  <li>java中的static method可以考慮用function的方式實現，statistic<br />
method可視為一種退化的function lang?</li>
  <li>scala是純oo<br />
lang，所有的東西都是物件，所有的操作(含運算子)都是method，所以，可以做運算子的override</li>
  <li>
    <p>scala可以與java無縫的整合，事實上，scala很多型號都是來自java。scala<br />
call java lib會很容易，但java call<br />
scala會有比較多的限制，因為scala的物件模型及語意比java豐富，java沒辦法一一對應。</p>
  </li>
  <li>scala有兩種變數</li>
</ul>

<ol>
  <li>expression後面的分號(;)可有可無</li>
  <li>val : 像java的final變數，一旦宣告後，就不能改變<br />
(如果重新指派，會出reassignment的error)</li>
  <li>var : 像java的non final變數，可以重新指派值</li>
</ol>

<ul>
  <li>scala的array跟java一樣是0-base但是，是透過()存取，而不是[]</li>
</ul>

<h5 id="method">method</h5>

<pre><code>def mymethod(x: Int, y: Int) : Int = {
  x + y
}

</code></pre>

<pre><code>def mymethod(x: Int, y: Int) = x + y

</code></pre>

<p>所有的運算子在scala都是method，所以<code>1 + 2</code>是這樣的method call</p>

<pre><code>(1).+(2)

</code></pre>

<p><code>1</code>是物件,<code>+</code>是method name，<code>1</code>物件透過<code>.</code>來呼叫<code>+</code>method並傳入參數值<code>2</code></p>

<p>以這樣的角度來看Array，Array就很直覺了，Array在Scala也只是一般的物件，而不是像java一樣，而不是像java一樣，是屬於語法等級的物件</p>

<h5 id="foreach">foreach</h5>

<p>for (arg ← args) println(arg)</p>

<h3 id="function">function</h3>

<h4 id="function-literal">function literal</h4>

<p>單行</p>

<pre><code>(x: Int, y: Int) =&gt; x + y 

</code></pre>

<p>多行時可以用大括號將 functio body括起來</p>

<pre><code>(x: Int, y: Int) =&gt; {
    val z = x + 1
    z + y
}

</code></pre>

<p>這邊用function literal來達到foreach的功能，function literal有三種用法</p>

<p>第一種是最囉嗦,array的item要給型別而且給了型別，外面還要配一對括號</p>

<pre><code>myarray.foreach((item: String) =&gt; println(item))

</code></pre>

<p>這個是比較正常的用法</p>

<pre><code>myarray.foreach(item =&gt; println(item))

</code></pre>

<p>超精簡的用法，但只適用於只有一個參數的狀況</p>

<pre><code>myarray.foreach(println)

</code></pre>

<h5 id="function-return-type">function return type</h5>

<p>為什麼sum function可以不用指定return type，而factorial必須指定return<br />
type為Int?</p>

<pre><code>  def sum(a:Int,b:Int) = a+b
  def factorial(n:Int):Int = if (n==0) 1 else n * factorial(n-1)

</code></pre>

<p>因為在sum function中complier可以推斷(infer)出a +<br />
b的回傳值是Int型別，但在factorial中，回傳值可能是 1<br />
或者是<code>n * factorial(n-1)</code>，<br />
而<code>n * factorial(n-1)</code>是未知型別，所以，我們必須指定return<br />
type，給complier一個提示。</p>

<p>有些語言的compiler可以由factorial function的第一個回傳值為1來推斷return<br />
type為Int，但scala的complier不行</p>

<h5 id="operator-notation">operator notation</h5>

<ol>
  <li>infix 1 + 2</li>
  <li>prefix +1,-1, !foo, \~bar (只有+,-,!,\~可以為prefix<br />
operator,定為方式為<code>unary_+</code>,<code>unary_-</code>,<code>unary_!</code>,<code>unary_~</code>,)</li>
  <li>postfix 1.toLong</li>
</ol>

<h4 id="functionn">functionN</h4>

<pre><code>package scala
 
 
trait Function2[@specialized(scala.Int, scala.Long, scala.Double) -T1, @specialized(scala.Int, scala.Long, scala.Double) -T2, @specialized(scala.Unit, scala.Boolean, scala.Int, scala.Float, scala.Long, scala.Double) +R] extends AnyRef { self =&gt;
  /** Apply the body of this function to the arguments.
   *  @return   the result of function application.
   */
  def apply(v1: T1, v2: T2): R
 
  /** Creates a curried version of this function.
   *
   *  @return   a function `f` such that `f(x1)(x2) == apply(x1, x2)`
   */
  def curried: T1 =&gt; T2 =&gt; R = {
    (x1: T1) =&gt; (x2: T2) =&gt; apply(x1, x2)
  }
  @deprecated("Use 'curried' instead", "2.8.0")
  def curry = curried
 
  /** Creates a tupled version of this function: instead of 2 arguments,
   *  it accepts a single [[scala.Tuple2]] argument.
   *
   *  @return   a function `f` such that `f((x1, x2)) == f(Tuple2(x1, x2)) == apply(x1, x2)`
   */
  def tupled: Tuple2[T1, T2] =&gt; R = {
    case Tuple2(x1, x2) =&gt; apply(x1, x2)
  }
  override def toString() = "&lt;function2&gt;"
}
 
}

</code></pre>

<p>scala中的每個function，都是實作像上面的functionN(N從0\~22)的trait，以<code>(x: Int, y: Int) ⇒ x + y </code>來說，就是上例中的Function2[-T1,<br />
-T2, +R]， 因為 (x: Int, y: Int) ⇒ x + y 就<br />
傳入兩個int的參數並傳回一個int的結果，這樣與Function2的<code>def apply(v1: T1, v2: T2): R</code>是相等的。</p>

<h4 id="closure">closure</h4>

<p>closure跟function literal語法很相似，但closure多了<a href="#free_variables" title="scala:scala_101 ↵">free<br />
variables</a>，所以，free<br />
variables可被當做區分closure跟function literal的依據</p>

<h5 id="free-variables">free variables</h5>

<p>TBC</p>

<h4 id="constructor">Constructor</h4>

<h5 id="primary-constructor">primary constructor</h5>

<pre><code>class MyClass(x: Int, y: Int)

</code></pre>

<h5 id="auxiliary-constructor">auxiliary constructor</h5>

<pre><code>class MyClass(x: Int) {
    def this(x:Int) = this(x, 1) 
}

</code></pre>

<p>在scala，只有primary constructor可以呼叫super class的Constructor</p>

<pre><code> 

</code></pre>

<h4 id="function-parameters">function parameters</h4>

<h5 id="repeated-parameters">repeated parameters</h5>

<p>repeated parameters像java的 myfunc(String…<br />
args)，後面能用0到多個相同型別的參數</p>

<pre><code>def myfunc(args: String*)

</code></pre>

<h5 id="naming-parameters">naming parameters</h5>

<p>naming<br />
parameters主要是在使用functions時可以指定參數的名稱，也因為可以指定參數的名稱，<br />
所以傳入的參數順序可以跟原來宣告時的不一樣</p>

<pre><code>def myfunc(foo: Int, bar: String)
 
// call myfunc with naming parameter
val x = myfunc(bar="test", foo=1)

</code></pre>

<h5 id="default-value">default value</h5>

<p>參數的預設值，如果沒有特別指定時，參數會以預設值為準</p>

<pre><code>def myfunc(foo: Int = 5)

</code></pre>

<h5 id="loop">loop</h5>

<p>如while 或者是 do-while loop 都是會帶有副作用(side<br />
effect)，請儘量改用其他的方式實作</p>

<h5 id="for">for</h5>

<p>for loop有filter的功能</p>

<pre><code>val filesHere = (new java.io.File(".")).listFiles
for (file &lt;- filesHere if file.getName.endsWith(".scala"))
  println(file)
 
// 上面那邊，的效果等同於  
for (file &lt;- filesHere)
  if (file.getName.endsWith(".scala"))
    println(file)  

</code></pre>

<p>filter也可以累加，像這樣</p>

<pre><code>for (
  file &lt;- filesHere
  if file.isFile
  if file.getName.endsWith(".scala")
) println(file)

</code></pre>

<h5 id="apply-and-update">apply() and update()</h5>

<dl>
  <dt><code>()</code>跟<code>()=</code>是語法糖(complier sugar)，分別等效於<code>apply()</code>跟<code>update()</code> ()</dt>
  <dd>apply() ()= : update()</dd>
</dl>

<h3 id="import-and-package">Import and Package</h3>

<h5 id="pacakge">pacakge</h5>

<ol>
  <li>可以是 java style ，把 package name 放在最上面</li>
  <li>可以是 c# like，用 com.kentchiu { <em>package content } 或 com{<br />
kentchiu {</em> package content} }</li>
  <li>_root_ package</li>
</ol>

<h5 id="import">import</h5>

<p>與 java 的不同</p>

<ol>
  <li>可以直接 import class member</li>
  <li>可以 rename 或隱藏部份被 import 的 members</li>
</ol>

<pre><code>import com.kentchiu.{Foo, Bar}        // 只 import Foo 跟 Bar
import com.kentchiu.{Foo, Bar =&gt; Baz} // 只 import Foo 跟 Bar， Bar 改名為 Baz
import com.kentchiu.{Bar =&gt; _, _}     // Bar rename 成 _ ，會變成 import com.kentchiu 但把 Bar 排外

</code></pre>

<h3 id="trait">trait</h3>

<p>Trait像是java的interface，不過，更像是ruby的mixin</p>

<h5 id="ordered-trait">Ordered Trait</h5>

<p>Ordered Trait是用來說明trait一個很好的例子，Rubyer應該對這個例子很眼熟</p>

<h3 id="case-class">case class</h3>

<h5 id="function-programming">function programming</h5>

<p>Functional programming is a programming paradigm that describes<br />
computation as the evaluation of mathematical functions avoiding state,<br />
mutual data and therefore side effects</p>

<p>Function programming based on applying functions to arguments in order<br />
to receive some desired values</p>

<p>The core idea for computation has shifted from a series of instructions<br />
(which specify precisely how the computation should proceed) to Notation<br />
of expressions, based on functions and values. You no longer have to<br />
follow a plan of instructions in order to understand a computation but<br />
decompose such an expression into its single elements.</p>

<h3 id="sequence-comprehensions">Sequence Comprehensions</h3>

<h3 id="tuple">Tuple</h3>

<pre><code>scala&gt; val t = (1,2)
t: (Int, Int) = (1,2)
 
scala&gt; val t = new Tuple2(1,2)
t: (Int, Int) = (1,2)

</code></pre>

<p>tuple是透過特殊index語法存取</p>

<pre><code>scala&gt; t._1
res3: Int = 1
 
scala&gt; t._2
res4: Int = 2

</code></pre>

<p>另外一種建立tuple的語法</p>

<pre><code>scala&gt; 1-&gt;2
res0: (Int, Int) = (1,2)

</code></pre>

<h3 id="extractors">Extractors</h3>

<p>利用 <code>unApply()</code> method搭配pattern match將資訊從class中萃取出來</p>

<h3 id="parser-combinators">Parser Combinators</h3>

<ul>
  <li>Christoph Henkelmann’s Blog - An Introduction To Scala Parser<br />
Combinators
    <ol>
      <li><a href="http://henkelmann.eu/2011/01/13/an_introduction_to_scala_parser_combinators" title="http://henkelmann.eu/2011/01/13/an_introduction_to_scala_parser_combinators">Part 1: Parser<br />
Basics</a></li>
      <li><a href="http://henkelmann.eu/2011/01/28/an_introduction_to_scala_parser_combinators-part_2_literal_expressions" title="http://henkelmann.eu/2011/01/28/an_introduction_to_scala_parser_combinators-part_2_literal_expressions">Part 2: Parsing Literal<br />
Expressions</a></li>
      <li><a href="http://henkelmann.eu/2011/01/29/an_introduction_to_scala_parser_combinators-part_3_unit_tests" title="http://henkelmann.eu/2011/01/29/an_introduction_to_scala_parser_combinators-part_3_unit_tests">An Introduction To Scala Parser Combinators - Part 3: Writing<br />
unit tests for<br />
parsers</a></li>
    </ol>
  </li>
</ul>

<h3 id="symbol-literals">Symbol Literals</h3>

<p>Symbol Literals是在字串前加一個單引號’，像這樣’foo</p>

<p>Symbol<br />
Literal主要作用是用來當作識別用，可以視為一個字串，但它不同於字串的地方有</p>

<ol>
  <li>不可以有任何空白</li>
  <li>一致性</li>
  <li>對重構比較友善</li>
</ol>

<p>像典型的map可以寫成這樣</p>

<pre><code>"key" -&gt; "value"

</code></pre>

<p>key的部份可以換成Symbol Literal取代</p>

<pre><code>'key -&gt; "value"

</code></pre>

<p>這樣的好處是，’key更能代表唯一性，而且，如果要進行重構，’key對於重構的支援會比”key”來的好，如果任何地方需要用字串當作識別的時侯，或者可以考慮換成用Symbol<br />
Literal取代</p>

<h1 id="tbd">TBD</h1>

<ul>
  <li>The Divide and Conquer principle</li>
  <li>Implicit Conversions and Parameters</li>
</ul>

<h1 id="resource">Resource</h1>

<ul>
  <li><a href="http://www.scala-lang.org/" title="http://www.scala-lang.org/">http://www.scala-lang.org/</a><br />
官網</li>
  <li><a href="http://docs.scala-lang.org/index.html" title="http://docs.scala-lang.org/index.html">http://docs.scala-lang.org/index.html</a><br />
官網文件</li>
  <li>Functional scala serial<br />
這一系列教學，很適合java背景，而且沒有function programming的人
    <ol>
      <li><a href="http://gleichmann.wordpress.com/2010/10/28/functional-scala-introduction/" title="http://gleichmann.wordpress.com/2010/10/28/functional-scala-introduction/">episode 1:<br />
Introduction</a></li>
      <li><a href="http://gleichmann.wordpress.com/2010/10/31/functional-scala-functions/" title="http://gleichmann.wordpress.com/2010/10/31/functional-scala-functions/">episode 2:<br />
Functions</a></li>
      <li><a href="http://gleichmann.wordpress.com/2010/11/08/functional-scala-functions-as-objects-as-functions/" title="http://gleichmann.wordpress.com/2010/11/08/functional-scala-functions-as-objects-as-functions/">episode 3: Functions as Objects as<br />
Functions</a></li>
      <li><a href="http://gleichmann.wordpress.com/2010/11/15/functional-scala-closures/" title="http://gleichmann.wordpress.com/2010/11/15/functional-scala-closures/">episode 4:<br />
Closures</a></li>
      <li><a href="http://gleichmann.wordpress.com/2010/11/21/functional-scala-comprehending-comprehensions/" title="http://gleichmann.wordpress.com/2010/11/21/functional-scala-comprehending-comprehensions/">episode 5: Comprehending<br />
Comprehensions</a></li>
      <li><a href="http://gleichmann.wordpress.com/2010/11/28/high-higher-higher-order-functions/" title="http://gleichmann.wordpress.com/2010/11/28/high-higher-higher-order-functions/">episode 6: High, Higher, Higher Order<br />
Functions</a></li>
      <li><a href="http://gleichmann.wordpress.com/2010/12/05/functional-scala-lambdas-and-other-shortcuts/" title="http://gleichmann.wordpress.com/2010/12/05/functional-scala-lambdas-and-other-shortcuts/">episode 7: Lambdas and other<br />
shortcuts</a></li>
    </ol>
  </li>
</ul>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Kent's Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Kent's Blog</li>
          <li><a href="mailto:kent.cwg@gmail.com">kent.cwg@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/kentchiu">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">kentchiu</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/kentchiu">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">kentchiu</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Kent的學習筆記</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
