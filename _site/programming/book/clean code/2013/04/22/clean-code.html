<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Clean Code閱讀筆記</title>
  <meta name="description" content="Table of contents">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://blog.kent-chiu.com//programming/book/clean%20code/2013/04/22/clean-code.html">
  <link rel="alternate" type="application/atom+xml" title="Kent's Blog" href="http://blog.kent-chiu.com//feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Kent's Blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Clean Code閱讀筆記</h1>
    <p class="post-meta">Apr 22, 2013 • Kent Chiu</p>
  </header>

  <article class="post-content">
    <h1 class="no_toc" id="table-of-contents">Table of contents</h1>

<ul id="markdown-toc">
  <li><a href="#section">代碼被讀取的次數遠比寫的次數多</a></li>
  <li><a href="#section-1">童子軍軍規</a></li>
  <li><a href="#section-2">命名</a>    <ul>
      <li><a href="#section-3">命名要能揭示他的意圖</a></li>
      <li><a href="#section-4">不要用不夠明確的字</a></li>
      <li><a href="#section-5">採用技術性的命名方式，而非領域性的命名方式</a></li>
      <li><a href="#class-name">Class Name</a></li>
      <li><a href="#section-6">命名的一致性</a></li>
    </ul>
  </li>
  <li><a href="#functions">Functions</a></li>
  <li><a href="#arguments">Arguments</a>    <ul>
      <li><a href="#section-7">回傳值</a></li>
    </ul>
  </li>
  <li><a href="#exceptions">Exceptions</a></li>
  <li><a href="#object-and-data-structures">Object And Data Structures</a></li>
  <li><a href="#boundaries">Boundaries</a>    <ul>
      <li><a href="#learning-tests">Learning tests</a></li>
    </ul>
  </li>
  <li><a href="#testings">Testings</a>    <ul>
      <li><a href="#first">F.I.R.S.T.</a></li>
    </ul>
  </li>
  <li><a href="#classes">Classes</a>    <ul>
      <li><a href="#section-8">保持精簡</a></li>
      <li><a href="#large-class-vs--small-class">少量的 Large Class V.S. 大量的 Small Class</a></li>
      <li><a href="#section-9">內聚力</a></li>
    </ul>
  </li>
  <li><a href="#emergence">Emergence</a>    <ul>
      <li><a href="#section-10">重構的方向</a></li>
    </ul>
  </li>
  <li><a href="#resource">Resource</a></li>
</ul>

<hr />

<h6 id="section">代碼被讀取的次數遠比寫的次數多</h6>

<p>之前只會以為這句是很正常不過的話，而且也認為通常是讀代碼的對象大多是自己，但 Uncle Bob 用一個 Editor Replay (讓編輯器或 IDE <br />
有類似 Media Player replay 的功能)的例子說明，當在 coding 時，在 method 間的查閱，呼叫，引用…等，這就是在閱讀自己的代碼了。<br />
也就是說，當要寫一個功能時，就一定會不斷的在閱讀自己的代碼了。</p>

<h6 id="section-1">童子軍軍規</h6>

<p>童子軍有一條軍規是<strong>讓營地比你來時更乾淨</strong>，套用在寫程式上，就是在每次的 checkin ，代碼應該都是要比 checkout 時更 clean</p>

<p>很多人都提到好的程式，不是一開始就規畫出來的，而且每天不斷不斷的重構、改進。重構這些也不用刻意安排時間去做，應該是在每次的 <br />
checkin / checkout 時就順手整理。</p>

<h2 id="section-2">命名</h2>

<h6 id="section-3">命名要能揭示他的意圖</h6>

<ul>
  <li>WHY  : 要能看出為何存在 </li>
  <li>WHAT : 要能看出做了什麼</li>
  <li>HOW  : 要能看出如何被使用 (是如何被使用，不是如何做)</li>
</ul>

<p>如果命名時還需要加上額外的注釋，就不會是個好的名字</p>

<h6 id="section-4">不要用不夠明確的字</h6>

<pre><code>getActiveAccount()
getActiveAccounts()
getActiveAccountInfo()
</code></pre>

<p>這三者並無法從名字上區分不同，應該要避免。 (不過個人覺得 account, accounts 是有作用的字，一個代表單數，一個代表複數資料結構)<br />
像是 <em>Info,Object,Data</em> 這樣的字，跟 a, an, the 一樣，太含混的字，不應該用來命名</p>

<p>也不用特意在命名時加上型別， ex: NameString, CustomerObject 因為在 IDE 幫助下，已經可以很方便的知道物件的型號了，不需要特別去加上類別資訊</p>

<h6 id="section-5">採用技術性的命名方式，而非領域性的命名方式</h6>

<p>會去看代碼的，大多是 programmer ，所以應該是用技術性的名字，像是 JobQuery, AccountVisitor 來取名字，而不是領域上的專業術語，如果一定要用到領域上的術語<br />
，那務必讓術語的名字與領域術語能一致。</p>

<blockquote>
  <p>私以為有時使用領域術語命名，會比較直覺，要維護該程式，應該要對該專業領域有所瞭解</p>
</blockquote>

<h4 id="class-name">Class Name</h4>

<ul>
  <li>不要有像 Info, Data, Processor這樣的字</li>
</ul>

<h4 id="section-6">命名的一致性</h4>

<ul>
  <li>像 fetch, retrieve, get 意義上相等的字，應該只取一組就好，不要有的 method 是用 get ，有的又用 fetech，還有的用 retrieve 這樣，使用 API 的人，搞不清楚要用那一套</li>
  <li>Driver, Manager, Controller 也是意義上相等的字，應該只取一組就好，因為很難從字面上分辨 DeviceManger 跟 DeviceController 會有什麼不同</li>
</ul>

<blockquote>
  <p>如果是實作上本身就有差異性 ex: insert 跟 append，那兩個近義字同時使用，是可被接授的</p>
</blockquote>

<h2 id="functions">Functions</h2>

<ul>
  <li>function 愈短愈好，但怎樣的長度叫短呢？ Uncle Martin 認為應該像 Kent Beck 的寫作風格一樣，每個 method 都不超過5行</li>
  <li>每個 if, else , while statement 的內容，應該要只有一行，可以用 function call (extract to function) 把內容濃縮成一行，<br />
這樣不但可以讓 method 改小，也可以增加可讀性，也就是說，程式裡只要出現 nest structure 就是一個可以做 extract 的訊號</li>
  <li>
    <p><em>一個 funciton 應該只作一件事</em>，但何謂一件事呢？如果 function 可以的部份內容可以被 extract 成另一個 funciton ，<br />
extract 後的 function 是一個完全不同於原來 function 的功能，而不只用另一個方式描述原來的功能，就代表了 function 坐了不止一件事</p>

    <pre><code>  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { 
    	if (isTestPage(pageData))
          includeSetupAndTeardownPages(pageData, isSuite); 
          return pageData.getHtml();
      }
  }
</code></pre>

    <p>如果將上面的 function extract 成 </p>

    <pre><code>  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { 
      return includeSetupsAndTeardownsIfTestPage(pageData, isSuite);
  }
	
  public static String includeSetupsAndTeardownsIfTestPage( PageData pageData, boolean isSuite) throws Exception { 	 
    	if (isTestPage(pageData))
          includeSetupAndTeardownPages(pageData, isSuite); 
          return pageData.getHtml();
      }
  }
</code></pre>

    <p>新的 <code>includeSetupsAndTeardownsIfTestPage</code> function 只是在用另外一種方式描述 <code>renderPageWithSetupsAndTeardowns()</code> 雖然可以這樣做 extract，<br />
但這不代表了原來的 <code>includeSetupsAndTeardownsIfTestPage</code>  做了不止一件事，因為新的 function 只是另一種方式來描述原來的 function,<br />
而如果一個 funtion 的內容，分了成幾個斷落 (sections)，顯示的，這也表明了這個 function 做了不止一件事</p>
  </li>
</ul>

<blockquote>
  <p>我試著去翻出 Kent Beck 最早期的 junit (3.4) 大多的 function 也都相當的短 (10行以下)， 也有少數比較長的，但也沒超過50行<br />
不過，讓每個 function 都小到了極致，那勢必會產生更多的 fucntions 或 classes 而造成 <em>Divergent Change（發散式變化</em> 或 <em>Shotgun Surgery（霰彈式修改)</em><br />
這部份，可透過package或class的重新組織，並秉持著single responsibility principle (單一職責原則)，通常就不會有太大的問題 </p>
</blockquote>

<ul>
  <li>functon 內的實作抽像等級應該要一致，不要同一個 function 內，有很高階的實作，又有很低階的實作<br />
高階，低階是指實作的抽象性，像 getHtml() 就是比較高階，而字串相加，就是屬於比較低階的實作</li>
  <li>small function 在取名上也比較容易，因為它只做一件事，就會比較容易給他一個相符的名稱，所以，如果 funciton 在命名上有困難時，也許就是該 funciton 做了不止一件事了</li>
</ul>

<h2 id="arguments">Arguments</h2>

<ul>
  <li>參數的數量愈少愈好，如果能沒有參數最好，三個參數應該已是最大值，四個參數應該是特殊狀況了</li>
  <li><em>參數數量多，程式的可測性也會降，更多的參數，將需要更多的測試</em>，因為參數的排列組合的方式會更多，需要更多的測試</li>
  <li>用布林當參數時，通常代表該 function 可以被切割成兩個 function</li>
</ul>

<h4 id="section-7">回傳值</h4>

<ul>
  <li>應儘量避免使用回傳值，如果回傳值是為了改變某個狀態，應該要直接改變物件本身</li>
</ul>

<h2 id="exceptions">Exceptions</h2>

<ul>
  <li>例外處理的 try / catch / finally 本身就是<em>一件事</em>，不可做切割</li>
  <li>例外處理不要值用error code，不然會造成所有人都依賴的這個 error code，要異動時，一定得去異動 error code</li>
</ul>

<h2 id="object-and-data-structures">Object And Data Structures</h2>

<p>這樣的code，違反了Law of Demeter</p>

<pre><code>final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
</code></pre>

<p>最好改成這樣</p>

<pre><code>Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
</code></pre>

<p>不選，如果一個 function 像這樣包含了太多相關的物件，那就應該考慮是不是有責任歸屬的問題，重新釐清每個物件的責任後，或許會有所改善</p>

<h2 id="boundaries">Boundaries</h2>

<p>如果需要在物件間傳遞 Map, List, Set 結構時，可以將它包成物件. </p>

<h4 id="learning-tests">Learning tests</h4>

<p>使用 third-party lib 是件不同易的事，要對 thrid-party lib 整合更是不容易，我們可以透過讀閱讀過文件後，寫一些簡單來驗証 lib 行為，是不是跟我們所理解的一樣。<br />
這樣的測試叫 Learning tests。</p>

<h2 id="testings">Testings</h2>

<ul>
  <li>可讀性對 test code 比 production code 更重要。</li>
  <li>專業的程式員應該要將測試重構成更具描述性的表達方式</li>
  <li>每個 test case 裡的 asssertions 應該要儘可能的少，有人甚至主張一個 test case 只能有一個 assertion，至少應該儘量保持 singal concept per test</li>
</ul>

<p>BDD Given/When/Then test case 的寫法</p>

<pre><code>
	public void testGetPageHierarchyAsXml() throws Exception { 
		givenPages("PageOne", "PageOne.ChildOne", "PageTwo");
		whenRequestIsIssued("root", "type:pages");
		thenResponseShouldBeXML();
	 }


	public void testGetPageHierarchyHasRightTags() throws Exception { 
		givenPages("PageOne", "PageOne.ChildOne", "PageTwo");
		whenRequestIsIssued("root", "type:pages");
		thenResponseShouldContain("&lt;name&gt;PageOne&lt;/name&gt;", "&lt;name&gt;PageTwo&lt;/name&gt;", "&lt;name&gt;ChildOne&lt;/name&gt;"); 
	}

</code></pre>

<h6 id="first">F.I.R.S.T.</h6>

<ul>
  <li>Fast 執行起來要夠快，才會經常去執行</li>
  <li>Independent 獨立，不需要 testing code 及 production code 以外的東西，像是還要手動設定資料庫，或一定要網路連線</li>
  <li>Repeatable 可重覆 (可重現)</li>
  <li>Self-Validating  簡單而明確的指出測式的結果 (red bar / green bar) 跟失敗的原因</li>
  <li>Timely 測試要在 proudction code 之前寫好，而不是寫好了 production code 再來寫測式 ( test first or TDD )</li>
</ul>

<h2 id="classes">Classes</h2>

<p>Uncle Bob 提倡<em>報紙代排版</em>，也就是 functions 不是換按照 scope ( public -&gt; package -&gt; protected -&gt; private )，而是照閱讀順序 (stepdown)，<br />
一般以 plulic scope 的 fucntion 開始，緊接著是依該 public 裡值用到的順序做排列， 這樣會像報紙一樣，以上至下的閱讀。</p>

<blockquote>
  <p>目前要採用這種方式， IDE (eclipse , interllij ) 目前並沒有支援，況且，如果 function 被多個 function 呼叫， 被呼叫的 function 要放那，也是一個問題。<br />
目前 ide 都有 function 的 outline 可以快速跳掉某個 function ， eclipse 也有可以直接看另一個被呼叫的 function viewer ，<br />
私以為 newspaper format 不是那麼必要。 </p>
</blockquote>

<h4 id="section-8">保持精簡</h4>

<p>Class 應該儘可能的小，但要小到多少？用 function 的數量來計數比是那麼的精確，用檔案大小來計算，更是不容易反應出 class <br />
的真實大小，在計算 classs 的大小採用的是所讀的<em>職責數</em>，在 OOP 五大定理原則裡有一個叫 SPR (Single Responsibility <br />
Principle), 中文為<em>單一職責原則</em>，單一職責原則要求每個 class 應該只有一個責任（只做一件事），所以，我們可以用　class<br />
是否做了太多的事來判斷 class 是不是太大。</p>

<blockquote>
  <p>用比較實務上的方式來解釋<em>單一職責原則</em>的話，可以這樣說: 當同一個物件需要異動時，應該都是基於相同的理由</p>
</blockquote>

<pre><code>public class SuperDashboard extends JFrame implements MetaDataUser public Component getLastFocusedComponent()
public void setLastFocused(Component lastFocused)
public int getMajorVersionNumber()
public int getMinorVersionNumber()
public int getBuildNumber() }
</code></pre>

<p>以上面的 SuperDashboard class 來說，它就具備了兩個職責</p>

<ol>
  <li>版本資訊</li>
  <li>Java Swing的物件結構</li>
</ol>

<p>所以，當出貨時(理由一)，版本資訊需要異動， focus (GUI 元件的 foucs)異動時，也可能會改變 SuperDashboard，所以這個 class 應該再被細分。</p>

<h4 id="large-class-vs--small-class">少量的 Large Class V.S. 大量的 Small Class</h4>

<p>在設計 class 時，多數人更偏好寫一個很大的 class 而不是 許多的小 classes，因為這樣可以不用在 class見跳來跳去的閱讀，可以在同一個檔<br />
案裡找到所有需要的東西，覺得畫分成小的 class 反而是造成程式可讀性不佳的原兇。其實，<strong>這一定是個誤會</strong>，切成許多單一職責的 classes，<br />
只要透過系統化的分類，不但可以更快的找到需要的功能。</p>

<p>舉例來說，將許多的小零件分門別類的放在工具箱的小抽遞內，一定比全部混放在一個大抽遞更能被快速的找到。所以，不要害怕 class 的切割，做好<br />
SPR，其他的問題，可以透過系統化的組織來解決 class 過多的問題，而且 Small Class 在 reused的效果上也更好，測試上也比較容易。</p>

<h4 id="section-9">內聚力</h4>

<p>class 的 instance variables 的被 class 內的 methods 引用的次數愈多，表示其內聚力愈強，如果一個類別的內聚力太低時，就應該考慮是否做切割。</p>

<blockquote>
  <p>內聚力太低時，通常也代表 instance variables 數量太多，某些可能只被特定的 methods 引用，那可能就意味這些 methods 應該被<br />
extract 出去成為另一個獨立的 class， 這樣對兩個 classes 來說，都會有更高的內聚力</p>
</blockquote>

<h2 id="emergence">Emergence</h2>

<p>Kent Beck’s Xp Simplicity Rules:</p>

<ol>
  <li>Runs all the tests</li>
  <li>Contains no duplication</li>
  <li>Expresses the intent of the programmer</li>
  <li>Minimizes the number of classes and methods</li>
</ol>

<p>ref: <a href="http://c2.com/cgi/wiki?XpSimplicityRules">http://c2.com/cgi/wiki?XpSimplicityRules</a></p>

<h4 id="section-10">重構的方向</h4>

<ol>
  <li>去除重覆</li>
  <li>可讀性</li>
  <li>保持最少跟最小的 classes, methods</li>
</ol>

<h2 id="resource">Resource</h2>

<ul>
  <li>planetgeek.ch 整理的clean code cheetsheet <a href="http://www.planetgeek.ch/2013/06/05/clean-code-cheat-sheet/">http://www.planetgeek.ch/2013/06/05/clean-code-cheat-sheet/</a> , <a href="http://blog.kent-chiu.com/images/blog/2013-04-22/Clean-Code-V2.2.pdf">備份檔</a></li>
</ul>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Kent's Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Kent's Blog</li>
          <li><a href="mailto:kent.cwg@gmail.com">kent.cwg@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/kentchiu">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">kentchiu</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/kentchiu">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">kentchiu</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Kent的學習筆記</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
